'''
# -*- coding: utf-8 -*-
# code generated by Prisma. DO NOT EDIT.
# pyright: reportUnusedImport=false
# fmt: off

# global imports for type checking
from typing import (
    TYPE_CHECKING,
    Any,
    Dict,
    List,
    Union,
    Literal,
    TypeVar,
    TypedDict,
)
from builtins import str as _str

LiteralString = str
# -- template types/_model.py.jinja --
# Types for model: C

from ..utils import _NoneType
from .atomic import *  # noqa: TID251
from .filters import *  # noqa: TID251
from .list_filters import *  # noqa: TID251

# Cross-import related model types for type checker resolution
if TYPE_CHECKING:
    from .a import (  # noqa: TID251
        AWhereInput,
        AOrderByInput,
        AScalarFieldKeys,
        AWhereUniqueInput,
    )
    from .b import (  # noqa: TID251
        BWhereInput,
        BOrderByInput,
        BScalarFieldKeys,
        BWhereUniqueInput,
    )
    from .d import (  # noqa: TID251
        DWhereInput,
        DOrderByInput,
        DScalarFieldKeys,
        DWhereUniqueInput,
    )
    from .e import (  # noqa: TID251
        EWhereInput,
        EOrderByInput,
        EScalarFieldKeys,
        EWhereUniqueInput,
    )
    from .m import (  # noqa: TID251
        MWhereInput,
        MOrderByInput,
        MScalarFieldKeys,
        MWhereUniqueInput,
    )
    from .n import (  # noqa: TID251
        NWhereInput,
        NOrderByInput,
        NScalarFieldKeys,
        NWhereUniqueInput,
    )
    from .post import (  # noqa: TID251
        PostWhereInput,
        PostOrderByInput,
        PostScalarFieldKeys,
        PostWhereUniqueInput,
    )
    from .user import (  # noqa: TID251
        UserWhereInput,
        UserOrderByInput,
        UserScalarFieldKeys,
        UserWhereUniqueInput,
    )
    from .lists import (  # noqa: TID251
        ListsWhereInput,
        ListsOrderByInput,
        ListsScalarFieldKeys,
        ListsWhereUniqueInput,
    )
    from .oneoptional import (  # noqa: TID251
        OneOptionalWhereInput,
        OneOptionalOrderByInput,
        OneOptionalScalarFieldKeys,
        OneOptionalWhereUniqueInput,
    )
    from .manyrequired import (  # noqa: TID251
        ManyRequiredWhereInput,
        ManyRequiredOrderByInput,
        ManyRequiredScalarFieldKeys,
        ManyRequiredWhereUniqueInput,
    )





# C types

class COptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the C create method"""


class CCreateInput(COptionalCreateInput):
    """Required arguments to the C create method"""
    char: _str
    v_char: _str
    text: _str
    bit: _str
    v_bit: _str
    uuid: _str


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class COptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the C create method, without relations"""


class CCreateWithoutRelationsInput(COptionalCreateWithoutRelationsInput):
    """Required arguments to the C create method, without relations"""
    char: _str
    v_char: _str
    text: _str
    bit: _str
    v_bit: _str
    uuid: _str

class CConnectOrCreateWithoutRelationsInput(TypedDict):
    create: 'CCreateWithoutRelationsInput'
    where: 'CWhereUniqueInput'

class CCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'CCreateWithoutRelationsInput'
    connect: 'CWhereUniqueInput'
    connect_or_create: 'CConnectOrCreateWithoutRelationsInput'


class CCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['CCreateWithoutRelationsInput', List['CCreateWithoutRelationsInput']]
    connect: Union['CWhereUniqueInput', List['CWhereUniqueInput']]
    connect_or_create: Union['CConnectOrCreateWithoutRelationsInput', List['CConnectOrCreateWithoutRelationsInput']]

_CCompoundPrimaryKeyInner = TypedDict(
    '_CCompoundPrimaryKeyInner',
    {
        'char': '_str',
        'text': '_str',
    },
    total=True
)

_CCompoundPrimaryKey = TypedDict(
    '_CCompoundPrimaryKey',
    {
        'my_id': '_CCompoundPrimaryKeyInner',
    },
    total=True
)

CWhereUniqueInput = _CCompoundPrimaryKey


class CUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    char: _str
    v_char: _str
    text: _str
    bit: _str
    v_bit: _str
    uuid: _str


class CUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    char: _str
    v_char: _str
    text: _str
    bit: _str
    v_bit: _str
    uuid: _str


class CUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['CCreateWithoutRelationsInput']
    connect: List['CWhereUniqueInput']
    connect_or_create: List['CConnectOrCreateWithoutRelationsInput']
    set: List['CWhereUniqueInput']
    disconnect: List['CWhereUniqueInput']
    delete: List['CWhereUniqueInput']

    # TODO
    # update: List['CUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['CUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['CScalarWhereInput']
    # upsert: List['CUpserteWithWhereUniqueWithoutRelationsInput']


class CUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'CCreateWithoutRelationsInput'
    connect: 'CWhereUniqueInput'
    connect_or_create: 'CConnectOrCreateWithoutRelationsInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'CUpdateInput'
    # upsert: 'CUpsertWithoutRelationsInput'


class CUpsertInput(TypedDict):
    create: 'CCreateInput'
    update: 'CUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_C_char_OrderByInput = TypedDict(
    '_C_char_OrderByInput',
    {
        'char': 'SortOrder',
    },
    total=True
)

_C_v_char_OrderByInput = TypedDict(
    '_C_v_char_OrderByInput',
    {
        'v_char': 'SortOrder',
    },
    total=True
)

_C_text_OrderByInput = TypedDict(
    '_C_text_OrderByInput',
    {
        'text': 'SortOrder',
    },
    total=True
)

_C_bit_OrderByInput = TypedDict(
    '_C_bit_OrderByInput',
    {
        'bit': 'SortOrder',
    },
    total=True
)

_C_v_bit_OrderByInput = TypedDict(
    '_C_v_bit_OrderByInput',
    {
        'v_bit': 'SortOrder',
    },
    total=True
)

_C_uuid_OrderByInput = TypedDict(
    '_C_uuid_OrderByInput',
    {
        'uuid': 'SortOrder',
    },
    total=True
)

_C_RelevanceInner = TypedDict(
    '_C_RelevanceInner',
    {
        'fields': 'List[CScalarFieldKeys]',
        'search': 'str',
        'sort': 'SortOrder',
    },
    total=True
)

_C_RelevanceOrderByInput = TypedDict(
    '_C_RelevanceOrderByInput',
    {
        '_relevance': '_C_RelevanceInner',
    },
    total=True
)

COrderByInput = Union[
    '_C_char_OrderByInput',
    '_C_v_char_OrderByInput',
    '_C_text_OrderByInput',
    '_C_bit_OrderByInput',
    '_C_v_bit_OrderByInput',
    '_C_uuid_OrderByInput',
    '_C_RelevanceOrderByInput',
]



# recursive C types
# TODO: cleanup these types


# Dict[str, Any] is a mypy limitation
# see https://github.com/RobertCraigie/prisma-client-py/issues/45
# switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/stable/reference/limitations/

CRelationFilter = TypedDict(
    'CRelationFilter',
    {
        'is': 'Dict[str, Any]',
        'is_not': 'Dict[str, Any]',
    },
    total=False,
)


class CListRelationFilter(TypedDict, total=False):
    some: 'Dict[str, Any]'
    none: 'Dict[str, Any]'
    every: 'Dict[str, Any]'


class CInclude(TypedDict, total=False):
    """C relational arguments"""


    

class PostIncludeFromC(TypedDict, total=False):
    """Relational arguments for C"""
    author: Union[bool, 'UserArgsFromCRecursive1']


class PostIncludeFromCRecursive1(TypedDict, total=False):
    """Relational arguments for C"""
    author: Union[bool, 'UserArgsFromCRecursive2']


class PostIncludeFromCRecursive2(TypedDict, total=False):
    """Relational arguments for C"""

    

class PostArgsFromC(TypedDict, total=False):
    """Arguments for C"""
    include: 'PostIncludeFromCRecursive1'


class PostArgsFromCRecursive1(TypedDict, total=False):
    """Arguments for C"""
    include: 'PostIncludeFromCRecursive2'


class PostArgsFromCRecursive2(TypedDict, total=False):
    """Arguments for C"""
    
    

class FindManyPostArgsFromC(TypedDict, total=False):
    """Arguments for C"""
    take: int
    skip: int
    order_by: Union['PostOrderByInput', List['PostOrderByInput']]
    where: 'PostWhereInput'
    cursor: 'PostWhereUniqueInput'
    distinct: List['PostScalarFieldKeys']
    include: 'PostIncludeFromCRecursive1'


class FindManyPostArgsFromCRecursive1(TypedDict, total=False):
    """Arguments for C"""
    take: int
    skip: int
    order_by: Union['PostOrderByInput', List['PostOrderByInput']]
    where: 'PostWhereInput'
    cursor: 'PostWhereUniqueInput'
    distinct: List['PostScalarFieldKeys']
    include: 'PostIncludeFromCRecursive2'


class FindManyPostArgsFromCRecursive2(TypedDict, total=False):
    """Arguments for C"""
    take: int
    skip: int
    order_by: Union['PostOrderByInput', List['PostOrderByInput']]
    where: 'PostWhereInput'
    cursor: 'PostWhereUniqueInput'
    distinct: List['PostScalarFieldKeys']
        

class UserIncludeFromC(TypedDict, total=False):
    """Relational arguments for C"""
    posts: Union[bool, 'FindManyPostArgsFromCRecursive1']


class UserIncludeFromCRecursive1(TypedDict, total=False):
    """Relational arguments for C"""
    posts: Union[bool, 'FindManyPostArgsFromCRecursive2']


class UserIncludeFromCRecursive2(TypedDict, total=False):
    """Relational arguments for C"""

    

class UserArgsFromC(TypedDict, total=False):
    """Arguments for C"""
    include: 'UserIncludeFromCRecursive1'


class UserArgsFromCRecursive1(TypedDict, total=False):
    """Arguments for C"""
    include: 'UserIncludeFromCRecursive2'


class UserArgsFromCRecursive2(TypedDict, total=False):
    """Arguments for C"""
    
    

class FindManyUserArgsFromC(TypedDict, total=False):
    """Arguments for C"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromCRecursive1'


class FindManyUserArgsFromCRecursive1(TypedDict, total=False):
    """Arguments for C"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromCRecursive2'


class FindManyUserArgsFromCRecursive2(TypedDict, total=False):
    """Arguments for C"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
        

class MIncludeFromC(TypedDict, total=False):
    """Relational arguments for C"""
    n: Union[bool, 'FindManyNArgsFromCRecursive1']


class MIncludeFromCRecursive1(TypedDict, total=False):
    """Relational arguments for C"""
    n: Union[bool, 'FindManyNArgsFromCRecursive2']


class MIncludeFromCRecursive2(TypedDict, total=False):
    """Relational arguments for C"""

    

class MArgsFromC(TypedDict, total=False):
    """Arguments for C"""
    include: 'MIncludeFromCRecursive1'


class MArgsFromCRecursive1(TypedDict, total=False):
    """Arguments for C"""
    include: 'MIncludeFromCRecursive2'


class MArgsFromCRecursive2(TypedDict, total=False):
    """Arguments for C"""
    
    

class FindManyMArgsFromC(TypedDict, total=False):
    """Arguments for C"""
    take: int
    skip: int
    order_by: Union['MOrderByInput', List['MOrderByInput']]
    where: 'MWhereInput'
    cursor: 'MWhereUniqueInput'
    distinct: List['MScalarFieldKeys']
    include: 'MIncludeFromCRecursive1'


class FindManyMArgsFromCRecursive1(TypedDict, total=False):
    """Arguments for C"""
    take: int
    skip: int
    order_by: Union['MOrderByInput', List['MOrderByInput']]
    where: 'MWhereInput'
    cursor: 'MWhereUniqueInput'
    distinct: List['MScalarFieldKeys']
    include: 'MIncludeFromCRecursive2'


class FindManyMArgsFromCRecursive2(TypedDict, total=False):
    """Arguments for C"""
    take: int
    skip: int
    order_by: Union['MOrderByInput', List['MOrderByInput']]
    where: 'MWhereInput'
    cursor: 'MWhereUniqueInput'
    distinct: List['MScalarFieldKeys']
        

class NIncludeFromC(TypedDict, total=False):
    """Relational arguments for C"""
    m: Union[bool, 'FindManyMArgsFromCRecursive1']


class NIncludeFromCRecursive1(TypedDict, total=False):
    """Relational arguments for C"""
    m: Union[bool, 'FindManyMArgsFromCRecursive2']


class NIncludeFromCRecursive2(TypedDict, total=False):
    """Relational arguments for C"""

    

class NArgsFromC(TypedDict, total=False):
    """Arguments for C"""
    include: 'NIncludeFromCRecursive1'


class NArgsFromCRecursive1(TypedDict, total=False):
    """Arguments for C"""
    include: 'NIncludeFromCRecursive2'


class NArgsFromCRecursive2(TypedDict, total=False):
    """Arguments for C"""
    
    

class FindManyNArgsFromC(TypedDict, total=False):
    """Arguments for C"""
    take: int
    skip: int
    order_by: Union['NOrderByInput', List['NOrderByInput']]
    where: 'NWhereInput'
    cursor: 'NWhereUniqueInput'
    distinct: List['NScalarFieldKeys']
    include: 'NIncludeFromCRecursive1'


class FindManyNArgsFromCRecursive1(TypedDict, total=False):
    """Arguments for C"""
    take: int
    skip: int
    order_by: Union['NOrderByInput', List['NOrderByInput']]
    where: 'NWhereInput'
    cursor: 'NWhereUniqueInput'
    distinct: List['NScalarFieldKeys']
    include: 'NIncludeFromCRecursive2'


class FindManyNArgsFromCRecursive2(TypedDict, total=False):
    """Arguments for C"""
    take: int
    skip: int
    order_by: Union['NOrderByInput', List['NOrderByInput']]
    where: 'NWhereInput'
    cursor: 'NWhereUniqueInput'
    distinct: List['NScalarFieldKeys']
        

class OneOptionalIncludeFromC(TypedDict, total=False):
    """Relational arguments for C"""
    many: Union[bool, 'FindManyManyRequiredArgsFromCRecursive1']


class OneOptionalIncludeFromCRecursive1(TypedDict, total=False):
    """Relational arguments for C"""
    many: Union[bool, 'FindManyManyRequiredArgsFromCRecursive2']


class OneOptionalIncludeFromCRecursive2(TypedDict, total=False):
    """Relational arguments for C"""

    

class OneOptionalArgsFromC(TypedDict, total=False):
    """Arguments for C"""
    include: 'OneOptionalIncludeFromCRecursive1'


class OneOptionalArgsFromCRecursive1(TypedDict, total=False):
    """Arguments for C"""
    include: 'OneOptionalIncludeFromCRecursive2'


class OneOptionalArgsFromCRecursive2(TypedDict, total=False):
    """Arguments for C"""
    
    

class FindManyOneOptionalArgsFromC(TypedDict, total=False):
    """Arguments for C"""
    take: int
    skip: int
    order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
    where: 'OneOptionalWhereInput'
    cursor: 'OneOptionalWhereUniqueInput'
    distinct: List['OneOptionalScalarFieldKeys']
    include: 'OneOptionalIncludeFromCRecursive1'


class FindManyOneOptionalArgsFromCRecursive1(TypedDict, total=False):
    """Arguments for C"""
    take: int
    skip: int
    order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
    where: 'OneOptionalWhereInput'
    cursor: 'OneOptionalWhereUniqueInput'
    distinct: List['OneOptionalScalarFieldKeys']
    include: 'OneOptionalIncludeFromCRecursive2'


class FindManyOneOptionalArgsFromCRecursive2(TypedDict, total=False):
    """Arguments for C"""
    take: int
    skip: int
    order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
    where: 'OneOptionalWhereInput'
    cursor: 'OneOptionalWhereUniqueInput'
    distinct: List['OneOptionalScalarFieldKeys']
        

class ManyRequiredIncludeFromC(TypedDict, total=False):
    """Relational arguments for C"""
    one: Union[bool, 'OneOptionalArgsFromCRecursive1']


class ManyRequiredIncludeFromCRecursive1(TypedDict, total=False):
    """Relational arguments for C"""
    one: Union[bool, 'OneOptionalArgsFromCRecursive2']


class ManyRequiredIncludeFromCRecursive2(TypedDict, total=False):
    """Relational arguments for C"""

    

class ManyRequiredArgsFromC(TypedDict, total=False):
    """Arguments for C"""
    include: 'ManyRequiredIncludeFromCRecursive1'


class ManyRequiredArgsFromCRecursive1(TypedDict, total=False):
    """Arguments for C"""
    include: 'ManyRequiredIncludeFromCRecursive2'


class ManyRequiredArgsFromCRecursive2(TypedDict, total=False):
    """Arguments for C"""
    
    

class FindManyManyRequiredArgsFromC(TypedDict, total=False):
    """Arguments for C"""
    take: int
    skip: int
    order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
    where: 'ManyRequiredWhereInput'
    cursor: 'ManyRequiredWhereUniqueInput'
    distinct: List['ManyRequiredScalarFieldKeys']
    include: 'ManyRequiredIncludeFromCRecursive1'


class FindManyManyRequiredArgsFromCRecursive1(TypedDict, total=False):
    """Arguments for C"""
    take: int
    skip: int
    order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
    where: 'ManyRequiredWhereInput'
    cursor: 'ManyRequiredWhereUniqueInput'
    distinct: List['ManyRequiredScalarFieldKeys']
    include: 'ManyRequiredIncludeFromCRecursive2'


class FindManyManyRequiredArgsFromCRecursive2(TypedDict, total=False):
    """Arguments for C"""
    take: int
    skip: int
    order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
    where: 'ManyRequiredWhereInput'
    cursor: 'ManyRequiredWhereUniqueInput'
    distinct: List['ManyRequiredScalarFieldKeys']
        

class ListsIncludeFromC(TypedDict, total=False):
    """Relational arguments for C"""


class ListsIncludeFromCRecursive1(TypedDict, total=False):
    """Relational arguments for C"""


class ListsIncludeFromCRecursive2(TypedDict, total=False):
    """Relational arguments for C"""

    

class ListsArgsFromC(TypedDict, total=False):
    """Arguments for C"""
    include: 'ListsIncludeFromCRecursive1'


class ListsArgsFromCRecursive1(TypedDict, total=False):
    """Arguments for C"""
    include: 'ListsIncludeFromCRecursive2'


class ListsArgsFromCRecursive2(TypedDict, total=False):
    """Arguments for C"""
    
    

class FindManyListsArgsFromC(TypedDict, total=False):
    """Arguments for C"""
    take: int
    skip: int
    order_by: Union['ListsOrderByInput', List['ListsOrderByInput']]
    where: 'ListsWhereInput'
    cursor: 'ListsWhereUniqueInput'
    distinct: List['ListsScalarFieldKeys']
    include: 'ListsIncludeFromCRecursive1'


class FindManyListsArgsFromCRecursive1(TypedDict, total=False):
    """Arguments for C"""
    take: int
    skip: int
    order_by: Union['ListsOrderByInput', List['ListsOrderByInput']]
    where: 'ListsWhereInput'
    cursor: 'ListsWhereUniqueInput'
    distinct: List['ListsScalarFieldKeys']
    include: 'ListsIncludeFromCRecursive2'


class FindManyListsArgsFromCRecursive2(TypedDict, total=False):
    """Arguments for C"""
    take: int
    skip: int
    order_by: Union['ListsOrderByInput', List['ListsOrderByInput']]
    where: 'ListsWhereInput'
    cursor: 'ListsWhereUniqueInput'
    distinct: List['ListsScalarFieldKeys']
        

class AIncludeFromC(TypedDict, total=False):
    """Relational arguments for C"""


class AIncludeFromCRecursive1(TypedDict, total=False):
    """Relational arguments for C"""


class AIncludeFromCRecursive2(TypedDict, total=False):
    """Relational arguments for C"""

    

class AArgsFromC(TypedDict, total=False):
    """Arguments for C"""
    include: 'AIncludeFromCRecursive1'


class AArgsFromCRecursive1(TypedDict, total=False):
    """Arguments for C"""
    include: 'AIncludeFromCRecursive2'


class AArgsFromCRecursive2(TypedDict, total=False):
    """Arguments for C"""
    
    

class FindManyAArgsFromC(TypedDict, total=False):
    """Arguments for C"""
    take: int
    skip: int
    order_by: Union['AOrderByInput', List['AOrderByInput']]
    where: 'AWhereInput'
    cursor: 'AWhereUniqueInput'
    distinct: List['AScalarFieldKeys']
    include: 'AIncludeFromCRecursive1'


class FindManyAArgsFromCRecursive1(TypedDict, total=False):
    """Arguments for C"""
    take: int
    skip: int
    order_by: Union['AOrderByInput', List['AOrderByInput']]
    where: 'AWhereInput'
    cursor: 'AWhereUniqueInput'
    distinct: List['AScalarFieldKeys']
    include: 'AIncludeFromCRecursive2'


class FindManyAArgsFromCRecursive2(TypedDict, total=False):
    """Arguments for C"""
    take: int
    skip: int
    order_by: Union['AOrderByInput', List['AOrderByInput']]
    where: 'AWhereInput'
    cursor: 'AWhereUniqueInput'
    distinct: List['AScalarFieldKeys']
        

class BIncludeFromC(TypedDict, total=False):
    """Relational arguments for C"""


class BIncludeFromCRecursive1(TypedDict, total=False):
    """Relational arguments for C"""


class BIncludeFromCRecursive2(TypedDict, total=False):
    """Relational arguments for C"""

    

class BArgsFromC(TypedDict, total=False):
    """Arguments for C"""
    include: 'BIncludeFromCRecursive1'


class BArgsFromCRecursive1(TypedDict, total=False):
    """Arguments for C"""
    include: 'BIncludeFromCRecursive2'


class BArgsFromCRecursive2(TypedDict, total=False):
    """Arguments for C"""
    
    

class FindManyBArgsFromC(TypedDict, total=False):
    """Arguments for C"""
    take: int
    skip: int
    order_by: Union['BOrderByInput', List['BOrderByInput']]
    where: 'BWhereInput'
    cursor: 'BWhereUniqueInput'
    distinct: List['BScalarFieldKeys']
    include: 'BIncludeFromCRecursive1'


class FindManyBArgsFromCRecursive1(TypedDict, total=False):
    """Arguments for C"""
    take: int
    skip: int
    order_by: Union['BOrderByInput', List['BOrderByInput']]
    where: 'BWhereInput'
    cursor: 'BWhereUniqueInput'
    distinct: List['BScalarFieldKeys']
    include: 'BIncludeFromCRecursive2'


class FindManyBArgsFromCRecursive2(TypedDict, total=False):
    """Arguments for C"""
    take: int
    skip: int
    order_by: Union['BOrderByInput', List['BOrderByInput']]
    where: 'BWhereInput'
    cursor: 'BWhereUniqueInput'
    distinct: List['BScalarFieldKeys']
        

class CIncludeFromC(TypedDict, total=False):
    """Relational arguments for C"""


class CIncludeFromCRecursive1(TypedDict, total=False):
    """Relational arguments for C"""


class CIncludeFromCRecursive2(TypedDict, total=False):
    """Relational arguments for C"""

    

class CArgsFromC(TypedDict, total=False):
    """Arguments for C"""
    include: 'CIncludeFromCRecursive1'


class CArgsFromCRecursive1(TypedDict, total=False):
    """Arguments for C"""
    include: 'CIncludeFromCRecursive2'


class CArgsFromCRecursive2(TypedDict, total=False):
    """Arguments for C"""
    
    

class FindManyCArgsFromC(TypedDict, total=False):
    """Arguments for C"""
    take: int
    skip: int
    order_by: Union['COrderByInput', List['COrderByInput']]
    where: 'CWhereInput'
    cursor: 'CWhereUniqueInput'
    distinct: List['CScalarFieldKeys']
    include: 'CIncludeFromCRecursive1'


class FindManyCArgsFromCRecursive1(TypedDict, total=False):
    """Arguments for C"""
    take: int
    skip: int
    order_by: Union['COrderByInput', List['COrderByInput']]
    where: 'CWhereInput'
    cursor: 'CWhereUniqueInput'
    distinct: List['CScalarFieldKeys']
    include: 'CIncludeFromCRecursive2'


class FindManyCArgsFromCRecursive2(TypedDict, total=False):
    """Arguments for C"""
    take: int
    skip: int
    order_by: Union['COrderByInput', List['COrderByInput']]
    where: 'CWhereInput'
    cursor: 'CWhereUniqueInput'
    distinct: List['CScalarFieldKeys']
        

class DIncludeFromC(TypedDict, total=False):
    """Relational arguments for C"""


class DIncludeFromCRecursive1(TypedDict, total=False):
    """Relational arguments for C"""


class DIncludeFromCRecursive2(TypedDict, total=False):
    """Relational arguments for C"""

    

class DArgsFromC(TypedDict, total=False):
    """Arguments for C"""
    include: 'DIncludeFromCRecursive1'


class DArgsFromCRecursive1(TypedDict, total=False):
    """Arguments for C"""
    include: 'DIncludeFromCRecursive2'


class DArgsFromCRecursive2(TypedDict, total=False):
    """Arguments for C"""
    
    

class FindManyDArgsFromC(TypedDict, total=False):
    """Arguments for C"""
    take: int
    skip: int
    order_by: Union['DOrderByInput', List['DOrderByInput']]
    where: 'DWhereInput'
    cursor: 'DWhereUniqueInput'
    distinct: List['DScalarFieldKeys']
    include: 'DIncludeFromCRecursive1'


class FindManyDArgsFromCRecursive1(TypedDict, total=False):
    """Arguments for C"""
    take: int
    skip: int
    order_by: Union['DOrderByInput', List['DOrderByInput']]
    where: 'DWhereInput'
    cursor: 'DWhereUniqueInput'
    distinct: List['DScalarFieldKeys']
    include: 'DIncludeFromCRecursive2'


class FindManyDArgsFromCRecursive2(TypedDict, total=False):
    """Arguments for C"""
    take: int
    skip: int
    order_by: Union['DOrderByInput', List['DOrderByInput']]
    where: 'DWhereInput'
    cursor: 'DWhereUniqueInput'
    distinct: List['DScalarFieldKeys']
        

class EIncludeFromC(TypedDict, total=False):
    """Relational arguments for C"""


class EIncludeFromCRecursive1(TypedDict, total=False):
    """Relational arguments for C"""


class EIncludeFromCRecursive2(TypedDict, total=False):
    """Relational arguments for C"""

    

class EArgsFromC(TypedDict, total=False):
    """Arguments for C"""
    include: 'EIncludeFromCRecursive1'


class EArgsFromCRecursive1(TypedDict, total=False):
    """Arguments for C"""
    include: 'EIncludeFromCRecursive2'


class EArgsFromCRecursive2(TypedDict, total=False):
    """Arguments for C"""
    
    

class FindManyEArgsFromC(TypedDict, total=False):
    """Arguments for C"""
    take: int
    skip: int
    order_by: Union['EOrderByInput', List['EOrderByInput']]
    where: 'EWhereInput'
    cursor: 'EWhereUniqueInput'
    distinct: List['EScalarFieldKeys']
    include: 'EIncludeFromCRecursive1'


class FindManyEArgsFromCRecursive1(TypedDict, total=False):
    """Arguments for C"""
    take: int
    skip: int
    order_by: Union['EOrderByInput', List['EOrderByInput']]
    where: 'EWhereInput'
    cursor: 'EWhereUniqueInput'
    distinct: List['EScalarFieldKeys']
    include: 'EIncludeFromCRecursive2'


class FindManyEArgsFromCRecursive2(TypedDict, total=False):
    """Arguments for C"""
    take: int
    skip: int
    order_by: Union['EOrderByInput', List['EOrderByInput']]
    where: 'EWhereInput'
    cursor: 'EWhereUniqueInput'
    distinct: List['EScalarFieldKeys']
    

FindManyCArgs = FindManyCArgsFromC
FindFirstCArgs = FindManyCArgsFromC


    

class CWhereInput(TypedDict, total=False):
    """C arguments for searching"""
    char: Union[_str, 'types.StringFilter']
    v_char: Union[_str, 'types.StringFilter']
    text: Union[_str, 'types.StringFilter']
    bit: Union[_str, 'types.StringFilter']
    v_bit: Union[_str, 'types.StringFilter']
    uuid: Union[_str, 'types.StringFilter']

    # should be noted that AND and NOT should be Union['CWhereInputRecursive1', List['CWhereInputRecursive1']]
    # but this causes mypy to hang :/
    AND: List['CWhereInputRecursive1']
    OR: List['CWhereInputRecursive1']
    NOT: List['CWhereInputRecursive1']


class CWhereInputRecursive1(TypedDict, total=False):
    """C arguments for searching"""
    char: Union[_str, 'types.StringFilter']
    v_char: Union[_str, 'types.StringFilter']
    text: Union[_str, 'types.StringFilter']
    bit: Union[_str, 'types.StringFilter']
    v_bit: Union[_str, 'types.StringFilter']
    uuid: Union[_str, 'types.StringFilter']

    # should be noted that AND and NOT should be Union['CWhereInputRecursive2', List['CWhereInputRecursive2']]
    # but this causes mypy to hang :/
    AND: List['CWhereInputRecursive2']
    OR: List['CWhereInputRecursive2']
    NOT: List['CWhereInputRecursive2']


class CWhereInputRecursive2(TypedDict, total=False):
    """C arguments for searching"""
    char: Union[_str, 'types.StringFilter']
    v_char: Union[_str, 'types.StringFilter']
    text: Union[_str, 'types.StringFilter']
    bit: Union[_str, 'types.StringFilter']
    v_bit: Union[_str, 'types.StringFilter']
    uuid: Union[_str, 'types.StringFilter']



# aggregate C types


    

class CScalarWhereWithAggregatesInput(TypedDict, total=False):
    """C arguments for searching"""
    char: Union[_str, 'types.StringWithAggregatesFilter']
    v_char: Union[_str, 'types.StringWithAggregatesFilter']
    text: Union[_str, 'types.StringWithAggregatesFilter']
    bit: Union[_str, 'types.StringWithAggregatesFilter']
    v_bit: Union[_str, 'types.StringWithAggregatesFilter']
    uuid: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['CScalarWhereWithAggregatesInputRecursive1']
    OR: List['CScalarWhereWithAggregatesInputRecursive1']
    NOT: List['CScalarWhereWithAggregatesInputRecursive1']


class CScalarWhereWithAggregatesInputRecursive1(TypedDict, total=False):
    """C arguments for searching"""
    char: Union[_str, 'types.StringWithAggregatesFilter']
    v_char: Union[_str, 'types.StringWithAggregatesFilter']
    text: Union[_str, 'types.StringWithAggregatesFilter']
    bit: Union[_str, 'types.StringWithAggregatesFilter']
    v_bit: Union[_str, 'types.StringWithAggregatesFilter']
    uuid: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['CScalarWhereWithAggregatesInputRecursive2']
    OR: List['CScalarWhereWithAggregatesInputRecursive2']
    NOT: List['CScalarWhereWithAggregatesInputRecursive2']


class CScalarWhereWithAggregatesInputRecursive2(TypedDict, total=False):
    """C arguments for searching"""
    char: Union[_str, 'types.StringWithAggregatesFilter']
    v_char: Union[_str, 'types.StringWithAggregatesFilter']
    text: Union[_str, 'types.StringWithAggregatesFilter']
    bit: Union[_str, 'types.StringWithAggregatesFilter']
    v_bit: Union[_str, 'types.StringWithAggregatesFilter']
    uuid: Union[_str, 'types.StringWithAggregatesFilter']



class CGroupByOutput(TypedDict, total=False):
    char: _str
    v_char: _str
    text: _str
    bit: _str
    v_bit: _str
    uuid: _str
    _sum: 'CSumAggregateOutput'
    _avg: 'CAvgAggregateOutput'
    _min: 'CMinAggregateOutput'
    _max: 'CMaxAggregateOutput'
    _count: 'CCountAggregateOutput'


class CAvgAggregateOutput(TypedDict, total=False):
    """C output for aggregating averages"""


class CSumAggregateOutput(TypedDict, total=False):
    """C output for aggregating sums"""


class CScalarAggregateOutput(TypedDict, total=False):
    """C output including scalar fields"""
    char: _str
    v_char: _str
    text: _str
    bit: _str
    v_bit: _str
    uuid: _str


CMinAggregateOutput = CScalarAggregateOutput
CMaxAggregateOutput = CScalarAggregateOutput


class CMaxAggregateInput(TypedDict, total=False):
    """C input for aggregating by max"""
    char: bool
    v_char: bool
    text: bool
    bit: bool
    v_bit: bool
    uuid: bool


class CMinAggregateInput(TypedDict, total=False):
    """C input for aggregating by min"""
    char: bool
    v_char: bool
    text: bool
    bit: bool
    v_bit: bool
    uuid: bool


class CNumberAggregateInput(TypedDict, total=False):
    """C input for aggregating numbers"""


CAvgAggregateInput = CNumberAggregateInput
CSumAggregateInput = CNumberAggregateInput


CCountAggregateInput = TypedDict(
    'CCountAggregateInput',
    {
        'char': bool,
        'v_char': bool,
        'text': bool,
        'bit': bool,
        'v_bit': bool,
        'uuid': bool,
        '_all': bool,
    },
    total=False,
)

CCountAggregateOutput = TypedDict(
    'CCountAggregateOutput',
    {
        'char': int,
        'v_char': int,
        'text': int,
        'bit': int,
        'v_bit': int,
        'uuid': int,
        '_all': int,
    },
    total=False,
)


CKeys = Literal[
    'char',
    'v_char',
    'text',
    'bit',
    'v_bit',
    'uuid',
]
CScalarFieldKeys = Literal[
    'char',
    'v_char',
    'text',
    'bit',
    'v_bit',
    'uuid',
]
CScalarFieldKeysT = TypeVar('CScalarFieldKeysT', bound=CScalarFieldKeys)

CRelationalFieldKeys = _NoneType


# we have to import ourselves as forward references may use 'types.XFilter' syntax
from .. import types  # noqa: TID251

'''