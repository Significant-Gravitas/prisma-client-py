'''
# -*- coding: utf-8 -*-
# code generated by Prisma. DO NOT EDIT.
# pyright: reportUnusedImport=false

import decimal
from typing import (
    Any,
    Dict,
    List,
    Union,
    Literal,
    TypeVar,
    TypedDict,
)
from builtins import str as _str, float as _float

# -- template types/_model.py.jinja --
from .. import types
from ..utils import _NoneType
from .atomic import *
from .filters import *
from .list_filters import *

# --- Types for model: B --- #


# B types


class BOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the B create method"""

    id: _str


class BCreateInput(BOptionalCreateInput):
    """Required arguments to the B create method"""

    float: _float
    d_float: _float
    decFloat: decimal.Decimal
    numFloat: decimal.Decimal


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput


class BOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the B create method, without relations"""

    id: _str


class BCreateWithoutRelationsInput(BOptionalCreateWithoutRelationsInput):
    """Required arguments to the B create method, without relations"""

    float: _float
    d_float: _float
    decFloat: decimal.Decimal
    numFloat: decimal.Decimal


class BConnectOrCreateWithoutRelationsInput(TypedDict):
    create: 'BCreateWithoutRelationsInput'
    where: 'BWhereUniqueInput'


class BCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'BCreateWithoutRelationsInput'
    connect: 'BWhereUniqueInput'
    connect_or_create: 'BConnectOrCreateWithoutRelationsInput'


class BCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['BCreateWithoutRelationsInput', List['BCreateWithoutRelationsInput']]
    connect: Union['BWhereUniqueInput', List['BWhereUniqueInput']]
    connect_or_create: Union['BConnectOrCreateWithoutRelationsInput', List['BConnectOrCreateWithoutRelationsInput']]


_BWhereUnique_id_Input = TypedDict(
    '_BWhereUnique_id_Input',
    {
        'id': '_str',
    },
    total=True,
)

_BCompoundmy_constraintKeyInner = TypedDict(
    '_BCompoundmy_constraintKeyInner',
    {
        'float': '_float',
        'd_float': '_float',
    },
    total=True,
)

_BCompoundmy_constraintKey = TypedDict(
    '_BCompoundmy_constraintKey',
    {
        'my_constraint': '_BCompoundmy_constraintKeyInner',
    },
    total=True,
)

BWhereUniqueInput = Union[
    '_BWhereUnique_id_Input',
    '_BCompoundmy_constraintKey',
]


class BUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""

    id: _str
    float: Union[AtomicFloatInput, _float]
    d_float: Union[AtomicFloatInput, _float]
    decFloat: decimal.Decimal
    numFloat: decimal.Decimal


class BUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""

    id: _str
    float: Union[AtomicFloatInput, _float]
    d_float: Union[AtomicFloatInput, _float]
    decFloat: decimal.Decimal
    numFloat: decimal.Decimal


class BUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['BCreateWithoutRelationsInput']
    connect: List['BWhereUniqueInput']
    connect_or_create: List['BConnectOrCreateWithoutRelationsInput']
    set: List['BWhereUniqueInput']
    disconnect: List['BWhereUniqueInput']
    delete: List['BWhereUniqueInput']

    # TODO
    # update: List['BUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['BUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['BScalarWhereInput']
    # upsert: List['BUpserteWithWhereUniqueWithoutRelationsInput']


class BUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'BCreateWithoutRelationsInput'
    connect: 'BWhereUniqueInput'
    connect_or_create: 'BConnectOrCreateWithoutRelationsInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'BUpdateInput'
    # upsert: 'BUpsertWithoutRelationsInput'


class BUpsertInput(TypedDict):
    create: 'BCreateInput'
    update: 'BUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_B_id_OrderByInput = TypedDict(
    '_B_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True,
)

_B_float_OrderByInput = TypedDict(
    '_B_float_OrderByInput',
    {
        'float': 'SortOrder',
    },
    total=True,
)

_B_d_float_OrderByInput = TypedDict(
    '_B_d_float_OrderByInput',
    {
        'd_float': 'SortOrder',
    },
    total=True,
)

_B_decFloat_OrderByInput = TypedDict(
    '_B_decFloat_OrderByInput',
    {
        'decFloat': 'SortOrder',
    },
    total=True,
)

_B_numFloat_OrderByInput = TypedDict(
    '_B_numFloat_OrderByInput',
    {
        'numFloat': 'SortOrder',
    },
    total=True,
)

_B_RelevanceInner = TypedDict(
    '_B_RelevanceInner',
    {
        'fields': 'List[BScalarFieldKeys]',
        'search': 'str',
        'sort': 'SortOrder',
    },
    total=True,
)

_B_RelevanceOrderByInput = TypedDict(
    '_B_RelevanceOrderByInput',
    {
        '_relevance': '_B_RelevanceInner',
    },
    total=True,
)

BOrderByInput = Union[
    '_B_id_OrderByInput',
    '_B_float_OrderByInput',
    '_B_d_float_OrderByInput',
    '_B_decFloat_OrderByInput',
    '_B_numFloat_OrderByInput',
    '_B_RelevanceOrderByInput',
]


# recursive B types
# TODO: cleanup these types


# Dict[str, Any] is a mypy limitation
# see https://github.com/RobertCraigie/prisma-client-py/issues/45
# switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/stable/reference/limitations/

BRelationFilter = TypedDict(
    'BRelationFilter',
    {
        'is': 'Dict[str, Any]',
        'is_not': 'Dict[str, Any]',
    },
    total=False,
)


class BListRelationFilter(TypedDict, total=False):
    some: 'Dict[str, Any]'
    none: 'Dict[str, Any]'
    every: 'Dict[str, Any]'


class BInclude(TypedDict, total=False):
    """B relational arguments"""


class PostIncludeFromB(TypedDict, total=False):
    """Relational arguments for B"""

    author: Union[bool, 'UserArgsFromBRecursive1']


class PostIncludeFromBRecursive1(TypedDict, total=False):
    """Relational arguments for B"""

    author: Union[bool, 'UserArgsFromBRecursive2']


class PostIncludeFromBRecursive2(TypedDict, total=False):
    """Relational arguments for B"""


class PostArgsFromB(TypedDict, total=False):
    """Arguments for B"""

    include: 'PostIncludeFromBRecursive1'


class PostArgsFromBRecursive1(TypedDict, total=False):
    """Arguments for B"""

    include: 'PostIncludeFromBRecursive2'


class PostArgsFromBRecursive2(TypedDict, total=False):
    """Arguments for B"""


class FindManyPostArgsFromB(TypedDict, total=False):
    """Arguments for B"""

    take: int
    skip: int
    order_by: Union['PostOrderByInput', List['PostOrderByInput']]
    where: 'PostWhereInput'
    cursor: 'PostWhereUniqueInput'
    distinct: List['PostScalarFieldKeys']
    include: 'PostIncludeFromBRecursive1'


class FindManyPostArgsFromBRecursive1(TypedDict, total=False):
    """Arguments for B"""

    take: int
    skip: int
    order_by: Union['PostOrderByInput', List['PostOrderByInput']]
    where: 'PostWhereInput'
    cursor: 'PostWhereUniqueInput'
    distinct: List['PostScalarFieldKeys']
    include: 'PostIncludeFromBRecursive2'


class FindManyPostArgsFromBRecursive2(TypedDict, total=False):
    """Arguments for B"""

    take: int
    skip: int
    order_by: Union['PostOrderByInput', List['PostOrderByInput']]
    where: 'PostWhereInput'
    cursor: 'PostWhereUniqueInput'
    distinct: List['PostScalarFieldKeys']


class UserIncludeFromB(TypedDict, total=False):
    """Relational arguments for B"""

    posts: Union[bool, 'FindManyPostArgsFromBRecursive1']


class UserIncludeFromBRecursive1(TypedDict, total=False):
    """Relational arguments for B"""

    posts: Union[bool, 'FindManyPostArgsFromBRecursive2']


class UserIncludeFromBRecursive2(TypedDict, total=False):
    """Relational arguments for B"""


class UserArgsFromB(TypedDict, total=False):
    """Arguments for B"""

    include: 'UserIncludeFromBRecursive1'


class UserArgsFromBRecursive1(TypedDict, total=False):
    """Arguments for B"""

    include: 'UserIncludeFromBRecursive2'


class UserArgsFromBRecursive2(TypedDict, total=False):
    """Arguments for B"""


class FindManyUserArgsFromB(TypedDict, total=False):
    """Arguments for B"""

    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromBRecursive1'


class FindManyUserArgsFromBRecursive1(TypedDict, total=False):
    """Arguments for B"""

    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromBRecursive2'


class FindManyUserArgsFromBRecursive2(TypedDict, total=False):
    """Arguments for B"""

    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']


class MIncludeFromB(TypedDict, total=False):
    """Relational arguments for B"""

    n: Union[bool, 'FindManyNArgsFromBRecursive1']


class MIncludeFromBRecursive1(TypedDict, total=False):
    """Relational arguments for B"""

    n: Union[bool, 'FindManyNArgsFromBRecursive2']


class MIncludeFromBRecursive2(TypedDict, total=False):
    """Relational arguments for B"""


class MArgsFromB(TypedDict, total=False):
    """Arguments for B"""

    include: 'MIncludeFromBRecursive1'


class MArgsFromBRecursive1(TypedDict, total=False):
    """Arguments for B"""

    include: 'MIncludeFromBRecursive2'


class MArgsFromBRecursive2(TypedDict, total=False):
    """Arguments for B"""


class FindManyMArgsFromB(TypedDict, total=False):
    """Arguments for B"""

    take: int
    skip: int
    order_by: Union['MOrderByInput', List['MOrderByInput']]
    where: 'MWhereInput'
    cursor: 'MWhereUniqueInput'
    distinct: List['MScalarFieldKeys']
    include: 'MIncludeFromBRecursive1'


class FindManyMArgsFromBRecursive1(TypedDict, total=False):
    """Arguments for B"""

    take: int
    skip: int
    order_by: Union['MOrderByInput', List['MOrderByInput']]
    where: 'MWhereInput'
    cursor: 'MWhereUniqueInput'
    distinct: List['MScalarFieldKeys']
    include: 'MIncludeFromBRecursive2'


class FindManyMArgsFromBRecursive2(TypedDict, total=False):
    """Arguments for B"""

    take: int
    skip: int
    order_by: Union['MOrderByInput', List['MOrderByInput']]
    where: 'MWhereInput'
    cursor: 'MWhereUniqueInput'
    distinct: List['MScalarFieldKeys']


class NIncludeFromB(TypedDict, total=False):
    """Relational arguments for B"""

    m: Union[bool, 'FindManyMArgsFromBRecursive1']


class NIncludeFromBRecursive1(TypedDict, total=False):
    """Relational arguments for B"""

    m: Union[bool, 'FindManyMArgsFromBRecursive2']


class NIncludeFromBRecursive2(TypedDict, total=False):
    """Relational arguments for B"""


class NArgsFromB(TypedDict, total=False):
    """Arguments for B"""

    include: 'NIncludeFromBRecursive1'


class NArgsFromBRecursive1(TypedDict, total=False):
    """Arguments for B"""

    include: 'NIncludeFromBRecursive2'


class NArgsFromBRecursive2(TypedDict, total=False):
    """Arguments for B"""


class FindManyNArgsFromB(TypedDict, total=False):
    """Arguments for B"""

    take: int
    skip: int
    order_by: Union['NOrderByInput', List['NOrderByInput']]
    where: 'NWhereInput'
    cursor: 'NWhereUniqueInput'
    distinct: List['NScalarFieldKeys']
    include: 'NIncludeFromBRecursive1'


class FindManyNArgsFromBRecursive1(TypedDict, total=False):
    """Arguments for B"""

    take: int
    skip: int
    order_by: Union['NOrderByInput', List['NOrderByInput']]
    where: 'NWhereInput'
    cursor: 'NWhereUniqueInput'
    distinct: List['NScalarFieldKeys']
    include: 'NIncludeFromBRecursive2'


class FindManyNArgsFromBRecursive2(TypedDict, total=False):
    """Arguments for B"""

    take: int
    skip: int
    order_by: Union['NOrderByInput', List['NOrderByInput']]
    where: 'NWhereInput'
    cursor: 'NWhereUniqueInput'
    distinct: List['NScalarFieldKeys']


class OneOptionalIncludeFromB(TypedDict, total=False):
    """Relational arguments for B"""

    many: Union[bool, 'FindManyManyRequiredArgsFromBRecursive1']


class OneOptionalIncludeFromBRecursive1(TypedDict, total=False):
    """Relational arguments for B"""

    many: Union[bool, 'FindManyManyRequiredArgsFromBRecursive2']


class OneOptionalIncludeFromBRecursive2(TypedDict, total=False):
    """Relational arguments for B"""


class OneOptionalArgsFromB(TypedDict, total=False):
    """Arguments for B"""

    include: 'OneOptionalIncludeFromBRecursive1'


class OneOptionalArgsFromBRecursive1(TypedDict, total=False):
    """Arguments for B"""

    include: 'OneOptionalIncludeFromBRecursive2'


class OneOptionalArgsFromBRecursive2(TypedDict, total=False):
    """Arguments for B"""


class FindManyOneOptionalArgsFromB(TypedDict, total=False):
    """Arguments for B"""

    take: int
    skip: int
    order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
    where: 'OneOptionalWhereInput'
    cursor: 'OneOptionalWhereUniqueInput'
    distinct: List['OneOptionalScalarFieldKeys']
    include: 'OneOptionalIncludeFromBRecursive1'


class FindManyOneOptionalArgsFromBRecursive1(TypedDict, total=False):
    """Arguments for B"""

    take: int
    skip: int
    order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
    where: 'OneOptionalWhereInput'
    cursor: 'OneOptionalWhereUniqueInput'
    distinct: List['OneOptionalScalarFieldKeys']
    include: 'OneOptionalIncludeFromBRecursive2'


class FindManyOneOptionalArgsFromBRecursive2(TypedDict, total=False):
    """Arguments for B"""

    take: int
    skip: int
    order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
    where: 'OneOptionalWhereInput'
    cursor: 'OneOptionalWhereUniqueInput'
    distinct: List['OneOptionalScalarFieldKeys']


class ManyRequiredIncludeFromB(TypedDict, total=False):
    """Relational arguments for B"""

    one: Union[bool, 'OneOptionalArgsFromBRecursive1']


class ManyRequiredIncludeFromBRecursive1(TypedDict, total=False):
    """Relational arguments for B"""

    one: Union[bool, 'OneOptionalArgsFromBRecursive2']


class ManyRequiredIncludeFromBRecursive2(TypedDict, total=False):
    """Relational arguments for B"""


class ManyRequiredArgsFromB(TypedDict, total=False):
    """Arguments for B"""

    include: 'ManyRequiredIncludeFromBRecursive1'


class ManyRequiredArgsFromBRecursive1(TypedDict, total=False):
    """Arguments for B"""

    include: 'ManyRequiredIncludeFromBRecursive2'


class ManyRequiredArgsFromBRecursive2(TypedDict, total=False):
    """Arguments for B"""


class FindManyManyRequiredArgsFromB(TypedDict, total=False):
    """Arguments for B"""

    take: int
    skip: int
    order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
    where: 'ManyRequiredWhereInput'
    cursor: 'ManyRequiredWhereUniqueInput'
    distinct: List['ManyRequiredScalarFieldKeys']
    include: 'ManyRequiredIncludeFromBRecursive1'


class FindManyManyRequiredArgsFromBRecursive1(TypedDict, total=False):
    """Arguments for B"""

    take: int
    skip: int
    order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
    where: 'ManyRequiredWhereInput'
    cursor: 'ManyRequiredWhereUniqueInput'
    distinct: List['ManyRequiredScalarFieldKeys']
    include: 'ManyRequiredIncludeFromBRecursive2'


class FindManyManyRequiredArgsFromBRecursive2(TypedDict, total=False):
    """Arguments for B"""

    take: int
    skip: int
    order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
    where: 'ManyRequiredWhereInput'
    cursor: 'ManyRequiredWhereUniqueInput'
    distinct: List['ManyRequiredScalarFieldKeys']


class ListsIncludeFromB(TypedDict, total=False):
    """Relational arguments for B"""


class ListsIncludeFromBRecursive1(TypedDict, total=False):
    """Relational arguments for B"""


class ListsIncludeFromBRecursive2(TypedDict, total=False):
    """Relational arguments for B"""


class ListsArgsFromB(TypedDict, total=False):
    """Arguments for B"""

    include: 'ListsIncludeFromBRecursive1'


class ListsArgsFromBRecursive1(TypedDict, total=False):
    """Arguments for B"""

    include: 'ListsIncludeFromBRecursive2'


class ListsArgsFromBRecursive2(TypedDict, total=False):
    """Arguments for B"""


class FindManyListsArgsFromB(TypedDict, total=False):
    """Arguments for B"""

    take: int
    skip: int
    order_by: Union['ListsOrderByInput', List['ListsOrderByInput']]
    where: 'ListsWhereInput'
    cursor: 'ListsWhereUniqueInput'
    distinct: List['ListsScalarFieldKeys']
    include: 'ListsIncludeFromBRecursive1'


class FindManyListsArgsFromBRecursive1(TypedDict, total=False):
    """Arguments for B"""

    take: int
    skip: int
    order_by: Union['ListsOrderByInput', List['ListsOrderByInput']]
    where: 'ListsWhereInput'
    cursor: 'ListsWhereUniqueInput'
    distinct: List['ListsScalarFieldKeys']
    include: 'ListsIncludeFromBRecursive2'


class FindManyListsArgsFromBRecursive2(TypedDict, total=False):
    """Arguments for B"""

    take: int
    skip: int
    order_by: Union['ListsOrderByInput', List['ListsOrderByInput']]
    where: 'ListsWhereInput'
    cursor: 'ListsWhereUniqueInput'
    distinct: List['ListsScalarFieldKeys']


class AIncludeFromB(TypedDict, total=False):
    """Relational arguments for B"""


class AIncludeFromBRecursive1(TypedDict, total=False):
    """Relational arguments for B"""


class AIncludeFromBRecursive2(TypedDict, total=False):
    """Relational arguments for B"""


class AArgsFromB(TypedDict, total=False):
    """Arguments for B"""

    include: 'AIncludeFromBRecursive1'


class AArgsFromBRecursive1(TypedDict, total=False):
    """Arguments for B"""

    include: 'AIncludeFromBRecursive2'


class AArgsFromBRecursive2(TypedDict, total=False):
    """Arguments for B"""


class FindManyAArgsFromB(TypedDict, total=False):
    """Arguments for B"""

    take: int
    skip: int
    order_by: Union['AOrderByInput', List['AOrderByInput']]
    where: 'AWhereInput'
    cursor: 'AWhereUniqueInput'
    distinct: List['AScalarFieldKeys']
    include: 'AIncludeFromBRecursive1'


class FindManyAArgsFromBRecursive1(TypedDict, total=False):
    """Arguments for B"""

    take: int
    skip: int
    order_by: Union['AOrderByInput', List['AOrderByInput']]
    where: 'AWhereInput'
    cursor: 'AWhereUniqueInput'
    distinct: List['AScalarFieldKeys']
    include: 'AIncludeFromBRecursive2'


class FindManyAArgsFromBRecursive2(TypedDict, total=False):
    """Arguments for B"""

    take: int
    skip: int
    order_by: Union['AOrderByInput', List['AOrderByInput']]
    where: 'AWhereInput'
    cursor: 'AWhereUniqueInput'
    distinct: List['AScalarFieldKeys']


class BIncludeFromB(TypedDict, total=False):
    """Relational arguments for B"""


class BIncludeFromBRecursive1(TypedDict, total=False):
    """Relational arguments for B"""


class BIncludeFromBRecursive2(TypedDict, total=False):
    """Relational arguments for B"""


class BArgsFromB(TypedDict, total=False):
    """Arguments for B"""

    include: 'BIncludeFromBRecursive1'


class BArgsFromBRecursive1(TypedDict, total=False):
    """Arguments for B"""

    include: 'BIncludeFromBRecursive2'


class BArgsFromBRecursive2(TypedDict, total=False):
    """Arguments for B"""


class FindManyBArgsFromB(TypedDict, total=False):
    """Arguments for B"""

    take: int
    skip: int
    order_by: Union['BOrderByInput', List['BOrderByInput']]
    where: 'BWhereInput'
    cursor: 'BWhereUniqueInput'
    distinct: List['BScalarFieldKeys']
    include: 'BIncludeFromBRecursive1'


class FindManyBArgsFromBRecursive1(TypedDict, total=False):
    """Arguments for B"""

    take: int
    skip: int
    order_by: Union['BOrderByInput', List['BOrderByInput']]
    where: 'BWhereInput'
    cursor: 'BWhereUniqueInput'
    distinct: List['BScalarFieldKeys']
    include: 'BIncludeFromBRecursive2'


class FindManyBArgsFromBRecursive2(TypedDict, total=False):
    """Arguments for B"""

    take: int
    skip: int
    order_by: Union['BOrderByInput', List['BOrderByInput']]
    where: 'BWhereInput'
    cursor: 'BWhereUniqueInput'
    distinct: List['BScalarFieldKeys']


class CIncludeFromB(TypedDict, total=False):
    """Relational arguments for B"""


class CIncludeFromBRecursive1(TypedDict, total=False):
    """Relational arguments for B"""


class CIncludeFromBRecursive2(TypedDict, total=False):
    """Relational arguments for B"""


class CArgsFromB(TypedDict, total=False):
    """Arguments for B"""

    include: 'CIncludeFromBRecursive1'


class CArgsFromBRecursive1(TypedDict, total=False):
    """Arguments for B"""

    include: 'CIncludeFromBRecursive2'


class CArgsFromBRecursive2(TypedDict, total=False):
    """Arguments for B"""


class FindManyCArgsFromB(TypedDict, total=False):
    """Arguments for B"""

    take: int
    skip: int
    order_by: Union['COrderByInput', List['COrderByInput']]
    where: 'CWhereInput'
    cursor: 'CWhereUniqueInput'
    distinct: List['CScalarFieldKeys']
    include: 'CIncludeFromBRecursive1'


class FindManyCArgsFromBRecursive1(TypedDict, total=False):
    """Arguments for B"""

    take: int
    skip: int
    order_by: Union['COrderByInput', List['COrderByInput']]
    where: 'CWhereInput'
    cursor: 'CWhereUniqueInput'
    distinct: List['CScalarFieldKeys']
    include: 'CIncludeFromBRecursive2'


class FindManyCArgsFromBRecursive2(TypedDict, total=False):
    """Arguments for B"""

    take: int
    skip: int
    order_by: Union['COrderByInput', List['COrderByInput']]
    where: 'CWhereInput'
    cursor: 'CWhereUniqueInput'
    distinct: List['CScalarFieldKeys']


class DIncludeFromB(TypedDict, total=False):
    """Relational arguments for B"""


class DIncludeFromBRecursive1(TypedDict, total=False):
    """Relational arguments for B"""


class DIncludeFromBRecursive2(TypedDict, total=False):
    """Relational arguments for B"""


class DArgsFromB(TypedDict, total=False):
    """Arguments for B"""

    include: 'DIncludeFromBRecursive1'


class DArgsFromBRecursive1(TypedDict, total=False):
    """Arguments for B"""

    include: 'DIncludeFromBRecursive2'


class DArgsFromBRecursive2(TypedDict, total=False):
    """Arguments for B"""


class FindManyDArgsFromB(TypedDict, total=False):
    """Arguments for B"""

    take: int
    skip: int
    order_by: Union['DOrderByInput', List['DOrderByInput']]
    where: 'DWhereInput'
    cursor: 'DWhereUniqueInput'
    distinct: List['DScalarFieldKeys']
    include: 'DIncludeFromBRecursive1'


class FindManyDArgsFromBRecursive1(TypedDict, total=False):
    """Arguments for B"""

    take: int
    skip: int
    order_by: Union['DOrderByInput', List['DOrderByInput']]
    where: 'DWhereInput'
    cursor: 'DWhereUniqueInput'
    distinct: List['DScalarFieldKeys']
    include: 'DIncludeFromBRecursive2'


class FindManyDArgsFromBRecursive2(TypedDict, total=False):
    """Arguments for B"""

    take: int
    skip: int
    order_by: Union['DOrderByInput', List['DOrderByInput']]
    where: 'DWhereInput'
    cursor: 'DWhereUniqueInput'
    distinct: List['DScalarFieldKeys']


class EIncludeFromB(TypedDict, total=False):
    """Relational arguments for B"""


class EIncludeFromBRecursive1(TypedDict, total=False):
    """Relational arguments for B"""


class EIncludeFromBRecursive2(TypedDict, total=False):
    """Relational arguments for B"""


class EArgsFromB(TypedDict, total=False):
    """Arguments for B"""

    include: 'EIncludeFromBRecursive1'


class EArgsFromBRecursive1(TypedDict, total=False):
    """Arguments for B"""

    include: 'EIncludeFromBRecursive2'


class EArgsFromBRecursive2(TypedDict, total=False):
    """Arguments for B"""


class FindManyEArgsFromB(TypedDict, total=False):
    """Arguments for B"""

    take: int
    skip: int
    order_by: Union['EOrderByInput', List['EOrderByInput']]
    where: 'EWhereInput'
    cursor: 'EWhereUniqueInput'
    distinct: List['EScalarFieldKeys']
    include: 'EIncludeFromBRecursive1'


class FindManyEArgsFromBRecursive1(TypedDict, total=False):
    """Arguments for B"""

    take: int
    skip: int
    order_by: Union['EOrderByInput', List['EOrderByInput']]
    where: 'EWhereInput'
    cursor: 'EWhereUniqueInput'
    distinct: List['EScalarFieldKeys']
    include: 'EIncludeFromBRecursive2'


class FindManyEArgsFromBRecursive2(TypedDict, total=False):
    """Arguments for B"""

    take: int
    skip: int
    order_by: Union['EOrderByInput', List['EOrderByInput']]
    where: 'EWhereInput'
    cursor: 'EWhereUniqueInput'
    distinct: List['EScalarFieldKeys']


FindManyBArgs = FindManyBArgsFromB
FindFirstBArgs = FindManyBArgsFromB


class BWhereInput(TypedDict, total=False):
    """B arguments for searching"""

    id: Union[_str, 'types.StringFilter']
    float: Union[_float, 'types.FloatFilter']
    d_float: Union[_float, 'types.FloatFilter']
    decFloat: Union[decimal.Decimal, 'types.DecimalFilter']
    numFloat: Union[decimal.Decimal, 'types.DecimalFilter']

    # should be noted that AND and NOT should be Union['BWhereInputRecursive1', List['BWhereInputRecursive1']]
    # but this causes mypy to hang :/
    AND: List['BWhereInputRecursive1']
    OR: List['BWhereInputRecursive1']
    NOT: List['BWhereInputRecursive1']


class BWhereInputRecursive1(TypedDict, total=False):
    """B arguments for searching"""

    id: Union[_str, 'types.StringFilter']
    float: Union[_float, 'types.FloatFilter']
    d_float: Union[_float, 'types.FloatFilter']
    decFloat: Union[decimal.Decimal, 'types.DecimalFilter']
    numFloat: Union[decimal.Decimal, 'types.DecimalFilter']

    # should be noted that AND and NOT should be Union['BWhereInputRecursive2', List['BWhereInputRecursive2']]
    # but this causes mypy to hang :/
    AND: List['BWhereInputRecursive2']
    OR: List['BWhereInputRecursive2']
    NOT: List['BWhereInputRecursive2']


class BWhereInputRecursive2(TypedDict, total=False):
    """B arguments for searching"""

    id: Union[_str, 'types.StringFilter']
    float: Union[_float, 'types.FloatFilter']
    d_float: Union[_float, 'types.FloatFilter']
    decFloat: Union[decimal.Decimal, 'types.DecimalFilter']
    numFloat: Union[decimal.Decimal, 'types.DecimalFilter']


# aggregate B types


class BScalarWhereWithAggregatesInput(TypedDict, total=False):
    """B arguments for searching"""

    id: Union[_str, 'types.StringWithAggregatesFilter']
    float: Union[_float, 'types.FloatWithAggregatesFilter']
    d_float: Union[_float, 'types.FloatWithAggregatesFilter']
    decFloat: Union[decimal.Decimal, 'types.DecimalWithAggregatesFilter']
    numFloat: Union[decimal.Decimal, 'types.DecimalWithAggregatesFilter']

    AND: List['BScalarWhereWithAggregatesInputRecursive1']
    OR: List['BScalarWhereWithAggregatesInputRecursive1']
    NOT: List['BScalarWhereWithAggregatesInputRecursive1']


class BScalarWhereWithAggregatesInputRecursive1(TypedDict, total=False):
    """B arguments for searching"""

    id: Union[_str, 'types.StringWithAggregatesFilter']
    float: Union[_float, 'types.FloatWithAggregatesFilter']
    d_float: Union[_float, 'types.FloatWithAggregatesFilter']
    decFloat: Union[decimal.Decimal, 'types.DecimalWithAggregatesFilter']
    numFloat: Union[decimal.Decimal, 'types.DecimalWithAggregatesFilter']

    AND: List['BScalarWhereWithAggregatesInputRecursive2']
    OR: List['BScalarWhereWithAggregatesInputRecursive2']
    NOT: List['BScalarWhereWithAggregatesInputRecursive2']


class BScalarWhereWithAggregatesInputRecursive2(TypedDict, total=False):
    """B arguments for searching"""

    id: Union[_str, 'types.StringWithAggregatesFilter']
    float: Union[_float, 'types.FloatWithAggregatesFilter']
    d_float: Union[_float, 'types.FloatWithAggregatesFilter']
    decFloat: Union[decimal.Decimal, 'types.DecimalWithAggregatesFilter']
    numFloat: Union[decimal.Decimal, 'types.DecimalWithAggregatesFilter']


class BGroupByOutput(TypedDict, total=False):
    id: _str
    float: _float
    d_float: _float
    decFloat: decimal.Decimal
    numFloat: decimal.Decimal
    _sum: 'BSumAggregateOutput'
    _avg: 'BAvgAggregateOutput'
    _min: 'BMinAggregateOutput'
    _max: 'BMaxAggregateOutput'
    _count: 'BCountAggregateOutput'


class BAvgAggregateOutput(TypedDict, total=False):
    """B output for aggregating averages"""

    float: float
    d_float: float


class BSumAggregateOutput(TypedDict, total=False):
    """B output for aggregating sums"""

    float: _float
    d_float: _float


class BScalarAggregateOutput(TypedDict, total=False):
    """B output including scalar fields"""

    id: _str
    float: _float
    d_float: _float
    decFloat: decimal.Decimal
    numFloat: decimal.Decimal


BMinAggregateOutput = BScalarAggregateOutput
BMaxAggregateOutput = BScalarAggregateOutput


class BMaxAggregateInput(TypedDict, total=False):
    """B input for aggregating by max"""

    id: bool
    float: bool
    d_float: bool
    decFloat: bool
    numFloat: bool


class BMinAggregateInput(TypedDict, total=False):
    """B input for aggregating by min"""

    id: bool
    float: bool
    d_float: bool
    decFloat: bool
    numFloat: bool


class BNumberAggregateInput(TypedDict, total=False):
    """B input for aggregating numbers"""

    float: bool
    d_float: bool


BAvgAggregateInput = BNumberAggregateInput
BSumAggregateInput = BNumberAggregateInput


BCountAggregateInput = TypedDict(
    'BCountAggregateInput',
    {
        'id': bool,
        'float': bool,
        'd_float': bool,
        'decFloat': bool,
        'numFloat': bool,
        '_all': bool,
    },
    total=False,
)

BCountAggregateOutput = TypedDict(
    'BCountAggregateOutput',
    {
        'id': int,
        'float': int,
        'd_float': int,
        'decFloat': int,
        'numFloat': int,
        '_all': int,
    },
    total=False,
)


BKeys = Literal[
    'id',
    'float',
    'd_float',
    'decFloat',
    'numFloat',
]
BScalarFieldKeys = Literal[
    'id',
    'float',
    'd_float',
    'decFloat',
    'numFloat',
]
BScalarFieldKeysT = TypeVar('BScalarFieldKeysT', bound=BScalarFieldKeys)

BRelationalFieldKeys = _NoneType

# Cross-import related model types for resolution of forward references
from .a import (
    AWhereInput,
    AOrderByInput,
    AScalarFieldKeys,
    AWhereUniqueInput,
)
from .c import (
    CWhereInput,
    COrderByInput,
    CScalarFieldKeys,
    CWhereUniqueInput,
)
from .d import (
    DWhereInput,
    DOrderByInput,
    DScalarFieldKeys,
    DWhereUniqueInput,
)
from .e import (
    EWhereInput,
    EOrderByInput,
    EScalarFieldKeys,
    EWhereUniqueInput,
)
from .m import (
    MWhereInput,
    MOrderByInput,
    MScalarFieldKeys,
    MWhereUniqueInput,
)
from .n import (
    NWhereInput,
    NOrderByInput,
    NScalarFieldKeys,
    NWhereUniqueInput,
)
from .post import (
    PostWhereInput,
    PostOrderByInput,
    PostScalarFieldKeys,
    PostWhereUniqueInput,
)
from .user import (
    UserWhereInput,
    UserOrderByInput,
    UserScalarFieldKeys,
    UserWhereUniqueInput,
)
from .lists import (
    ListsWhereInput,
    ListsOrderByInput,
    ListsScalarFieldKeys,
    ListsWhereUniqueInput,
)
from .oneoptional import (
    OneOptionalWhereInput,
    OneOptionalOrderByInput,
    OneOptionalScalarFieldKeys,
    OneOptionalWhereUniqueInput,
)
from .manyrequired import (
    ManyRequiredWhereInput,
    ManyRequiredOrderByInput,
    ManyRequiredScalarFieldKeys,
    ManyRequiredWhereUniqueInput,
)

'''