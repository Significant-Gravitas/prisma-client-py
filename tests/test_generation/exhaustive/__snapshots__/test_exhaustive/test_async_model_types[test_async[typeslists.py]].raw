'''
# -*- coding: utf-8 -*-
# code generated by Prisma. DO NOT EDIT.
# pyright: reportUnusedImport=false
# fmt: off

# global imports for type checking
import decimal
import datetime
from typing import (
    TYPE_CHECKING,
    Any,
    Dict,
    List,
    Union,
    Literal,
    TypeVar,
    TypedDict,
)
from builtins import int as _int, str as _str, bool as _bool, float as _float

LiteralString = str
# -- template types/_model.py.jinja --
# Types for model: Lists

from ..utils import _NoneType
from .atomic import *  # noqa: TID251
from .filters import *  # noqa: TID251
from .list_filters import *  # noqa: TID251

# Cross-import related model types for type checker resolution
if TYPE_CHECKING:
    from .a import (  # noqa: TID251
        AWhereInput,
        AOrderByInput,
        AScalarFieldKeys,
        AWhereUniqueInput,
    )
    from .b import (  # noqa: TID251
        BWhereInput,
        BOrderByInput,
        BScalarFieldKeys,
        BWhereUniqueInput,
    )
    from .c import (  # noqa: TID251
        CWhereInput,
        COrderByInput,
        CScalarFieldKeys,
        CWhereUniqueInput,
    )
    from .d import (  # noqa: TID251
        DWhereInput,
        DOrderByInput,
        DScalarFieldKeys,
        DWhereUniqueInput,
    )
    from .e import (  # noqa: TID251
        EWhereInput,
        EOrderByInput,
        EScalarFieldKeys,
        EWhereUniqueInput,
    )
    from .m import (  # noqa: TID251
        MWhereInput,
        MOrderByInput,
        MScalarFieldKeys,
        MWhereUniqueInput,
    )
    from .n import (  # noqa: TID251
        NWhereInput,
        NOrderByInput,
        NScalarFieldKeys,
        NWhereUniqueInput,
    )
    from .post import (  # noqa: TID251
        PostWhereInput,
        PostOrderByInput,
        PostScalarFieldKeys,
        PostWhereUniqueInput,
    )
    from .user import (  # noqa: TID251
        UserWhereInput,
        UserOrderByInput,
        UserScalarFieldKeys,
        UserWhereUniqueInput,
    )
    from .oneoptional import (  # noqa: TID251
        OneOptionalWhereInput,
        OneOptionalOrderByInput,
        OneOptionalScalarFieldKeys,
        OneOptionalWhereUniqueInput,
    )
    from .manyrequired import (  # noqa: TID251
        ManyRequiredWhereInput,
        ManyRequiredOrderByInput,
        ManyRequiredScalarFieldKeys,
        ManyRequiredWhereUniqueInput,
    )





# Lists types

class ListsOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the Lists create method"""
    id: _str
    strings: List[_str]
    bytes: List['fields.Base64']
    dates: List[datetime.datetime]
    bools: List[_bool]
    ints: List[_int]
    floats: List[_float]
    bigints: List[_int]
    json_objects: List['fields.Json']
    decimals: List[decimal.Decimal]


class ListsCreateInput(ListsOptionalCreateInput):
    """Required arguments to the Lists create method"""


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class ListsOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the Lists create method, without relations"""
    id: _str
    strings: List[_str]
    bytes: List['fields.Base64']
    dates: List[datetime.datetime]
    bools: List[_bool]
    ints: List[_int]
    floats: List[_float]
    bigints: List[_int]
    json_objects: List['fields.Json']
    decimals: List[decimal.Decimal]


class ListsCreateWithoutRelationsInput(ListsOptionalCreateWithoutRelationsInput):
    """Required arguments to the Lists create method, without relations"""

class ListsConnectOrCreateWithoutRelationsInput(TypedDict):
    create: 'ListsCreateWithoutRelationsInput'
    where: 'ListsWhereUniqueInput'

class ListsCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'ListsCreateWithoutRelationsInput'
    connect: 'ListsWhereUniqueInput'
    connect_or_create: 'ListsConnectOrCreateWithoutRelationsInput'


class ListsCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['ListsCreateWithoutRelationsInput', List['ListsCreateWithoutRelationsInput']]
    connect: Union['ListsWhereUniqueInput', List['ListsWhereUniqueInput']]
    connect_or_create: Union['ListsConnectOrCreateWithoutRelationsInput', List['ListsConnectOrCreateWithoutRelationsInput']]

_ListsWhereUnique_id_Input = TypedDict(
    '_ListsWhereUnique_id_Input',
    {
        'id': '_str',
    },
    total=True
)

ListsWhereUniqueInput = _ListsWhereUnique_id_Input


class ListsUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: _str
    strings: 'types.StringListUpdate'
    bytes: 'types.BytesListUpdate'
    dates: 'types.DateTimeListUpdate'
    bools: 'types.BooleanListUpdate'
    ints: 'types.IntListUpdate'
    floats: 'types.FloatListUpdate'
    bigints: 'types.BigIntListUpdate'
    json_objects: 'types.JsonListUpdate'
    decimals: 'types.DecimalListUpdate'


class ListsUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: _str
    strings: 'types.StringListUpdate'
    bytes: 'types.BytesListUpdate'
    dates: 'types.DateTimeListUpdate'
    bools: 'types.BooleanListUpdate'
    ints: 'types.IntListUpdate'
    floats: 'types.FloatListUpdate'
    bigints: 'types.BigIntListUpdate'
    json_objects: 'types.JsonListUpdate'
    decimals: 'types.DecimalListUpdate'


class ListsUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['ListsCreateWithoutRelationsInput']
    connect: List['ListsWhereUniqueInput']
    connect_or_create: List['ListsConnectOrCreateWithoutRelationsInput']
    set: List['ListsWhereUniqueInput']
    disconnect: List['ListsWhereUniqueInput']
    delete: List['ListsWhereUniqueInput']

    # TODO
    # update: List['ListsUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['ListsUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['ListsScalarWhereInput']
    # upsert: List['ListsUpserteWithWhereUniqueWithoutRelationsInput']


class ListsUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'ListsCreateWithoutRelationsInput'
    connect: 'ListsWhereUniqueInput'
    connect_or_create: 'ListsConnectOrCreateWithoutRelationsInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'ListsUpdateInput'
    # upsert: 'ListsUpsertWithoutRelationsInput'


class ListsUpsertInput(TypedDict):
    create: 'ListsCreateInput'
    update: 'ListsUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_Lists_id_OrderByInput = TypedDict(
    '_Lists_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_Lists_strings_OrderByInput = TypedDict(
    '_Lists_strings_OrderByInput',
    {
        'strings': 'SortOrder',
    },
    total=True
)

_Lists_bytes_OrderByInput = TypedDict(
    '_Lists_bytes_OrderByInput',
    {
        'bytes': 'SortOrder',
    },
    total=True
)

_Lists_dates_OrderByInput = TypedDict(
    '_Lists_dates_OrderByInput',
    {
        'dates': 'SortOrder',
    },
    total=True
)

_Lists_bools_OrderByInput = TypedDict(
    '_Lists_bools_OrderByInput',
    {
        'bools': 'SortOrder',
    },
    total=True
)

_Lists_ints_OrderByInput = TypedDict(
    '_Lists_ints_OrderByInput',
    {
        'ints': 'SortOrder',
    },
    total=True
)

_Lists_floats_OrderByInput = TypedDict(
    '_Lists_floats_OrderByInput',
    {
        'floats': 'SortOrder',
    },
    total=True
)

_Lists_bigints_OrderByInput = TypedDict(
    '_Lists_bigints_OrderByInput',
    {
        'bigints': 'SortOrder',
    },
    total=True
)

_Lists_json_objects_OrderByInput = TypedDict(
    '_Lists_json_objects_OrderByInput',
    {
        'json_objects': 'SortOrder',
    },
    total=True
)

_Lists_decimals_OrderByInput = TypedDict(
    '_Lists_decimals_OrderByInput',
    {
        'decimals': 'SortOrder',
    },
    total=True
)

_Lists_RelevanceInner = TypedDict(
    '_Lists_RelevanceInner',
    {
        'fields': 'List[ListsScalarFieldKeys]',
        'search': 'str',
        'sort': 'SortOrder',
    },
    total=True
)

_Lists_RelevanceOrderByInput = TypedDict(
    '_Lists_RelevanceOrderByInput',
    {
        '_relevance': '_Lists_RelevanceInner',
    },
    total=True
)

ListsOrderByInput = Union[
    '_Lists_id_OrderByInput',
    '_Lists_strings_OrderByInput',
    '_Lists_bytes_OrderByInput',
    '_Lists_dates_OrderByInput',
    '_Lists_bools_OrderByInput',
    '_Lists_ints_OrderByInput',
    '_Lists_floats_OrderByInput',
    '_Lists_bigints_OrderByInput',
    '_Lists_json_objects_OrderByInput',
    '_Lists_decimals_OrderByInput',
    '_Lists_RelevanceOrderByInput',
]



# recursive Lists types
# TODO: cleanup these types


# Dict[str, Any] is a mypy limitation
# see https://github.com/RobertCraigie/prisma-client-py/issues/45
# switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/stable/reference/limitations/

ListsRelationFilter = TypedDict(
    'ListsRelationFilter',
    {
        'is': 'Dict[str, Any]',
        'is_not': 'Dict[str, Any]',
    },
    total=False,
)


class ListsListRelationFilter(TypedDict, total=False):
    some: 'Dict[str, Any]'
    none: 'Dict[str, Any]'
    every: 'Dict[str, Any]'


class ListsInclude(TypedDict, total=False):
    """Lists relational arguments"""


    

class PostIncludeFromLists(TypedDict, total=False):
    """Relational arguments for Lists"""
    author: Union[bool, 'UserArgsFromListsRecursive1']


class PostIncludeFromListsRecursive1(TypedDict, total=False):
    """Relational arguments for Lists"""
    author: Union[bool, 'UserArgsFromListsRecursive2']


class PostIncludeFromListsRecursive2(TypedDict, total=False):
    """Relational arguments for Lists"""

    

class PostArgsFromLists(TypedDict, total=False):
    """Arguments for Lists"""
    include: 'PostIncludeFromListsRecursive1'


class PostArgsFromListsRecursive1(TypedDict, total=False):
    """Arguments for Lists"""
    include: 'PostIncludeFromListsRecursive2'


class PostArgsFromListsRecursive2(TypedDict, total=False):
    """Arguments for Lists"""
    
    

class FindManyPostArgsFromLists(TypedDict, total=False):
    """Arguments for Lists"""
    take: int
    skip: int
    order_by: Union['PostOrderByInput', List['PostOrderByInput']]
    where: 'PostWhereInput'
    cursor: 'PostWhereUniqueInput'
    distinct: List['PostScalarFieldKeys']
    include: 'PostIncludeFromListsRecursive1'


class FindManyPostArgsFromListsRecursive1(TypedDict, total=False):
    """Arguments for Lists"""
    take: int
    skip: int
    order_by: Union['PostOrderByInput', List['PostOrderByInput']]
    where: 'PostWhereInput'
    cursor: 'PostWhereUniqueInput'
    distinct: List['PostScalarFieldKeys']
    include: 'PostIncludeFromListsRecursive2'


class FindManyPostArgsFromListsRecursive2(TypedDict, total=False):
    """Arguments for Lists"""
    take: int
    skip: int
    order_by: Union['PostOrderByInput', List['PostOrderByInput']]
    where: 'PostWhereInput'
    cursor: 'PostWhereUniqueInput'
    distinct: List['PostScalarFieldKeys']
        

class UserIncludeFromLists(TypedDict, total=False):
    """Relational arguments for Lists"""
    posts: Union[bool, 'FindManyPostArgsFromListsRecursive1']


class UserIncludeFromListsRecursive1(TypedDict, total=False):
    """Relational arguments for Lists"""
    posts: Union[bool, 'FindManyPostArgsFromListsRecursive2']


class UserIncludeFromListsRecursive2(TypedDict, total=False):
    """Relational arguments for Lists"""

    

class UserArgsFromLists(TypedDict, total=False):
    """Arguments for Lists"""
    include: 'UserIncludeFromListsRecursive1'


class UserArgsFromListsRecursive1(TypedDict, total=False):
    """Arguments for Lists"""
    include: 'UserIncludeFromListsRecursive2'


class UserArgsFromListsRecursive2(TypedDict, total=False):
    """Arguments for Lists"""
    
    

class FindManyUserArgsFromLists(TypedDict, total=False):
    """Arguments for Lists"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromListsRecursive1'


class FindManyUserArgsFromListsRecursive1(TypedDict, total=False):
    """Arguments for Lists"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromListsRecursive2'


class FindManyUserArgsFromListsRecursive2(TypedDict, total=False):
    """Arguments for Lists"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
        

class MIncludeFromLists(TypedDict, total=False):
    """Relational arguments for Lists"""
    n: Union[bool, 'FindManyNArgsFromListsRecursive1']


class MIncludeFromListsRecursive1(TypedDict, total=False):
    """Relational arguments for Lists"""
    n: Union[bool, 'FindManyNArgsFromListsRecursive2']


class MIncludeFromListsRecursive2(TypedDict, total=False):
    """Relational arguments for Lists"""

    

class MArgsFromLists(TypedDict, total=False):
    """Arguments for Lists"""
    include: 'MIncludeFromListsRecursive1'


class MArgsFromListsRecursive1(TypedDict, total=False):
    """Arguments for Lists"""
    include: 'MIncludeFromListsRecursive2'


class MArgsFromListsRecursive2(TypedDict, total=False):
    """Arguments for Lists"""
    
    

class FindManyMArgsFromLists(TypedDict, total=False):
    """Arguments for Lists"""
    take: int
    skip: int
    order_by: Union['MOrderByInput', List['MOrderByInput']]
    where: 'MWhereInput'
    cursor: 'MWhereUniqueInput'
    distinct: List['MScalarFieldKeys']
    include: 'MIncludeFromListsRecursive1'


class FindManyMArgsFromListsRecursive1(TypedDict, total=False):
    """Arguments for Lists"""
    take: int
    skip: int
    order_by: Union['MOrderByInput', List['MOrderByInput']]
    where: 'MWhereInput'
    cursor: 'MWhereUniqueInput'
    distinct: List['MScalarFieldKeys']
    include: 'MIncludeFromListsRecursive2'


class FindManyMArgsFromListsRecursive2(TypedDict, total=False):
    """Arguments for Lists"""
    take: int
    skip: int
    order_by: Union['MOrderByInput', List['MOrderByInput']]
    where: 'MWhereInput'
    cursor: 'MWhereUniqueInput'
    distinct: List['MScalarFieldKeys']
        

class NIncludeFromLists(TypedDict, total=False):
    """Relational arguments for Lists"""
    m: Union[bool, 'FindManyMArgsFromListsRecursive1']


class NIncludeFromListsRecursive1(TypedDict, total=False):
    """Relational arguments for Lists"""
    m: Union[bool, 'FindManyMArgsFromListsRecursive2']


class NIncludeFromListsRecursive2(TypedDict, total=False):
    """Relational arguments for Lists"""

    

class NArgsFromLists(TypedDict, total=False):
    """Arguments for Lists"""
    include: 'NIncludeFromListsRecursive1'


class NArgsFromListsRecursive1(TypedDict, total=False):
    """Arguments for Lists"""
    include: 'NIncludeFromListsRecursive2'


class NArgsFromListsRecursive2(TypedDict, total=False):
    """Arguments for Lists"""
    
    

class FindManyNArgsFromLists(TypedDict, total=False):
    """Arguments for Lists"""
    take: int
    skip: int
    order_by: Union['NOrderByInput', List['NOrderByInput']]
    where: 'NWhereInput'
    cursor: 'NWhereUniqueInput'
    distinct: List['NScalarFieldKeys']
    include: 'NIncludeFromListsRecursive1'


class FindManyNArgsFromListsRecursive1(TypedDict, total=False):
    """Arguments for Lists"""
    take: int
    skip: int
    order_by: Union['NOrderByInput', List['NOrderByInput']]
    where: 'NWhereInput'
    cursor: 'NWhereUniqueInput'
    distinct: List['NScalarFieldKeys']
    include: 'NIncludeFromListsRecursive2'


class FindManyNArgsFromListsRecursive2(TypedDict, total=False):
    """Arguments for Lists"""
    take: int
    skip: int
    order_by: Union['NOrderByInput', List['NOrderByInput']]
    where: 'NWhereInput'
    cursor: 'NWhereUniqueInput'
    distinct: List['NScalarFieldKeys']
        

class OneOptionalIncludeFromLists(TypedDict, total=False):
    """Relational arguments for Lists"""
    many: Union[bool, 'FindManyManyRequiredArgsFromListsRecursive1']


class OneOptionalIncludeFromListsRecursive1(TypedDict, total=False):
    """Relational arguments for Lists"""
    many: Union[bool, 'FindManyManyRequiredArgsFromListsRecursive2']


class OneOptionalIncludeFromListsRecursive2(TypedDict, total=False):
    """Relational arguments for Lists"""

    

class OneOptionalArgsFromLists(TypedDict, total=False):
    """Arguments for Lists"""
    include: 'OneOptionalIncludeFromListsRecursive1'


class OneOptionalArgsFromListsRecursive1(TypedDict, total=False):
    """Arguments for Lists"""
    include: 'OneOptionalIncludeFromListsRecursive2'


class OneOptionalArgsFromListsRecursive2(TypedDict, total=False):
    """Arguments for Lists"""
    
    

class FindManyOneOptionalArgsFromLists(TypedDict, total=False):
    """Arguments for Lists"""
    take: int
    skip: int
    order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
    where: 'OneOptionalWhereInput'
    cursor: 'OneOptionalWhereUniqueInput'
    distinct: List['OneOptionalScalarFieldKeys']
    include: 'OneOptionalIncludeFromListsRecursive1'


class FindManyOneOptionalArgsFromListsRecursive1(TypedDict, total=False):
    """Arguments for Lists"""
    take: int
    skip: int
    order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
    where: 'OneOptionalWhereInput'
    cursor: 'OneOptionalWhereUniqueInput'
    distinct: List['OneOptionalScalarFieldKeys']
    include: 'OneOptionalIncludeFromListsRecursive2'


class FindManyOneOptionalArgsFromListsRecursive2(TypedDict, total=False):
    """Arguments for Lists"""
    take: int
    skip: int
    order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
    where: 'OneOptionalWhereInput'
    cursor: 'OneOptionalWhereUniqueInput'
    distinct: List['OneOptionalScalarFieldKeys']
        

class ManyRequiredIncludeFromLists(TypedDict, total=False):
    """Relational arguments for Lists"""
    one: Union[bool, 'OneOptionalArgsFromListsRecursive1']


class ManyRequiredIncludeFromListsRecursive1(TypedDict, total=False):
    """Relational arguments for Lists"""
    one: Union[bool, 'OneOptionalArgsFromListsRecursive2']


class ManyRequiredIncludeFromListsRecursive2(TypedDict, total=False):
    """Relational arguments for Lists"""

    

class ManyRequiredArgsFromLists(TypedDict, total=False):
    """Arguments for Lists"""
    include: 'ManyRequiredIncludeFromListsRecursive1'


class ManyRequiredArgsFromListsRecursive1(TypedDict, total=False):
    """Arguments for Lists"""
    include: 'ManyRequiredIncludeFromListsRecursive2'


class ManyRequiredArgsFromListsRecursive2(TypedDict, total=False):
    """Arguments for Lists"""
    
    

class FindManyManyRequiredArgsFromLists(TypedDict, total=False):
    """Arguments for Lists"""
    take: int
    skip: int
    order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
    where: 'ManyRequiredWhereInput'
    cursor: 'ManyRequiredWhereUniqueInput'
    distinct: List['ManyRequiredScalarFieldKeys']
    include: 'ManyRequiredIncludeFromListsRecursive1'


class FindManyManyRequiredArgsFromListsRecursive1(TypedDict, total=False):
    """Arguments for Lists"""
    take: int
    skip: int
    order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
    where: 'ManyRequiredWhereInput'
    cursor: 'ManyRequiredWhereUniqueInput'
    distinct: List['ManyRequiredScalarFieldKeys']
    include: 'ManyRequiredIncludeFromListsRecursive2'


class FindManyManyRequiredArgsFromListsRecursive2(TypedDict, total=False):
    """Arguments for Lists"""
    take: int
    skip: int
    order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
    where: 'ManyRequiredWhereInput'
    cursor: 'ManyRequiredWhereUniqueInput'
    distinct: List['ManyRequiredScalarFieldKeys']
        

class ListsIncludeFromLists(TypedDict, total=False):
    """Relational arguments for Lists"""


class ListsIncludeFromListsRecursive1(TypedDict, total=False):
    """Relational arguments for Lists"""


class ListsIncludeFromListsRecursive2(TypedDict, total=False):
    """Relational arguments for Lists"""

    

class ListsArgsFromLists(TypedDict, total=False):
    """Arguments for Lists"""
    include: 'ListsIncludeFromListsRecursive1'


class ListsArgsFromListsRecursive1(TypedDict, total=False):
    """Arguments for Lists"""
    include: 'ListsIncludeFromListsRecursive2'


class ListsArgsFromListsRecursive2(TypedDict, total=False):
    """Arguments for Lists"""
    
    

class FindManyListsArgsFromLists(TypedDict, total=False):
    """Arguments for Lists"""
    take: int
    skip: int
    order_by: Union['ListsOrderByInput', List['ListsOrderByInput']]
    where: 'ListsWhereInput'
    cursor: 'ListsWhereUniqueInput'
    distinct: List['ListsScalarFieldKeys']
    include: 'ListsIncludeFromListsRecursive1'


class FindManyListsArgsFromListsRecursive1(TypedDict, total=False):
    """Arguments for Lists"""
    take: int
    skip: int
    order_by: Union['ListsOrderByInput', List['ListsOrderByInput']]
    where: 'ListsWhereInput'
    cursor: 'ListsWhereUniqueInput'
    distinct: List['ListsScalarFieldKeys']
    include: 'ListsIncludeFromListsRecursive2'


class FindManyListsArgsFromListsRecursive2(TypedDict, total=False):
    """Arguments for Lists"""
    take: int
    skip: int
    order_by: Union['ListsOrderByInput', List['ListsOrderByInput']]
    where: 'ListsWhereInput'
    cursor: 'ListsWhereUniqueInput'
    distinct: List['ListsScalarFieldKeys']
        

class AIncludeFromLists(TypedDict, total=False):
    """Relational arguments for Lists"""


class AIncludeFromListsRecursive1(TypedDict, total=False):
    """Relational arguments for Lists"""


class AIncludeFromListsRecursive2(TypedDict, total=False):
    """Relational arguments for Lists"""

    

class AArgsFromLists(TypedDict, total=False):
    """Arguments for Lists"""
    include: 'AIncludeFromListsRecursive1'


class AArgsFromListsRecursive1(TypedDict, total=False):
    """Arguments for Lists"""
    include: 'AIncludeFromListsRecursive2'


class AArgsFromListsRecursive2(TypedDict, total=False):
    """Arguments for Lists"""
    
    

class FindManyAArgsFromLists(TypedDict, total=False):
    """Arguments for Lists"""
    take: int
    skip: int
    order_by: Union['AOrderByInput', List['AOrderByInput']]
    where: 'AWhereInput'
    cursor: 'AWhereUniqueInput'
    distinct: List['AScalarFieldKeys']
    include: 'AIncludeFromListsRecursive1'


class FindManyAArgsFromListsRecursive1(TypedDict, total=False):
    """Arguments for Lists"""
    take: int
    skip: int
    order_by: Union['AOrderByInput', List['AOrderByInput']]
    where: 'AWhereInput'
    cursor: 'AWhereUniqueInput'
    distinct: List['AScalarFieldKeys']
    include: 'AIncludeFromListsRecursive2'


class FindManyAArgsFromListsRecursive2(TypedDict, total=False):
    """Arguments for Lists"""
    take: int
    skip: int
    order_by: Union['AOrderByInput', List['AOrderByInput']]
    where: 'AWhereInput'
    cursor: 'AWhereUniqueInput'
    distinct: List['AScalarFieldKeys']
        

class BIncludeFromLists(TypedDict, total=False):
    """Relational arguments for Lists"""


class BIncludeFromListsRecursive1(TypedDict, total=False):
    """Relational arguments for Lists"""


class BIncludeFromListsRecursive2(TypedDict, total=False):
    """Relational arguments for Lists"""

    

class BArgsFromLists(TypedDict, total=False):
    """Arguments for Lists"""
    include: 'BIncludeFromListsRecursive1'


class BArgsFromListsRecursive1(TypedDict, total=False):
    """Arguments for Lists"""
    include: 'BIncludeFromListsRecursive2'


class BArgsFromListsRecursive2(TypedDict, total=False):
    """Arguments for Lists"""
    
    

class FindManyBArgsFromLists(TypedDict, total=False):
    """Arguments for Lists"""
    take: int
    skip: int
    order_by: Union['BOrderByInput', List['BOrderByInput']]
    where: 'BWhereInput'
    cursor: 'BWhereUniqueInput'
    distinct: List['BScalarFieldKeys']
    include: 'BIncludeFromListsRecursive1'


class FindManyBArgsFromListsRecursive1(TypedDict, total=False):
    """Arguments for Lists"""
    take: int
    skip: int
    order_by: Union['BOrderByInput', List['BOrderByInput']]
    where: 'BWhereInput'
    cursor: 'BWhereUniqueInput'
    distinct: List['BScalarFieldKeys']
    include: 'BIncludeFromListsRecursive2'


class FindManyBArgsFromListsRecursive2(TypedDict, total=False):
    """Arguments for Lists"""
    take: int
    skip: int
    order_by: Union['BOrderByInput', List['BOrderByInput']]
    where: 'BWhereInput'
    cursor: 'BWhereUniqueInput'
    distinct: List['BScalarFieldKeys']
        

class CIncludeFromLists(TypedDict, total=False):
    """Relational arguments for Lists"""


class CIncludeFromListsRecursive1(TypedDict, total=False):
    """Relational arguments for Lists"""


class CIncludeFromListsRecursive2(TypedDict, total=False):
    """Relational arguments for Lists"""

    

class CArgsFromLists(TypedDict, total=False):
    """Arguments for Lists"""
    include: 'CIncludeFromListsRecursive1'


class CArgsFromListsRecursive1(TypedDict, total=False):
    """Arguments for Lists"""
    include: 'CIncludeFromListsRecursive2'


class CArgsFromListsRecursive2(TypedDict, total=False):
    """Arguments for Lists"""
    
    

class FindManyCArgsFromLists(TypedDict, total=False):
    """Arguments for Lists"""
    take: int
    skip: int
    order_by: Union['COrderByInput', List['COrderByInput']]
    where: 'CWhereInput'
    cursor: 'CWhereUniqueInput'
    distinct: List['CScalarFieldKeys']
    include: 'CIncludeFromListsRecursive1'


class FindManyCArgsFromListsRecursive1(TypedDict, total=False):
    """Arguments for Lists"""
    take: int
    skip: int
    order_by: Union['COrderByInput', List['COrderByInput']]
    where: 'CWhereInput'
    cursor: 'CWhereUniqueInput'
    distinct: List['CScalarFieldKeys']
    include: 'CIncludeFromListsRecursive2'


class FindManyCArgsFromListsRecursive2(TypedDict, total=False):
    """Arguments for Lists"""
    take: int
    skip: int
    order_by: Union['COrderByInput', List['COrderByInput']]
    where: 'CWhereInput'
    cursor: 'CWhereUniqueInput'
    distinct: List['CScalarFieldKeys']
        

class DIncludeFromLists(TypedDict, total=False):
    """Relational arguments for Lists"""


class DIncludeFromListsRecursive1(TypedDict, total=False):
    """Relational arguments for Lists"""


class DIncludeFromListsRecursive2(TypedDict, total=False):
    """Relational arguments for Lists"""

    

class DArgsFromLists(TypedDict, total=False):
    """Arguments for Lists"""
    include: 'DIncludeFromListsRecursive1'


class DArgsFromListsRecursive1(TypedDict, total=False):
    """Arguments for Lists"""
    include: 'DIncludeFromListsRecursive2'


class DArgsFromListsRecursive2(TypedDict, total=False):
    """Arguments for Lists"""
    
    

class FindManyDArgsFromLists(TypedDict, total=False):
    """Arguments for Lists"""
    take: int
    skip: int
    order_by: Union['DOrderByInput', List['DOrderByInput']]
    where: 'DWhereInput'
    cursor: 'DWhereUniqueInput'
    distinct: List['DScalarFieldKeys']
    include: 'DIncludeFromListsRecursive1'


class FindManyDArgsFromListsRecursive1(TypedDict, total=False):
    """Arguments for Lists"""
    take: int
    skip: int
    order_by: Union['DOrderByInput', List['DOrderByInput']]
    where: 'DWhereInput'
    cursor: 'DWhereUniqueInput'
    distinct: List['DScalarFieldKeys']
    include: 'DIncludeFromListsRecursive2'


class FindManyDArgsFromListsRecursive2(TypedDict, total=False):
    """Arguments for Lists"""
    take: int
    skip: int
    order_by: Union['DOrderByInput', List['DOrderByInput']]
    where: 'DWhereInput'
    cursor: 'DWhereUniqueInput'
    distinct: List['DScalarFieldKeys']
        

class EIncludeFromLists(TypedDict, total=False):
    """Relational arguments for Lists"""


class EIncludeFromListsRecursive1(TypedDict, total=False):
    """Relational arguments for Lists"""


class EIncludeFromListsRecursive2(TypedDict, total=False):
    """Relational arguments for Lists"""

    

class EArgsFromLists(TypedDict, total=False):
    """Arguments for Lists"""
    include: 'EIncludeFromListsRecursive1'


class EArgsFromListsRecursive1(TypedDict, total=False):
    """Arguments for Lists"""
    include: 'EIncludeFromListsRecursive2'


class EArgsFromListsRecursive2(TypedDict, total=False):
    """Arguments for Lists"""
    
    

class FindManyEArgsFromLists(TypedDict, total=False):
    """Arguments for Lists"""
    take: int
    skip: int
    order_by: Union['EOrderByInput', List['EOrderByInput']]
    where: 'EWhereInput'
    cursor: 'EWhereUniqueInput'
    distinct: List['EScalarFieldKeys']
    include: 'EIncludeFromListsRecursive1'


class FindManyEArgsFromListsRecursive1(TypedDict, total=False):
    """Arguments for Lists"""
    take: int
    skip: int
    order_by: Union['EOrderByInput', List['EOrderByInput']]
    where: 'EWhereInput'
    cursor: 'EWhereUniqueInput'
    distinct: List['EScalarFieldKeys']
    include: 'EIncludeFromListsRecursive2'


class FindManyEArgsFromListsRecursive2(TypedDict, total=False):
    """Arguments for Lists"""
    take: int
    skip: int
    order_by: Union['EOrderByInput', List['EOrderByInput']]
    where: 'EWhereInput'
    cursor: 'EWhereUniqueInput'
    distinct: List['EScalarFieldKeys']
    

FindManyListsArgs = FindManyListsArgsFromLists
FindFirstListsArgs = FindManyListsArgsFromLists


    

class ListsWhereInput(TypedDict, total=False):
    """Lists arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    strings: 'types.StringListFilter'
    bytes: 'types.BytesListFilter'
    dates: 'types.DateTimeListFilter'
    bools: 'types.BooleanListFilter'
    ints: 'types.IntListFilter'
    floats: 'types.FloatListFilter'
    bigints: 'types.BigIntListFilter'
    json_objects: 'types.JsonListFilter'
    decimals: 'types.DecimalListFilter'

    # should be noted that AND and NOT should be Union['ListsWhereInputRecursive1', List['ListsWhereInputRecursive1']]
    # but this causes mypy to hang :/
    AND: List['ListsWhereInputRecursive1']
    OR: List['ListsWhereInputRecursive1']
    NOT: List['ListsWhereInputRecursive1']


class ListsWhereInputRecursive1(TypedDict, total=False):
    """Lists arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    strings: 'types.StringListFilter'
    bytes: 'types.BytesListFilter'
    dates: 'types.DateTimeListFilter'
    bools: 'types.BooleanListFilter'
    ints: 'types.IntListFilter'
    floats: 'types.FloatListFilter'
    bigints: 'types.BigIntListFilter'
    json_objects: 'types.JsonListFilter'
    decimals: 'types.DecimalListFilter'

    # should be noted that AND and NOT should be Union['ListsWhereInputRecursive2', List['ListsWhereInputRecursive2']]
    # but this causes mypy to hang :/
    AND: List['ListsWhereInputRecursive2']
    OR: List['ListsWhereInputRecursive2']
    NOT: List['ListsWhereInputRecursive2']


class ListsWhereInputRecursive2(TypedDict, total=False):
    """Lists arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    strings: 'types.StringListFilter'
    bytes: 'types.BytesListFilter'
    dates: 'types.DateTimeListFilter'
    bools: 'types.BooleanListFilter'
    ints: 'types.IntListFilter'
    floats: 'types.FloatListFilter'
    bigints: 'types.BigIntListFilter'
    json_objects: 'types.JsonListFilter'
    decimals: 'types.DecimalListFilter'



# aggregate Lists types


    

class ListsScalarWhereWithAggregatesInput(TypedDict, total=False):
    """Lists arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    strings: Union[_str, 'types.StringWithAggregatesFilter']
    bytes: Union['fields.Base64', 'types.BytesWithAggregatesFilter']
    dates: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    bools: Union[_bool, 'types.BooleanWithAggregatesFilter']
    ints: Union[_int, 'types.IntWithAggregatesFilter']
    floats: Union[_float, 'types.FloatWithAggregatesFilter']
    bigints: Union[_int, 'types.BigIntWithAggregatesFilter']
    json_objects: Union['fields.Json', 'types.JsonWithAggregatesFilter']
    decimals: Union[decimal.Decimal, 'types.DecimalWithAggregatesFilter']

    AND: List['ListsScalarWhereWithAggregatesInputRecursive1']
    OR: List['ListsScalarWhereWithAggregatesInputRecursive1']
    NOT: List['ListsScalarWhereWithAggregatesInputRecursive1']


class ListsScalarWhereWithAggregatesInputRecursive1(TypedDict, total=False):
    """Lists arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    strings: Union[_str, 'types.StringWithAggregatesFilter']
    bytes: Union['fields.Base64', 'types.BytesWithAggregatesFilter']
    dates: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    bools: Union[_bool, 'types.BooleanWithAggregatesFilter']
    ints: Union[_int, 'types.IntWithAggregatesFilter']
    floats: Union[_float, 'types.FloatWithAggregatesFilter']
    bigints: Union[_int, 'types.BigIntWithAggregatesFilter']
    json_objects: Union['fields.Json', 'types.JsonWithAggregatesFilter']
    decimals: Union[decimal.Decimal, 'types.DecimalWithAggregatesFilter']

    AND: List['ListsScalarWhereWithAggregatesInputRecursive2']
    OR: List['ListsScalarWhereWithAggregatesInputRecursive2']
    NOT: List['ListsScalarWhereWithAggregatesInputRecursive2']


class ListsScalarWhereWithAggregatesInputRecursive2(TypedDict, total=False):
    """Lists arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    strings: Union[_str, 'types.StringWithAggregatesFilter']
    bytes: Union['fields.Base64', 'types.BytesWithAggregatesFilter']
    dates: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    bools: Union[_bool, 'types.BooleanWithAggregatesFilter']
    ints: Union[_int, 'types.IntWithAggregatesFilter']
    floats: Union[_float, 'types.FloatWithAggregatesFilter']
    bigints: Union[_int, 'types.BigIntWithAggregatesFilter']
    json_objects: Union['fields.Json', 'types.JsonWithAggregatesFilter']
    decimals: Union[decimal.Decimal, 'types.DecimalWithAggregatesFilter']



class ListsGroupByOutput(TypedDict, total=False):
    id: _str
    strings: List[_str]
    bytes: List['fields.Base64']
    dates: List[datetime.datetime]
    bools: List[_bool]
    ints: List[_int]
    floats: List[_float]
    bigints: List[_int]
    json_objects: List['fields.Json']
    decimals: List[decimal.Decimal]
    _sum: 'ListsSumAggregateOutput'
    _avg: 'ListsAvgAggregateOutput'
    _min: 'ListsMinAggregateOutput'
    _max: 'ListsMaxAggregateOutput'
    _count: 'ListsCountAggregateOutput'


class ListsAvgAggregateOutput(TypedDict, total=False):
    """Lists output for aggregating averages"""
    ints: float
    floats: float
    bigints: float


class ListsSumAggregateOutput(TypedDict, total=False):
    """Lists output for aggregating sums"""
    ints: List[_int]
    floats: List[_float]
    bigints: List[_int]


class ListsScalarAggregateOutput(TypedDict, total=False):
    """Lists output including scalar fields"""
    id: _str
    strings: List[_str]
    bytes: List['fields.Base64']
    dates: List[datetime.datetime]
    bools: List[_bool]
    ints: List[_int]
    floats: List[_float]
    bigints: List[_int]
    json_objects: List['fields.Json']
    decimals: List[decimal.Decimal]


ListsMinAggregateOutput = ListsScalarAggregateOutput
ListsMaxAggregateOutput = ListsScalarAggregateOutput


class ListsMaxAggregateInput(TypedDict, total=False):
    """Lists input for aggregating by max"""
    id: bool
    strings: bool
    bytes: bool
    dates: bool
    bools: bool
    ints: bool
    floats: bool
    bigints: bool
    json_objects: bool
    decimals: bool


class ListsMinAggregateInput(TypedDict, total=False):
    """Lists input for aggregating by min"""
    id: bool
    strings: bool
    bytes: bool
    dates: bool
    bools: bool
    ints: bool
    floats: bool
    bigints: bool
    json_objects: bool
    decimals: bool


class ListsNumberAggregateInput(TypedDict, total=False):
    """Lists input for aggregating numbers"""
    ints: bool
    floats: bool
    bigints: bool


ListsAvgAggregateInput = ListsNumberAggregateInput
ListsSumAggregateInput = ListsNumberAggregateInput


ListsCountAggregateInput = TypedDict(
    'ListsCountAggregateInput',
    {
        'id': bool,
        'strings': bool,
        'bytes': bool,
        'dates': bool,
        'bools': bool,
        'ints': bool,
        'floats': bool,
        'bigints': bool,
        'json_objects': bool,
        'decimals': bool,
        '_all': bool,
    },
    total=False,
)

ListsCountAggregateOutput = TypedDict(
    'ListsCountAggregateOutput',
    {
        'id': int,
        'strings': int,
        'bytes': int,
        'dates': int,
        'bools': int,
        'ints': int,
        'floats': int,
        'bigints': int,
        'json_objects': int,
        'decimals': int,
        '_all': int,
    },
    total=False,
)


ListsKeys = Literal[
    'id',
    'strings',
    'bytes',
    'dates',
    'bools',
    'ints',
    'floats',
    'bigints',
    'json_objects',
    'decimals',
]
ListsScalarFieldKeys = Literal[
    'id',
    'strings',
    'bytes',
    'dates',
    'bools',
    'ints',
    'floats',
    'bigints',
    'json_objects',
    'decimals',
]
ListsScalarFieldKeysT = TypeVar('ListsScalarFieldKeysT', bound=ListsScalarFieldKeys)

ListsRelationalFieldKeys = _NoneType


# we have to import ourselves as forward references may use 'types.XFilter' syntax
from .. import types, fields  # noqa: TID251

'''