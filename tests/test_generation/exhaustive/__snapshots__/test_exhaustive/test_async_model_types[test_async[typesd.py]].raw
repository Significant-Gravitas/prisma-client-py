'''
# -*- coding: utf-8 -*-
# code generated by Prisma. DO NOT EDIT.
# pyright: reportUnusedImport=false

from typing import (
    Any,
    Dict,
    List,
    Union,
    Literal,
    TypeVar,
    TypedDict,
)
from builtins import str as _str, bool as _bool

# -- template types/_model.py.jinja --
from .. import types, fields
from ..utils import _NoneType
from .atomic import *
from .filters import *
from .list_filters import *

# --- Types for model: D --- #


# D types


class DOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the D create method"""

    id: _str


class DCreateInput(DOptionalCreateInput):
    """Required arguments to the D create method"""

    bool: _bool
    xml: _str
    json_: 'fields.Json'
    jsonb: 'fields.Json'
    binary: 'fields.Base64'


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput


class DOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the D create method, without relations"""

    id: _str


class DCreateWithoutRelationsInput(DOptionalCreateWithoutRelationsInput):
    """Required arguments to the D create method, without relations"""

    bool: _bool
    xml: _str
    json_: 'fields.Json'
    jsonb: 'fields.Json'
    binary: 'fields.Base64'


class DConnectOrCreateWithoutRelationsInput(TypedDict):
    create: 'DCreateWithoutRelationsInput'
    where: 'DWhereUniqueInput'


class DCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'DCreateWithoutRelationsInput'
    connect: 'DWhereUniqueInput'
    connect_or_create: 'DConnectOrCreateWithoutRelationsInput'


class DCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['DCreateWithoutRelationsInput', List['DCreateWithoutRelationsInput']]
    connect: Union['DWhereUniqueInput', List['DWhereUniqueInput']]
    connect_or_create: Union['DConnectOrCreateWithoutRelationsInput', List['DConnectOrCreateWithoutRelationsInput']]


_DWhereUnique_id_Input = TypedDict(
    '_DWhereUnique_id_Input',
    {
        'id': '_str',
    },
    total=True,
)

DWhereUniqueInput = _DWhereUnique_id_Input


class DUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""

    id: _str
    bool: _bool
    xml: _str
    json_: 'fields.Json'
    jsonb: 'fields.Json'
    binary: 'fields.Base64'


class DUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""

    id: _str
    bool: _bool
    xml: _str
    json_: 'fields.Json'
    jsonb: 'fields.Json'
    binary: 'fields.Base64'


class DUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['DCreateWithoutRelationsInput']
    connect: List['DWhereUniqueInput']
    connect_or_create: List['DConnectOrCreateWithoutRelationsInput']
    set: List['DWhereUniqueInput']
    disconnect: List['DWhereUniqueInput']
    delete: List['DWhereUniqueInput']

    # TODO
    # update: List['DUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['DUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['DScalarWhereInput']
    # upsert: List['DUpserteWithWhereUniqueWithoutRelationsInput']


class DUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'DCreateWithoutRelationsInput'
    connect: 'DWhereUniqueInput'
    connect_or_create: 'DConnectOrCreateWithoutRelationsInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'DUpdateInput'
    # upsert: 'DUpsertWithoutRelationsInput'


class DUpsertInput(TypedDict):
    create: 'DCreateInput'
    update: 'DUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_D_id_OrderByInput = TypedDict(
    '_D_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True,
)

_D_bool_OrderByInput = TypedDict(
    '_D_bool_OrderByInput',
    {
        'bool': 'SortOrder',
    },
    total=True,
)

_D_xml_OrderByInput = TypedDict(
    '_D_xml_OrderByInput',
    {
        'xml': 'SortOrder',
    },
    total=True,
)

_D_json__OrderByInput = TypedDict(
    '_D_json__OrderByInput',
    {
        'json_': 'SortOrder',
    },
    total=True,
)

_D_jsonb_OrderByInput = TypedDict(
    '_D_jsonb_OrderByInput',
    {
        'jsonb': 'SortOrder',
    },
    total=True,
)

_D_binary_OrderByInput = TypedDict(
    '_D_binary_OrderByInput',
    {
        'binary': 'SortOrder',
    },
    total=True,
)

_D_RelevanceInner = TypedDict(
    '_D_RelevanceInner',
    {
        'fields': 'List[DScalarFieldKeys]',
        'search': 'str',
        'sort': 'SortOrder',
    },
    total=True,
)

_D_RelevanceOrderByInput = TypedDict(
    '_D_RelevanceOrderByInput',
    {
        '_relevance': '_D_RelevanceInner',
    },
    total=True,
)

DOrderByInput = Union[
    '_D_id_OrderByInput',
    '_D_bool_OrderByInput',
    '_D_xml_OrderByInput',
    '_D_json__OrderByInput',
    '_D_jsonb_OrderByInput',
    '_D_binary_OrderByInput',
    '_D_RelevanceOrderByInput',
]


# recursive D types
# TODO: cleanup these types


# Dict[str, Any] is a mypy limitation
# see https://github.com/RobertCraigie/prisma-client-py/issues/45
# switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/stable/reference/limitations/

DRelationFilter = TypedDict(
    'DRelationFilter',
    {
        'is': 'Dict[str, Any]',
        'is_not': 'Dict[str, Any]',
    },
    total=False,
)


class DListRelationFilter(TypedDict, total=False):
    some: 'Dict[str, Any]'
    none: 'Dict[str, Any]'
    every: 'Dict[str, Any]'


class DInclude(TypedDict, total=False):
    """D relational arguments"""


class PostIncludeFromD(TypedDict, total=False):
    """Relational arguments for D"""

    author: Union[bool, 'UserArgsFromDRecursive1']


class PostIncludeFromDRecursive1(TypedDict, total=False):
    """Relational arguments for D"""

    author: Union[bool, 'UserArgsFromDRecursive2']


class PostIncludeFromDRecursive2(TypedDict, total=False):
    """Relational arguments for D"""


class PostArgsFromD(TypedDict, total=False):
    """Arguments for D"""

    include: 'PostIncludeFromDRecursive1'


class PostArgsFromDRecursive1(TypedDict, total=False):
    """Arguments for D"""

    include: 'PostIncludeFromDRecursive2'


class PostArgsFromDRecursive2(TypedDict, total=False):
    """Arguments for D"""


class FindManyPostArgsFromD(TypedDict, total=False):
    """Arguments for D"""

    take: int
    skip: int
    order_by: Union['PostOrderByInput', List['PostOrderByInput']]
    where: 'PostWhereInput'
    cursor: 'PostWhereUniqueInput'
    distinct: List['PostScalarFieldKeys']
    include: 'PostIncludeFromDRecursive1'


class FindManyPostArgsFromDRecursive1(TypedDict, total=False):
    """Arguments for D"""

    take: int
    skip: int
    order_by: Union['PostOrderByInput', List['PostOrderByInput']]
    where: 'PostWhereInput'
    cursor: 'PostWhereUniqueInput'
    distinct: List['PostScalarFieldKeys']
    include: 'PostIncludeFromDRecursive2'


class FindManyPostArgsFromDRecursive2(TypedDict, total=False):
    """Arguments for D"""

    take: int
    skip: int
    order_by: Union['PostOrderByInput', List['PostOrderByInput']]
    where: 'PostWhereInput'
    cursor: 'PostWhereUniqueInput'
    distinct: List['PostScalarFieldKeys']


class UserIncludeFromD(TypedDict, total=False):
    """Relational arguments for D"""

    posts: Union[bool, 'FindManyPostArgsFromDRecursive1']


class UserIncludeFromDRecursive1(TypedDict, total=False):
    """Relational arguments for D"""

    posts: Union[bool, 'FindManyPostArgsFromDRecursive2']


class UserIncludeFromDRecursive2(TypedDict, total=False):
    """Relational arguments for D"""


class UserArgsFromD(TypedDict, total=False):
    """Arguments for D"""

    include: 'UserIncludeFromDRecursive1'


class UserArgsFromDRecursive1(TypedDict, total=False):
    """Arguments for D"""

    include: 'UserIncludeFromDRecursive2'


class UserArgsFromDRecursive2(TypedDict, total=False):
    """Arguments for D"""


class FindManyUserArgsFromD(TypedDict, total=False):
    """Arguments for D"""

    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromDRecursive1'


class FindManyUserArgsFromDRecursive1(TypedDict, total=False):
    """Arguments for D"""

    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromDRecursive2'


class FindManyUserArgsFromDRecursive2(TypedDict, total=False):
    """Arguments for D"""

    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']


class MIncludeFromD(TypedDict, total=False):
    """Relational arguments for D"""

    n: Union[bool, 'FindManyNArgsFromDRecursive1']


class MIncludeFromDRecursive1(TypedDict, total=False):
    """Relational arguments for D"""

    n: Union[bool, 'FindManyNArgsFromDRecursive2']


class MIncludeFromDRecursive2(TypedDict, total=False):
    """Relational arguments for D"""


class MArgsFromD(TypedDict, total=False):
    """Arguments for D"""

    include: 'MIncludeFromDRecursive1'


class MArgsFromDRecursive1(TypedDict, total=False):
    """Arguments for D"""

    include: 'MIncludeFromDRecursive2'


class MArgsFromDRecursive2(TypedDict, total=False):
    """Arguments for D"""


class FindManyMArgsFromD(TypedDict, total=False):
    """Arguments for D"""

    take: int
    skip: int
    order_by: Union['MOrderByInput', List['MOrderByInput']]
    where: 'MWhereInput'
    cursor: 'MWhereUniqueInput'
    distinct: List['MScalarFieldKeys']
    include: 'MIncludeFromDRecursive1'


class FindManyMArgsFromDRecursive1(TypedDict, total=False):
    """Arguments for D"""

    take: int
    skip: int
    order_by: Union['MOrderByInput', List['MOrderByInput']]
    where: 'MWhereInput'
    cursor: 'MWhereUniqueInput'
    distinct: List['MScalarFieldKeys']
    include: 'MIncludeFromDRecursive2'


class FindManyMArgsFromDRecursive2(TypedDict, total=False):
    """Arguments for D"""

    take: int
    skip: int
    order_by: Union['MOrderByInput', List['MOrderByInput']]
    where: 'MWhereInput'
    cursor: 'MWhereUniqueInput'
    distinct: List['MScalarFieldKeys']


class NIncludeFromD(TypedDict, total=False):
    """Relational arguments for D"""

    m: Union[bool, 'FindManyMArgsFromDRecursive1']


class NIncludeFromDRecursive1(TypedDict, total=False):
    """Relational arguments for D"""

    m: Union[bool, 'FindManyMArgsFromDRecursive2']


class NIncludeFromDRecursive2(TypedDict, total=False):
    """Relational arguments for D"""


class NArgsFromD(TypedDict, total=False):
    """Arguments for D"""

    include: 'NIncludeFromDRecursive1'


class NArgsFromDRecursive1(TypedDict, total=False):
    """Arguments for D"""

    include: 'NIncludeFromDRecursive2'


class NArgsFromDRecursive2(TypedDict, total=False):
    """Arguments for D"""


class FindManyNArgsFromD(TypedDict, total=False):
    """Arguments for D"""

    take: int
    skip: int
    order_by: Union['NOrderByInput', List['NOrderByInput']]
    where: 'NWhereInput'
    cursor: 'NWhereUniqueInput'
    distinct: List['NScalarFieldKeys']
    include: 'NIncludeFromDRecursive1'


class FindManyNArgsFromDRecursive1(TypedDict, total=False):
    """Arguments for D"""

    take: int
    skip: int
    order_by: Union['NOrderByInput', List['NOrderByInput']]
    where: 'NWhereInput'
    cursor: 'NWhereUniqueInput'
    distinct: List['NScalarFieldKeys']
    include: 'NIncludeFromDRecursive2'


class FindManyNArgsFromDRecursive2(TypedDict, total=False):
    """Arguments for D"""

    take: int
    skip: int
    order_by: Union['NOrderByInput', List['NOrderByInput']]
    where: 'NWhereInput'
    cursor: 'NWhereUniqueInput'
    distinct: List['NScalarFieldKeys']


class OneOptionalIncludeFromD(TypedDict, total=False):
    """Relational arguments for D"""

    many: Union[bool, 'FindManyManyRequiredArgsFromDRecursive1']


class OneOptionalIncludeFromDRecursive1(TypedDict, total=False):
    """Relational arguments for D"""

    many: Union[bool, 'FindManyManyRequiredArgsFromDRecursive2']


class OneOptionalIncludeFromDRecursive2(TypedDict, total=False):
    """Relational arguments for D"""


class OneOptionalArgsFromD(TypedDict, total=False):
    """Arguments for D"""

    include: 'OneOptionalIncludeFromDRecursive1'


class OneOptionalArgsFromDRecursive1(TypedDict, total=False):
    """Arguments for D"""

    include: 'OneOptionalIncludeFromDRecursive2'


class OneOptionalArgsFromDRecursive2(TypedDict, total=False):
    """Arguments for D"""


class FindManyOneOptionalArgsFromD(TypedDict, total=False):
    """Arguments for D"""

    take: int
    skip: int
    order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
    where: 'OneOptionalWhereInput'
    cursor: 'OneOptionalWhereUniqueInput'
    distinct: List['OneOptionalScalarFieldKeys']
    include: 'OneOptionalIncludeFromDRecursive1'


class FindManyOneOptionalArgsFromDRecursive1(TypedDict, total=False):
    """Arguments for D"""

    take: int
    skip: int
    order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
    where: 'OneOptionalWhereInput'
    cursor: 'OneOptionalWhereUniqueInput'
    distinct: List['OneOptionalScalarFieldKeys']
    include: 'OneOptionalIncludeFromDRecursive2'


class FindManyOneOptionalArgsFromDRecursive2(TypedDict, total=False):
    """Arguments for D"""

    take: int
    skip: int
    order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
    where: 'OneOptionalWhereInput'
    cursor: 'OneOptionalWhereUniqueInput'
    distinct: List['OneOptionalScalarFieldKeys']


class ManyRequiredIncludeFromD(TypedDict, total=False):
    """Relational arguments for D"""

    one: Union[bool, 'OneOptionalArgsFromDRecursive1']


class ManyRequiredIncludeFromDRecursive1(TypedDict, total=False):
    """Relational arguments for D"""

    one: Union[bool, 'OneOptionalArgsFromDRecursive2']


class ManyRequiredIncludeFromDRecursive2(TypedDict, total=False):
    """Relational arguments for D"""


class ManyRequiredArgsFromD(TypedDict, total=False):
    """Arguments for D"""

    include: 'ManyRequiredIncludeFromDRecursive1'


class ManyRequiredArgsFromDRecursive1(TypedDict, total=False):
    """Arguments for D"""

    include: 'ManyRequiredIncludeFromDRecursive2'


class ManyRequiredArgsFromDRecursive2(TypedDict, total=False):
    """Arguments for D"""


class FindManyManyRequiredArgsFromD(TypedDict, total=False):
    """Arguments for D"""

    take: int
    skip: int
    order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
    where: 'ManyRequiredWhereInput'
    cursor: 'ManyRequiredWhereUniqueInput'
    distinct: List['ManyRequiredScalarFieldKeys']
    include: 'ManyRequiredIncludeFromDRecursive1'


class FindManyManyRequiredArgsFromDRecursive1(TypedDict, total=False):
    """Arguments for D"""

    take: int
    skip: int
    order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
    where: 'ManyRequiredWhereInput'
    cursor: 'ManyRequiredWhereUniqueInput'
    distinct: List['ManyRequiredScalarFieldKeys']
    include: 'ManyRequiredIncludeFromDRecursive2'


class FindManyManyRequiredArgsFromDRecursive2(TypedDict, total=False):
    """Arguments for D"""

    take: int
    skip: int
    order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
    where: 'ManyRequiredWhereInput'
    cursor: 'ManyRequiredWhereUniqueInput'
    distinct: List['ManyRequiredScalarFieldKeys']


class ListsIncludeFromD(TypedDict, total=False):
    """Relational arguments for D"""


class ListsIncludeFromDRecursive1(TypedDict, total=False):
    """Relational arguments for D"""


class ListsIncludeFromDRecursive2(TypedDict, total=False):
    """Relational arguments for D"""


class ListsArgsFromD(TypedDict, total=False):
    """Arguments for D"""

    include: 'ListsIncludeFromDRecursive1'


class ListsArgsFromDRecursive1(TypedDict, total=False):
    """Arguments for D"""

    include: 'ListsIncludeFromDRecursive2'


class ListsArgsFromDRecursive2(TypedDict, total=False):
    """Arguments for D"""


class FindManyListsArgsFromD(TypedDict, total=False):
    """Arguments for D"""

    take: int
    skip: int
    order_by: Union['ListsOrderByInput', List['ListsOrderByInput']]
    where: 'ListsWhereInput'
    cursor: 'ListsWhereUniqueInput'
    distinct: List['ListsScalarFieldKeys']
    include: 'ListsIncludeFromDRecursive1'


class FindManyListsArgsFromDRecursive1(TypedDict, total=False):
    """Arguments for D"""

    take: int
    skip: int
    order_by: Union['ListsOrderByInput', List['ListsOrderByInput']]
    where: 'ListsWhereInput'
    cursor: 'ListsWhereUniqueInput'
    distinct: List['ListsScalarFieldKeys']
    include: 'ListsIncludeFromDRecursive2'


class FindManyListsArgsFromDRecursive2(TypedDict, total=False):
    """Arguments for D"""

    take: int
    skip: int
    order_by: Union['ListsOrderByInput', List['ListsOrderByInput']]
    where: 'ListsWhereInput'
    cursor: 'ListsWhereUniqueInput'
    distinct: List['ListsScalarFieldKeys']


class AIncludeFromD(TypedDict, total=False):
    """Relational arguments for D"""


class AIncludeFromDRecursive1(TypedDict, total=False):
    """Relational arguments for D"""


class AIncludeFromDRecursive2(TypedDict, total=False):
    """Relational arguments for D"""


class AArgsFromD(TypedDict, total=False):
    """Arguments for D"""

    include: 'AIncludeFromDRecursive1'


class AArgsFromDRecursive1(TypedDict, total=False):
    """Arguments for D"""

    include: 'AIncludeFromDRecursive2'


class AArgsFromDRecursive2(TypedDict, total=False):
    """Arguments for D"""


class FindManyAArgsFromD(TypedDict, total=False):
    """Arguments for D"""

    take: int
    skip: int
    order_by: Union['AOrderByInput', List['AOrderByInput']]
    where: 'AWhereInput'
    cursor: 'AWhereUniqueInput'
    distinct: List['AScalarFieldKeys']
    include: 'AIncludeFromDRecursive1'


class FindManyAArgsFromDRecursive1(TypedDict, total=False):
    """Arguments for D"""

    take: int
    skip: int
    order_by: Union['AOrderByInput', List['AOrderByInput']]
    where: 'AWhereInput'
    cursor: 'AWhereUniqueInput'
    distinct: List['AScalarFieldKeys']
    include: 'AIncludeFromDRecursive2'


class FindManyAArgsFromDRecursive2(TypedDict, total=False):
    """Arguments for D"""

    take: int
    skip: int
    order_by: Union['AOrderByInput', List['AOrderByInput']]
    where: 'AWhereInput'
    cursor: 'AWhereUniqueInput'
    distinct: List['AScalarFieldKeys']


class BIncludeFromD(TypedDict, total=False):
    """Relational arguments for D"""


class BIncludeFromDRecursive1(TypedDict, total=False):
    """Relational arguments for D"""


class BIncludeFromDRecursive2(TypedDict, total=False):
    """Relational arguments for D"""


class BArgsFromD(TypedDict, total=False):
    """Arguments for D"""

    include: 'BIncludeFromDRecursive1'


class BArgsFromDRecursive1(TypedDict, total=False):
    """Arguments for D"""

    include: 'BIncludeFromDRecursive2'


class BArgsFromDRecursive2(TypedDict, total=False):
    """Arguments for D"""


class FindManyBArgsFromD(TypedDict, total=False):
    """Arguments for D"""

    take: int
    skip: int
    order_by: Union['BOrderByInput', List['BOrderByInput']]
    where: 'BWhereInput'
    cursor: 'BWhereUniqueInput'
    distinct: List['BScalarFieldKeys']
    include: 'BIncludeFromDRecursive1'


class FindManyBArgsFromDRecursive1(TypedDict, total=False):
    """Arguments for D"""

    take: int
    skip: int
    order_by: Union['BOrderByInput', List['BOrderByInput']]
    where: 'BWhereInput'
    cursor: 'BWhereUniqueInput'
    distinct: List['BScalarFieldKeys']
    include: 'BIncludeFromDRecursive2'


class FindManyBArgsFromDRecursive2(TypedDict, total=False):
    """Arguments for D"""

    take: int
    skip: int
    order_by: Union['BOrderByInput', List['BOrderByInput']]
    where: 'BWhereInput'
    cursor: 'BWhereUniqueInput'
    distinct: List['BScalarFieldKeys']


class CIncludeFromD(TypedDict, total=False):
    """Relational arguments for D"""


class CIncludeFromDRecursive1(TypedDict, total=False):
    """Relational arguments for D"""


class CIncludeFromDRecursive2(TypedDict, total=False):
    """Relational arguments for D"""


class CArgsFromD(TypedDict, total=False):
    """Arguments for D"""

    include: 'CIncludeFromDRecursive1'


class CArgsFromDRecursive1(TypedDict, total=False):
    """Arguments for D"""

    include: 'CIncludeFromDRecursive2'


class CArgsFromDRecursive2(TypedDict, total=False):
    """Arguments for D"""


class FindManyCArgsFromD(TypedDict, total=False):
    """Arguments for D"""

    take: int
    skip: int
    order_by: Union['COrderByInput', List['COrderByInput']]
    where: 'CWhereInput'
    cursor: 'CWhereUniqueInput'
    distinct: List['CScalarFieldKeys']
    include: 'CIncludeFromDRecursive1'


class FindManyCArgsFromDRecursive1(TypedDict, total=False):
    """Arguments for D"""

    take: int
    skip: int
    order_by: Union['COrderByInput', List['COrderByInput']]
    where: 'CWhereInput'
    cursor: 'CWhereUniqueInput'
    distinct: List['CScalarFieldKeys']
    include: 'CIncludeFromDRecursive2'


class FindManyCArgsFromDRecursive2(TypedDict, total=False):
    """Arguments for D"""

    take: int
    skip: int
    order_by: Union['COrderByInput', List['COrderByInput']]
    where: 'CWhereInput'
    cursor: 'CWhereUniqueInput'
    distinct: List['CScalarFieldKeys']


class DIncludeFromD(TypedDict, total=False):
    """Relational arguments for D"""


class DIncludeFromDRecursive1(TypedDict, total=False):
    """Relational arguments for D"""


class DIncludeFromDRecursive2(TypedDict, total=False):
    """Relational arguments for D"""


class DArgsFromD(TypedDict, total=False):
    """Arguments for D"""

    include: 'DIncludeFromDRecursive1'


class DArgsFromDRecursive1(TypedDict, total=False):
    """Arguments for D"""

    include: 'DIncludeFromDRecursive2'


class DArgsFromDRecursive2(TypedDict, total=False):
    """Arguments for D"""


class FindManyDArgsFromD(TypedDict, total=False):
    """Arguments for D"""

    take: int
    skip: int
    order_by: Union['DOrderByInput', List['DOrderByInput']]
    where: 'DWhereInput'
    cursor: 'DWhereUniqueInput'
    distinct: List['DScalarFieldKeys']
    include: 'DIncludeFromDRecursive1'


class FindManyDArgsFromDRecursive1(TypedDict, total=False):
    """Arguments for D"""

    take: int
    skip: int
    order_by: Union['DOrderByInput', List['DOrderByInput']]
    where: 'DWhereInput'
    cursor: 'DWhereUniqueInput'
    distinct: List['DScalarFieldKeys']
    include: 'DIncludeFromDRecursive2'


class FindManyDArgsFromDRecursive2(TypedDict, total=False):
    """Arguments for D"""

    take: int
    skip: int
    order_by: Union['DOrderByInput', List['DOrderByInput']]
    where: 'DWhereInput'
    cursor: 'DWhereUniqueInput'
    distinct: List['DScalarFieldKeys']


class EIncludeFromD(TypedDict, total=False):
    """Relational arguments for D"""


class EIncludeFromDRecursive1(TypedDict, total=False):
    """Relational arguments for D"""


class EIncludeFromDRecursive2(TypedDict, total=False):
    """Relational arguments for D"""


class EArgsFromD(TypedDict, total=False):
    """Arguments for D"""

    include: 'EIncludeFromDRecursive1'


class EArgsFromDRecursive1(TypedDict, total=False):
    """Arguments for D"""

    include: 'EIncludeFromDRecursive2'


class EArgsFromDRecursive2(TypedDict, total=False):
    """Arguments for D"""


class FindManyEArgsFromD(TypedDict, total=False):
    """Arguments for D"""

    take: int
    skip: int
    order_by: Union['EOrderByInput', List['EOrderByInput']]
    where: 'EWhereInput'
    cursor: 'EWhereUniqueInput'
    distinct: List['EScalarFieldKeys']
    include: 'EIncludeFromDRecursive1'


class FindManyEArgsFromDRecursive1(TypedDict, total=False):
    """Arguments for D"""

    take: int
    skip: int
    order_by: Union['EOrderByInput', List['EOrderByInput']]
    where: 'EWhereInput'
    cursor: 'EWhereUniqueInput'
    distinct: List['EScalarFieldKeys']
    include: 'EIncludeFromDRecursive2'


class FindManyEArgsFromDRecursive2(TypedDict, total=False):
    """Arguments for D"""

    take: int
    skip: int
    order_by: Union['EOrderByInput', List['EOrderByInput']]
    where: 'EWhereInput'
    cursor: 'EWhereUniqueInput'
    distinct: List['EScalarFieldKeys']


FindManyDArgs = FindManyDArgsFromD
FindFirstDArgs = FindManyDArgsFromD


class DWhereInput(TypedDict, total=False):
    """D arguments for searching"""

    id: Union[_str, 'types.StringFilter']
    bool: Union[_bool, 'types.BooleanFilter']
    xml: Union[_str, 'types.StringFilter']
    json_: Union['fields.Json', 'types.JsonFilter']
    jsonb: Union['fields.Json', 'types.JsonFilter']
    binary: Union['fields.Base64', 'types.BytesFilter']

    # should be noted that AND and NOT should be Union['DWhereInputRecursive1', List['DWhereInputRecursive1']]
    # but this causes mypy to hang :/
    AND: List['DWhereInputRecursive1']
    OR: List['DWhereInputRecursive1']
    NOT: List['DWhereInputRecursive1']


class DWhereInputRecursive1(TypedDict, total=False):
    """D arguments for searching"""

    id: Union[_str, 'types.StringFilter']
    bool: Union[_bool, 'types.BooleanFilter']
    xml: Union[_str, 'types.StringFilter']
    json_: Union['fields.Json', 'types.JsonFilter']
    jsonb: Union['fields.Json', 'types.JsonFilter']
    binary: Union['fields.Base64', 'types.BytesFilter']

    # should be noted that AND and NOT should be Union['DWhereInputRecursive2', List['DWhereInputRecursive2']]
    # but this causes mypy to hang :/
    AND: List['DWhereInputRecursive2']
    OR: List['DWhereInputRecursive2']
    NOT: List['DWhereInputRecursive2']


class DWhereInputRecursive2(TypedDict, total=False):
    """D arguments for searching"""

    id: Union[_str, 'types.StringFilter']
    bool: Union[_bool, 'types.BooleanFilter']
    xml: Union[_str, 'types.StringFilter']
    json_: Union['fields.Json', 'types.JsonFilter']
    jsonb: Union['fields.Json', 'types.JsonFilter']
    binary: Union['fields.Base64', 'types.BytesFilter']


# aggregate D types


class DScalarWhereWithAggregatesInput(TypedDict, total=False):
    """D arguments for searching"""

    id: Union[_str, 'types.StringWithAggregatesFilter']
    bool: Union[_bool, 'types.BooleanWithAggregatesFilter']
    xml: Union[_str, 'types.StringWithAggregatesFilter']
    json_: Union['fields.Json', 'types.JsonWithAggregatesFilter']
    jsonb: Union['fields.Json', 'types.JsonWithAggregatesFilter']
    binary: Union['fields.Base64', 'types.BytesWithAggregatesFilter']

    AND: List['DScalarWhereWithAggregatesInputRecursive1']
    OR: List['DScalarWhereWithAggregatesInputRecursive1']
    NOT: List['DScalarWhereWithAggregatesInputRecursive1']


class DScalarWhereWithAggregatesInputRecursive1(TypedDict, total=False):
    """D arguments for searching"""

    id: Union[_str, 'types.StringWithAggregatesFilter']
    bool: Union[_bool, 'types.BooleanWithAggregatesFilter']
    xml: Union[_str, 'types.StringWithAggregatesFilter']
    json_: Union['fields.Json', 'types.JsonWithAggregatesFilter']
    jsonb: Union['fields.Json', 'types.JsonWithAggregatesFilter']
    binary: Union['fields.Base64', 'types.BytesWithAggregatesFilter']

    AND: List['DScalarWhereWithAggregatesInputRecursive2']
    OR: List['DScalarWhereWithAggregatesInputRecursive2']
    NOT: List['DScalarWhereWithAggregatesInputRecursive2']


class DScalarWhereWithAggregatesInputRecursive2(TypedDict, total=False):
    """D arguments for searching"""

    id: Union[_str, 'types.StringWithAggregatesFilter']
    bool: Union[_bool, 'types.BooleanWithAggregatesFilter']
    xml: Union[_str, 'types.StringWithAggregatesFilter']
    json_: Union['fields.Json', 'types.JsonWithAggregatesFilter']
    jsonb: Union['fields.Json', 'types.JsonWithAggregatesFilter']
    binary: Union['fields.Base64', 'types.BytesWithAggregatesFilter']


class DGroupByOutput(TypedDict, total=False):
    id: _str
    bool: _bool
    xml: _str
    json_: 'fields.Json'
    jsonb: 'fields.Json'
    binary: 'fields.Base64'
    _sum: 'DSumAggregateOutput'
    _avg: 'DAvgAggregateOutput'
    _min: 'DMinAggregateOutput'
    _max: 'DMaxAggregateOutput'
    _count: 'DCountAggregateOutput'


class DAvgAggregateOutput(TypedDict, total=False):
    """D output for aggregating averages"""


class DSumAggregateOutput(TypedDict, total=False):
    """D output for aggregating sums"""


class DScalarAggregateOutput(TypedDict, total=False):
    """D output including scalar fields"""

    id: _str
    bool: _bool
    xml: _str
    json_: 'fields.Json'
    jsonb: 'fields.Json'
    binary: 'fields.Base64'


DMinAggregateOutput = DScalarAggregateOutput
DMaxAggregateOutput = DScalarAggregateOutput


class DMaxAggregateInput(TypedDict, total=False):
    """D input for aggregating by max"""

    id: bool
    bool: bool
    xml: bool
    json_: bool
    jsonb: bool
    binary: bool


class DMinAggregateInput(TypedDict, total=False):
    """D input for aggregating by min"""

    id: bool
    bool: bool
    xml: bool
    json_: bool
    jsonb: bool
    binary: bool


class DNumberAggregateInput(TypedDict, total=False):
    """D input for aggregating numbers"""


DAvgAggregateInput = DNumberAggregateInput
DSumAggregateInput = DNumberAggregateInput


DCountAggregateInput = TypedDict(
    'DCountAggregateInput',
    {
        'id': bool,
        'bool': bool,
        'xml': bool,
        'json_': bool,
        'jsonb': bool,
        'binary': bool,
        '_all': bool,
    },
    total=False,
)

DCountAggregateOutput = TypedDict(
    'DCountAggregateOutput',
    {
        'id': int,
        'bool': int,
        'xml': int,
        'json_': int,
        'jsonb': int,
        'binary': int,
        '_all': int,
    },
    total=False,
)


DKeys = Literal[
    'id',
    'bool',
    'xml',
    'json_',
    'jsonb',
    'binary',
]
DScalarFieldKeys = Literal[
    'id',
    'bool',
    'xml',
    'json_',
    'jsonb',
    'binary',
]
DScalarFieldKeysT = TypeVar('DScalarFieldKeysT', bound=DScalarFieldKeys)

DRelationalFieldKeys = _NoneType

# Cross-import related model types for resolution of forward references
from .a import (
    AWhereInput,
    AOrderByInput,
    AScalarFieldKeys,
    AWhereUniqueInput,
)
from .b import (
    BWhereInput,
    BOrderByInput,
    BScalarFieldKeys,
    BWhereUniqueInput,
)
from .c import (
    CWhereInput,
    COrderByInput,
    CScalarFieldKeys,
    CWhereUniqueInput,
)
from .e import (
    EWhereInput,
    EOrderByInput,
    EScalarFieldKeys,
    EWhereUniqueInput,
)
from .m import (
    MWhereInput,
    MOrderByInput,
    MScalarFieldKeys,
    MWhereUniqueInput,
)
from .n import (
    NWhereInput,
    NOrderByInput,
    NScalarFieldKeys,
    NWhereUniqueInput,
)
from .post import (
    PostWhereInput,
    PostOrderByInput,
    PostScalarFieldKeys,
    PostWhereUniqueInput,
)
from .user import (
    UserWhereInput,
    UserOrderByInput,
    UserScalarFieldKeys,
    UserWhereUniqueInput,
)
from .lists import (
    ListsWhereInput,
    ListsOrderByInput,
    ListsScalarFieldKeys,
    ListsWhereUniqueInput,
)
from .oneoptional import (
    OneOptionalWhereInput,
    OneOptionalOrderByInput,
    OneOptionalScalarFieldKeys,
    OneOptionalWhereUniqueInput,
)
from .manyrequired import (
    ManyRequiredWhereInput,
    ManyRequiredOrderByInput,
    ManyRequiredScalarFieldKeys,
    ManyRequiredWhereUniqueInput,
)

'''