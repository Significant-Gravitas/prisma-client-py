'''
# -*- coding: utf-8 -*-
# code generated by Prisma. DO NOT EDIT.
# pyright: reportUnusedImport=false
# fmt: off

# global imports for type checking
from typing import (
    TYPE_CHECKING,
    Any,
    Dict,
    List,
    Union,
    Literal,
    TypeVar,
    Optional,
    TypedDict,
)
from builtins import int as _int, str as _str, bool as _bool, float as _float

LiteralString = str
# -- template types/_model.py.jinja --
# Types for model: User

from .atomic import *  # noqa: TID251
from .filters import *  # noqa: TID251
from .list_filters import *  # noqa: TID251

# Cross-import related model types for type checker resolution
if TYPE_CHECKING:
    from .a import (  # noqa: TID251
        AWhereInput,
        AOrderByInput,
        AScalarFieldKeys,
        AWhereUniqueInput,
    )
    from .b import (  # noqa: TID251
        BWhereInput,
        BOrderByInput,
        BScalarFieldKeys,
        BWhereUniqueInput,
    )
    from .c import (  # noqa: TID251
        CWhereInput,
        COrderByInput,
        CScalarFieldKeys,
        CWhereUniqueInput,
    )
    from .d import (  # noqa: TID251
        DWhereInput,
        DOrderByInput,
        DScalarFieldKeys,
        DWhereUniqueInput,
    )
    from .e import (  # noqa: TID251
        EWhereInput,
        EOrderByInput,
        EScalarFieldKeys,
        EWhereUniqueInput,
    )
    from .m import (  # noqa: TID251
        MWhereInput,
        MOrderByInput,
        MScalarFieldKeys,
        MWhereUniqueInput,
    )
    from .n import (  # noqa: TID251
        NWhereInput,
        NOrderByInput,
        NScalarFieldKeys,
        NWhereUniqueInput,
    )
    from .post import (  # noqa: TID251
        PostWhereInput,
        PostOrderByInput,
        PostScalarFieldKeys,
        PostWhereUniqueInput,
        PostListRelationFilter,
        PostUpdateManyWithoutRelationsInput,
        PostCreateManyNestedWithoutRelationsInput,
    )
    from .lists import (  # noqa: TID251
        ListsWhereInput,
        ListsOrderByInput,
        ListsScalarFieldKeys,
        ListsWhereUniqueInput,
    )
    from .oneoptional import (  # noqa: TID251
        OneOptionalWhereInput,
        OneOptionalOrderByInput,
        OneOptionalScalarFieldKeys,
        OneOptionalWhereUniqueInput,
    )
    from .manyrequired import (  # noqa: TID251
        ManyRequiredWhereInput,
        ManyRequiredOrderByInput,
        ManyRequiredScalarFieldKeys,
        ManyRequiredWhereUniqueInput,
    )





# User types

class UserOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the User create method"""
    id: _int
    optional_int: Optional[_int]
    optional_float: Optional[_float]
    optional_string: Optional[_str]
    optional_enum: Optional['enums.ABeautifulEnum']
    optional_boolean: Optional[_bool]
    posts: 'PostCreateManyNestedWithoutRelationsInput'


class UserCreateInput(UserOptionalCreateInput):
    """Required arguments to the User create method"""
    email: _str
    int: _int
    float: _float
    string: _str
    enum: 'enums.ABeautifulEnum'
    boolean: _bool


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class UserOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the User create method, without relations"""
    id: _int
    optional_int: Optional[_int]
    optional_float: Optional[_float]
    optional_string: Optional[_str]
    optional_enum: Optional['enums.ABeautifulEnum']
    optional_boolean: Optional[_bool]


class UserCreateWithoutRelationsInput(UserOptionalCreateWithoutRelationsInput):
    """Required arguments to the User create method, without relations"""
    email: _str
    int: _int
    float: _float
    string: _str
    enum: 'enums.ABeautifulEnum'
    boolean: _bool

class UserConnectOrCreateWithoutRelationsInput(TypedDict):
    create: 'UserCreateWithoutRelationsInput'
    where: 'UserWhereUniqueInput'

class UserCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'UserCreateWithoutRelationsInput'
    connect: 'UserWhereUniqueInput'
    connect_or_create: 'UserConnectOrCreateWithoutRelationsInput'


class UserCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['UserCreateWithoutRelationsInput', List['UserCreateWithoutRelationsInput']]
    connect: Union['UserWhereUniqueInput', List['UserWhereUniqueInput']]
    connect_or_create: Union['UserConnectOrCreateWithoutRelationsInput', List['UserConnectOrCreateWithoutRelationsInput']]

_UserWhereUnique_id_Input = TypedDict(
    '_UserWhereUnique_id_Input',
    {
        'id': '_int',
    },
    total=True
)

_UserWhereUnique_email_Input = TypedDict(
    '_UserWhereUnique_email_Input',
    {
        'email': '_str',
    },
    total=True
)

UserWhereUniqueInput = Union[
    '_UserWhereUnique_id_Input',
    '_UserWhereUnique_email_Input',
]


class UserUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: Union[AtomicIntInput, _int]
    email: _str
    int: Union[AtomicIntInput, _int]
    optional_int: Optional[Union[AtomicIntInput, _int]]
    float: Union[AtomicFloatInput, _float]
    optional_float: Optional[Union[AtomicFloatInput, _float]]
    string: _str
    optional_string: Optional[_str]
    enum: 'enums.ABeautifulEnum'
    optional_enum: Optional['enums.ABeautifulEnum']
    boolean: _bool
    optional_boolean: Optional[_bool]
    posts: 'PostUpdateManyWithoutRelationsInput'


class UserUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: Union[AtomicIntInput, _int]
    email: _str
    int: Union[AtomicIntInput, _int]
    optional_int: Optional[Union[AtomicIntInput, _int]]
    float: Union[AtomicFloatInput, _float]
    optional_float: Optional[Union[AtomicFloatInput, _float]]
    string: _str
    optional_string: Optional[_str]
    enum: 'enums.ABeautifulEnum'
    optional_enum: Optional['enums.ABeautifulEnum']
    boolean: _bool
    optional_boolean: Optional[_bool]


class UserUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['UserCreateWithoutRelationsInput']
    connect: List['UserWhereUniqueInput']
    connect_or_create: List['UserConnectOrCreateWithoutRelationsInput']
    set: List['UserWhereUniqueInput']
    disconnect: List['UserWhereUniqueInput']
    delete: List['UserWhereUniqueInput']

    # TODO
    # update: List['UserUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['UserUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['UserScalarWhereInput']
    # upsert: List['UserUpserteWithWhereUniqueWithoutRelationsInput']


class UserUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'UserCreateWithoutRelationsInput'
    connect: 'UserWhereUniqueInput'
    connect_or_create: 'UserConnectOrCreateWithoutRelationsInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'UserUpdateInput'
    # upsert: 'UserUpsertWithoutRelationsInput'


class UserUpsertInput(TypedDict):
    create: 'UserCreateInput'
    update: 'UserUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_User_id_OrderByInput = TypedDict(
    '_User_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_User_email_OrderByInput = TypedDict(
    '_User_email_OrderByInput',
    {
        'email': 'SortOrder',
    },
    total=True
)

_User_int_OrderByInput = TypedDict(
    '_User_int_OrderByInput',
    {
        'int': 'SortOrder',
    },
    total=True
)

_User_optional_int_OrderByInput = TypedDict(
    '_User_optional_int_OrderByInput',
    {
        'optional_int': 'SortOrder',
    },
    total=True
)

_User_float_OrderByInput = TypedDict(
    '_User_float_OrderByInput',
    {
        'float': 'SortOrder',
    },
    total=True
)

_User_optional_float_OrderByInput = TypedDict(
    '_User_optional_float_OrderByInput',
    {
        'optional_float': 'SortOrder',
    },
    total=True
)

_User_string_OrderByInput = TypedDict(
    '_User_string_OrderByInput',
    {
        'string': 'SortOrder',
    },
    total=True
)

_User_optional_string_OrderByInput = TypedDict(
    '_User_optional_string_OrderByInput',
    {
        'optional_string': 'SortOrder',
    },
    total=True
)

_User_enum_OrderByInput = TypedDict(
    '_User_enum_OrderByInput',
    {
        'enum': 'SortOrder',
    },
    total=True
)

_User_optional_enum_OrderByInput = TypedDict(
    '_User_optional_enum_OrderByInput',
    {
        'optional_enum': 'SortOrder',
    },
    total=True
)

_User_boolean_OrderByInput = TypedDict(
    '_User_boolean_OrderByInput',
    {
        'boolean': 'SortOrder',
    },
    total=True
)

_User_optional_boolean_OrderByInput = TypedDict(
    '_User_optional_boolean_OrderByInput',
    {
        'optional_boolean': 'SortOrder',
    },
    total=True
)

_User_RelevanceInner = TypedDict(
    '_User_RelevanceInner',
    {
        'fields': 'List[UserScalarFieldKeys]',
        'search': 'str',
        'sort': 'SortOrder',
    },
    total=True
)

_User_RelevanceOrderByInput = TypedDict(
    '_User_RelevanceOrderByInput',
    {
        '_relevance': '_User_RelevanceInner',
    },
    total=True
)

UserOrderByInput = Union[
    '_User_id_OrderByInput',
    '_User_email_OrderByInput',
    '_User_int_OrderByInput',
    '_User_optional_int_OrderByInput',
    '_User_float_OrderByInput',
    '_User_optional_float_OrderByInput',
    '_User_string_OrderByInput',
    '_User_optional_string_OrderByInput',
    '_User_enum_OrderByInput',
    '_User_optional_enum_OrderByInput',
    '_User_boolean_OrderByInput',
    '_User_optional_boolean_OrderByInput',
    '_User_RelevanceOrderByInput',
]



# recursive User types
# TODO: cleanup these types


# Dict[str, Any] is a mypy limitation
# see https://github.com/RobertCraigie/prisma-client-py/issues/45
# switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/stable/reference/limitations/

UserRelationFilter = TypedDict(
    'UserRelationFilter',
    {
        'is': 'Dict[str, Any]',
        'is_not': 'Dict[str, Any]',
    },
    total=False,
)


class UserListRelationFilter(TypedDict, total=False):
    some: 'Dict[str, Any]'
    none: 'Dict[str, Any]'
    every: 'Dict[str, Any]'


class UserInclude(TypedDict, total=False):
    """User relational arguments"""
    posts: Union[bool, 'FindManyPostArgsFromUser']


    

class PostIncludeFromUser(TypedDict, total=False):
    """Relational arguments for User"""
    author: Union[bool, 'UserArgsFromUserRecursive1']


class PostIncludeFromUserRecursive1(TypedDict, total=False):
    """Relational arguments for User"""
    author: Union[bool, 'UserArgsFromUserRecursive2']


class PostIncludeFromUserRecursive2(TypedDict, total=False):
    """Relational arguments for User"""

    

class PostArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    include: 'PostIncludeFromUserRecursive1'


class PostArgsFromUserRecursive1(TypedDict, total=False):
    """Arguments for User"""
    include: 'PostIncludeFromUserRecursive2'


class PostArgsFromUserRecursive2(TypedDict, total=False):
    """Arguments for User"""
    
    

class FindManyPostArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['PostOrderByInput', List['PostOrderByInput']]
    where: 'PostWhereInput'
    cursor: 'PostWhereUniqueInput'
    distinct: List['PostScalarFieldKeys']
    include: 'PostIncludeFromUserRecursive1'


class FindManyPostArgsFromUserRecursive1(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['PostOrderByInput', List['PostOrderByInput']]
    where: 'PostWhereInput'
    cursor: 'PostWhereUniqueInput'
    distinct: List['PostScalarFieldKeys']
    include: 'PostIncludeFromUserRecursive2'


class FindManyPostArgsFromUserRecursive2(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['PostOrderByInput', List['PostOrderByInput']]
    where: 'PostWhereInput'
    cursor: 'PostWhereUniqueInput'
    distinct: List['PostScalarFieldKeys']
        

class UserIncludeFromUser(TypedDict, total=False):
    """Relational arguments for User"""
    posts: Union[bool, 'FindManyPostArgsFromUserRecursive1']


class UserIncludeFromUserRecursive1(TypedDict, total=False):
    """Relational arguments for User"""
    posts: Union[bool, 'FindManyPostArgsFromUserRecursive2']


class UserIncludeFromUserRecursive2(TypedDict, total=False):
    """Relational arguments for User"""

    

class UserArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    include: 'UserIncludeFromUserRecursive1'


class UserArgsFromUserRecursive1(TypedDict, total=False):
    """Arguments for User"""
    include: 'UserIncludeFromUserRecursive2'


class UserArgsFromUserRecursive2(TypedDict, total=False):
    """Arguments for User"""
    
    

class FindManyUserArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive1'


class FindManyUserArgsFromUserRecursive1(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive2'


class FindManyUserArgsFromUserRecursive2(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
        

class MIncludeFromUser(TypedDict, total=False):
    """Relational arguments for User"""
    n: Union[bool, 'FindManyNArgsFromUserRecursive1']


class MIncludeFromUserRecursive1(TypedDict, total=False):
    """Relational arguments for User"""
    n: Union[bool, 'FindManyNArgsFromUserRecursive2']


class MIncludeFromUserRecursive2(TypedDict, total=False):
    """Relational arguments for User"""

    

class MArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    include: 'MIncludeFromUserRecursive1'


class MArgsFromUserRecursive1(TypedDict, total=False):
    """Arguments for User"""
    include: 'MIncludeFromUserRecursive2'


class MArgsFromUserRecursive2(TypedDict, total=False):
    """Arguments for User"""
    
    

class FindManyMArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['MOrderByInput', List['MOrderByInput']]
    where: 'MWhereInput'
    cursor: 'MWhereUniqueInput'
    distinct: List['MScalarFieldKeys']
    include: 'MIncludeFromUserRecursive1'


class FindManyMArgsFromUserRecursive1(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['MOrderByInput', List['MOrderByInput']]
    where: 'MWhereInput'
    cursor: 'MWhereUniqueInput'
    distinct: List['MScalarFieldKeys']
    include: 'MIncludeFromUserRecursive2'


class FindManyMArgsFromUserRecursive2(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['MOrderByInput', List['MOrderByInput']]
    where: 'MWhereInput'
    cursor: 'MWhereUniqueInput'
    distinct: List['MScalarFieldKeys']
        

class NIncludeFromUser(TypedDict, total=False):
    """Relational arguments for User"""
    m: Union[bool, 'FindManyMArgsFromUserRecursive1']


class NIncludeFromUserRecursive1(TypedDict, total=False):
    """Relational arguments for User"""
    m: Union[bool, 'FindManyMArgsFromUserRecursive2']


class NIncludeFromUserRecursive2(TypedDict, total=False):
    """Relational arguments for User"""

    

class NArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    include: 'NIncludeFromUserRecursive1'


class NArgsFromUserRecursive1(TypedDict, total=False):
    """Arguments for User"""
    include: 'NIncludeFromUserRecursive2'


class NArgsFromUserRecursive2(TypedDict, total=False):
    """Arguments for User"""
    
    

class FindManyNArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['NOrderByInput', List['NOrderByInput']]
    where: 'NWhereInput'
    cursor: 'NWhereUniqueInput'
    distinct: List['NScalarFieldKeys']
    include: 'NIncludeFromUserRecursive1'


class FindManyNArgsFromUserRecursive1(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['NOrderByInput', List['NOrderByInput']]
    where: 'NWhereInput'
    cursor: 'NWhereUniqueInput'
    distinct: List['NScalarFieldKeys']
    include: 'NIncludeFromUserRecursive2'


class FindManyNArgsFromUserRecursive2(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['NOrderByInput', List['NOrderByInput']]
    where: 'NWhereInput'
    cursor: 'NWhereUniqueInput'
    distinct: List['NScalarFieldKeys']
        

class OneOptionalIncludeFromUser(TypedDict, total=False):
    """Relational arguments for User"""
    many: Union[bool, 'FindManyManyRequiredArgsFromUserRecursive1']


class OneOptionalIncludeFromUserRecursive1(TypedDict, total=False):
    """Relational arguments for User"""
    many: Union[bool, 'FindManyManyRequiredArgsFromUserRecursive2']


class OneOptionalIncludeFromUserRecursive2(TypedDict, total=False):
    """Relational arguments for User"""

    

class OneOptionalArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    include: 'OneOptionalIncludeFromUserRecursive1'


class OneOptionalArgsFromUserRecursive1(TypedDict, total=False):
    """Arguments for User"""
    include: 'OneOptionalIncludeFromUserRecursive2'


class OneOptionalArgsFromUserRecursive2(TypedDict, total=False):
    """Arguments for User"""
    
    

class FindManyOneOptionalArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
    where: 'OneOptionalWhereInput'
    cursor: 'OneOptionalWhereUniqueInput'
    distinct: List['OneOptionalScalarFieldKeys']
    include: 'OneOptionalIncludeFromUserRecursive1'


class FindManyOneOptionalArgsFromUserRecursive1(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
    where: 'OneOptionalWhereInput'
    cursor: 'OneOptionalWhereUniqueInput'
    distinct: List['OneOptionalScalarFieldKeys']
    include: 'OneOptionalIncludeFromUserRecursive2'


class FindManyOneOptionalArgsFromUserRecursive2(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
    where: 'OneOptionalWhereInput'
    cursor: 'OneOptionalWhereUniqueInput'
    distinct: List['OneOptionalScalarFieldKeys']
        

class ManyRequiredIncludeFromUser(TypedDict, total=False):
    """Relational arguments for User"""
    one: Union[bool, 'OneOptionalArgsFromUserRecursive1']


class ManyRequiredIncludeFromUserRecursive1(TypedDict, total=False):
    """Relational arguments for User"""
    one: Union[bool, 'OneOptionalArgsFromUserRecursive2']


class ManyRequiredIncludeFromUserRecursive2(TypedDict, total=False):
    """Relational arguments for User"""

    

class ManyRequiredArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    include: 'ManyRequiredIncludeFromUserRecursive1'


class ManyRequiredArgsFromUserRecursive1(TypedDict, total=False):
    """Arguments for User"""
    include: 'ManyRequiredIncludeFromUserRecursive2'


class ManyRequiredArgsFromUserRecursive2(TypedDict, total=False):
    """Arguments for User"""
    
    

class FindManyManyRequiredArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
    where: 'ManyRequiredWhereInput'
    cursor: 'ManyRequiredWhereUniqueInput'
    distinct: List['ManyRequiredScalarFieldKeys']
    include: 'ManyRequiredIncludeFromUserRecursive1'


class FindManyManyRequiredArgsFromUserRecursive1(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
    where: 'ManyRequiredWhereInput'
    cursor: 'ManyRequiredWhereUniqueInput'
    distinct: List['ManyRequiredScalarFieldKeys']
    include: 'ManyRequiredIncludeFromUserRecursive2'


class FindManyManyRequiredArgsFromUserRecursive2(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
    where: 'ManyRequiredWhereInput'
    cursor: 'ManyRequiredWhereUniqueInput'
    distinct: List['ManyRequiredScalarFieldKeys']
        

class ListsIncludeFromUser(TypedDict, total=False):
    """Relational arguments for User"""


class ListsIncludeFromUserRecursive1(TypedDict, total=False):
    """Relational arguments for User"""


class ListsIncludeFromUserRecursive2(TypedDict, total=False):
    """Relational arguments for User"""

    

class ListsArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    include: 'ListsIncludeFromUserRecursive1'


class ListsArgsFromUserRecursive1(TypedDict, total=False):
    """Arguments for User"""
    include: 'ListsIncludeFromUserRecursive2'


class ListsArgsFromUserRecursive2(TypedDict, total=False):
    """Arguments for User"""
    
    

class FindManyListsArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['ListsOrderByInput', List['ListsOrderByInput']]
    where: 'ListsWhereInput'
    cursor: 'ListsWhereUniqueInput'
    distinct: List['ListsScalarFieldKeys']
    include: 'ListsIncludeFromUserRecursive1'


class FindManyListsArgsFromUserRecursive1(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['ListsOrderByInput', List['ListsOrderByInput']]
    where: 'ListsWhereInput'
    cursor: 'ListsWhereUniqueInput'
    distinct: List['ListsScalarFieldKeys']
    include: 'ListsIncludeFromUserRecursive2'


class FindManyListsArgsFromUserRecursive2(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['ListsOrderByInput', List['ListsOrderByInput']]
    where: 'ListsWhereInput'
    cursor: 'ListsWhereUniqueInput'
    distinct: List['ListsScalarFieldKeys']
        

class AIncludeFromUser(TypedDict, total=False):
    """Relational arguments for User"""


class AIncludeFromUserRecursive1(TypedDict, total=False):
    """Relational arguments for User"""


class AIncludeFromUserRecursive2(TypedDict, total=False):
    """Relational arguments for User"""

    

class AArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    include: 'AIncludeFromUserRecursive1'


class AArgsFromUserRecursive1(TypedDict, total=False):
    """Arguments for User"""
    include: 'AIncludeFromUserRecursive2'


class AArgsFromUserRecursive2(TypedDict, total=False):
    """Arguments for User"""
    
    

class FindManyAArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['AOrderByInput', List['AOrderByInput']]
    where: 'AWhereInput'
    cursor: 'AWhereUniqueInput'
    distinct: List['AScalarFieldKeys']
    include: 'AIncludeFromUserRecursive1'


class FindManyAArgsFromUserRecursive1(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['AOrderByInput', List['AOrderByInput']]
    where: 'AWhereInput'
    cursor: 'AWhereUniqueInput'
    distinct: List['AScalarFieldKeys']
    include: 'AIncludeFromUserRecursive2'


class FindManyAArgsFromUserRecursive2(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['AOrderByInput', List['AOrderByInput']]
    where: 'AWhereInput'
    cursor: 'AWhereUniqueInput'
    distinct: List['AScalarFieldKeys']
        

class BIncludeFromUser(TypedDict, total=False):
    """Relational arguments for User"""


class BIncludeFromUserRecursive1(TypedDict, total=False):
    """Relational arguments for User"""


class BIncludeFromUserRecursive2(TypedDict, total=False):
    """Relational arguments for User"""

    

class BArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    include: 'BIncludeFromUserRecursive1'


class BArgsFromUserRecursive1(TypedDict, total=False):
    """Arguments for User"""
    include: 'BIncludeFromUserRecursive2'


class BArgsFromUserRecursive2(TypedDict, total=False):
    """Arguments for User"""
    
    

class FindManyBArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['BOrderByInput', List['BOrderByInput']]
    where: 'BWhereInput'
    cursor: 'BWhereUniqueInput'
    distinct: List['BScalarFieldKeys']
    include: 'BIncludeFromUserRecursive1'


class FindManyBArgsFromUserRecursive1(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['BOrderByInput', List['BOrderByInput']]
    where: 'BWhereInput'
    cursor: 'BWhereUniqueInput'
    distinct: List['BScalarFieldKeys']
    include: 'BIncludeFromUserRecursive2'


class FindManyBArgsFromUserRecursive2(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['BOrderByInput', List['BOrderByInput']]
    where: 'BWhereInput'
    cursor: 'BWhereUniqueInput'
    distinct: List['BScalarFieldKeys']
        

class CIncludeFromUser(TypedDict, total=False):
    """Relational arguments for User"""


class CIncludeFromUserRecursive1(TypedDict, total=False):
    """Relational arguments for User"""


class CIncludeFromUserRecursive2(TypedDict, total=False):
    """Relational arguments for User"""

    

class CArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    include: 'CIncludeFromUserRecursive1'


class CArgsFromUserRecursive1(TypedDict, total=False):
    """Arguments for User"""
    include: 'CIncludeFromUserRecursive2'


class CArgsFromUserRecursive2(TypedDict, total=False):
    """Arguments for User"""
    
    

class FindManyCArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['COrderByInput', List['COrderByInput']]
    where: 'CWhereInput'
    cursor: 'CWhereUniqueInput'
    distinct: List['CScalarFieldKeys']
    include: 'CIncludeFromUserRecursive1'


class FindManyCArgsFromUserRecursive1(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['COrderByInput', List['COrderByInput']]
    where: 'CWhereInput'
    cursor: 'CWhereUniqueInput'
    distinct: List['CScalarFieldKeys']
    include: 'CIncludeFromUserRecursive2'


class FindManyCArgsFromUserRecursive2(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['COrderByInput', List['COrderByInput']]
    where: 'CWhereInput'
    cursor: 'CWhereUniqueInput'
    distinct: List['CScalarFieldKeys']
        

class DIncludeFromUser(TypedDict, total=False):
    """Relational arguments for User"""


class DIncludeFromUserRecursive1(TypedDict, total=False):
    """Relational arguments for User"""


class DIncludeFromUserRecursive2(TypedDict, total=False):
    """Relational arguments for User"""

    

class DArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    include: 'DIncludeFromUserRecursive1'


class DArgsFromUserRecursive1(TypedDict, total=False):
    """Arguments for User"""
    include: 'DIncludeFromUserRecursive2'


class DArgsFromUserRecursive2(TypedDict, total=False):
    """Arguments for User"""
    
    

class FindManyDArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['DOrderByInput', List['DOrderByInput']]
    where: 'DWhereInput'
    cursor: 'DWhereUniqueInput'
    distinct: List['DScalarFieldKeys']
    include: 'DIncludeFromUserRecursive1'


class FindManyDArgsFromUserRecursive1(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['DOrderByInput', List['DOrderByInput']]
    where: 'DWhereInput'
    cursor: 'DWhereUniqueInput'
    distinct: List['DScalarFieldKeys']
    include: 'DIncludeFromUserRecursive2'


class FindManyDArgsFromUserRecursive2(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['DOrderByInput', List['DOrderByInput']]
    where: 'DWhereInput'
    cursor: 'DWhereUniqueInput'
    distinct: List['DScalarFieldKeys']
        

class EIncludeFromUser(TypedDict, total=False):
    """Relational arguments for User"""


class EIncludeFromUserRecursive1(TypedDict, total=False):
    """Relational arguments for User"""


class EIncludeFromUserRecursive2(TypedDict, total=False):
    """Relational arguments for User"""

    

class EArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    include: 'EIncludeFromUserRecursive1'


class EArgsFromUserRecursive1(TypedDict, total=False):
    """Arguments for User"""
    include: 'EIncludeFromUserRecursive2'


class EArgsFromUserRecursive2(TypedDict, total=False):
    """Arguments for User"""
    
    

class FindManyEArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['EOrderByInput', List['EOrderByInput']]
    where: 'EWhereInput'
    cursor: 'EWhereUniqueInput'
    distinct: List['EScalarFieldKeys']
    include: 'EIncludeFromUserRecursive1'


class FindManyEArgsFromUserRecursive1(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['EOrderByInput', List['EOrderByInput']]
    where: 'EWhereInput'
    cursor: 'EWhereUniqueInput'
    distinct: List['EScalarFieldKeys']
    include: 'EIncludeFromUserRecursive2'


class FindManyEArgsFromUserRecursive2(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['EOrderByInput', List['EOrderByInput']]
    where: 'EWhereInput'
    cursor: 'EWhereUniqueInput'
    distinct: List['EScalarFieldKeys']
    

FindManyUserArgs = FindManyUserArgsFromUser
FindFirstUserArgs = FindManyUserArgsFromUser


    

class UserWhereInput(TypedDict, total=False):
    """User arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    email: Union[_str, 'types.StringFilter']
    int: Union[_int, 'types.IntFilter']
    optional_int: Union[None, _int, 'types.IntFilter']
    float: Union[_float, 'types.FloatFilter']
    optional_float: Union[None, _float, 'types.FloatFilter']
    string: Union[_str, 'types.StringFilter']
    optional_string: Union[None, _str, 'types.StringFilter']
    enum: 'enums.ABeautifulEnum'
    optional_enum: 'enums.ABeautifulEnum'
    boolean: Union[_bool, 'types.BooleanFilter']
    optional_boolean: Union[None, _bool, 'types.BooleanFilter']
    posts: 'PostListRelationFilter'

    # should be noted that AND and NOT should be Union['UserWhereInputRecursive1', List['UserWhereInputRecursive1']]
    # but this causes mypy to hang :/
    AND: List['UserWhereInputRecursive1']
    OR: List['UserWhereInputRecursive1']
    NOT: List['UserWhereInputRecursive1']


class UserWhereInputRecursive1(TypedDict, total=False):
    """User arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    email: Union[_str, 'types.StringFilter']
    int: Union[_int, 'types.IntFilter']
    optional_int: Union[None, _int, 'types.IntFilter']
    float: Union[_float, 'types.FloatFilter']
    optional_float: Union[None, _float, 'types.FloatFilter']
    string: Union[_str, 'types.StringFilter']
    optional_string: Union[None, _str, 'types.StringFilter']
    enum: 'enums.ABeautifulEnum'
    optional_enum: 'enums.ABeautifulEnum'
    boolean: Union[_bool, 'types.BooleanFilter']
    optional_boolean: Union[None, _bool, 'types.BooleanFilter']
    posts: 'PostListRelationFilter'

    # should be noted that AND and NOT should be Union['UserWhereInputRecursive2', List['UserWhereInputRecursive2']]
    # but this causes mypy to hang :/
    AND: List['UserWhereInputRecursive2']
    OR: List['UserWhereInputRecursive2']
    NOT: List['UserWhereInputRecursive2']


class UserWhereInputRecursive2(TypedDict, total=False):
    """User arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    email: Union[_str, 'types.StringFilter']
    int: Union[_int, 'types.IntFilter']
    optional_int: Union[None, _int, 'types.IntFilter']
    float: Union[_float, 'types.FloatFilter']
    optional_float: Union[None, _float, 'types.FloatFilter']
    string: Union[_str, 'types.StringFilter']
    optional_string: Union[None, _str, 'types.StringFilter']
    enum: 'enums.ABeautifulEnum'
    optional_enum: 'enums.ABeautifulEnum'
    boolean: Union[_bool, 'types.BooleanFilter']
    optional_boolean: Union[None, _bool, 'types.BooleanFilter']
    posts: 'PostListRelationFilter'



# aggregate User types


    

class UserScalarWhereWithAggregatesInput(TypedDict, total=False):
    """User arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    email: Union[_str, 'types.StringWithAggregatesFilter']
    int: Union[_int, 'types.IntWithAggregatesFilter']
    optional_int: Union[_int, 'types.IntWithAggregatesFilter']
    float: Union[_float, 'types.FloatWithAggregatesFilter']
    optional_float: Union[_float, 'types.FloatWithAggregatesFilter']
    string: Union[_str, 'types.StringWithAggregatesFilter']
    optional_string: Union[_str, 'types.StringWithAggregatesFilter']
    enum: 'enums.ABeautifulEnum'
    optional_enum: 'enums.ABeautifulEnum'
    boolean: Union[_bool, 'types.BooleanWithAggregatesFilter']
    optional_boolean: Union[_bool, 'types.BooleanWithAggregatesFilter']

    AND: List['UserScalarWhereWithAggregatesInputRecursive1']
    OR: List['UserScalarWhereWithAggregatesInputRecursive1']
    NOT: List['UserScalarWhereWithAggregatesInputRecursive1']


class UserScalarWhereWithAggregatesInputRecursive1(TypedDict, total=False):
    """User arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    email: Union[_str, 'types.StringWithAggregatesFilter']
    int: Union[_int, 'types.IntWithAggregatesFilter']
    optional_int: Union[_int, 'types.IntWithAggregatesFilter']
    float: Union[_float, 'types.FloatWithAggregatesFilter']
    optional_float: Union[_float, 'types.FloatWithAggregatesFilter']
    string: Union[_str, 'types.StringWithAggregatesFilter']
    optional_string: Union[_str, 'types.StringWithAggregatesFilter']
    enum: 'enums.ABeautifulEnum'
    optional_enum: 'enums.ABeautifulEnum'
    boolean: Union[_bool, 'types.BooleanWithAggregatesFilter']
    optional_boolean: Union[_bool, 'types.BooleanWithAggregatesFilter']

    AND: List['UserScalarWhereWithAggregatesInputRecursive2']
    OR: List['UserScalarWhereWithAggregatesInputRecursive2']
    NOT: List['UserScalarWhereWithAggregatesInputRecursive2']


class UserScalarWhereWithAggregatesInputRecursive2(TypedDict, total=False):
    """User arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    email: Union[_str, 'types.StringWithAggregatesFilter']
    int: Union[_int, 'types.IntWithAggregatesFilter']
    optional_int: Union[_int, 'types.IntWithAggregatesFilter']
    float: Union[_float, 'types.FloatWithAggregatesFilter']
    optional_float: Union[_float, 'types.FloatWithAggregatesFilter']
    string: Union[_str, 'types.StringWithAggregatesFilter']
    optional_string: Union[_str, 'types.StringWithAggregatesFilter']
    enum: 'enums.ABeautifulEnum'
    optional_enum: 'enums.ABeautifulEnum'
    boolean: Union[_bool, 'types.BooleanWithAggregatesFilter']
    optional_boolean: Union[_bool, 'types.BooleanWithAggregatesFilter']



class UserGroupByOutput(TypedDict, total=False):
    id: _int
    email: _str
    int: _int
    optional_int: _int
    float: _float
    optional_float: _float
    string: _str
    optional_string: _str
    enum: 'enums.ABeautifulEnum'
    optional_enum: 'enums.ABeautifulEnum'
    boolean: _bool
    optional_boolean: _bool
    _sum: 'UserSumAggregateOutput'
    _avg: 'UserAvgAggregateOutput'
    _min: 'UserMinAggregateOutput'
    _max: 'UserMaxAggregateOutput'
    _count: 'UserCountAggregateOutput'


class UserAvgAggregateOutput(TypedDict, total=False):
    """User output for aggregating averages"""
    id: float
    int: float
    optional_int: float
    float: float
    optional_float: float


class UserSumAggregateOutput(TypedDict, total=False):
    """User output for aggregating sums"""
    id: _int
    int: _int
    optional_int: _int
    float: _float
    optional_float: _float


class UserScalarAggregateOutput(TypedDict, total=False):
    """User output including scalar fields"""
    id: _int
    email: _str
    int: _int
    optional_int: _int
    float: _float
    optional_float: _float
    string: _str
    optional_string: _str
    enum: 'enums.ABeautifulEnum'
    optional_enum: 'enums.ABeautifulEnum'
    boolean: _bool
    optional_boolean: _bool


UserMinAggregateOutput = UserScalarAggregateOutput
UserMaxAggregateOutput = UserScalarAggregateOutput


class UserMaxAggregateInput(TypedDict, total=False):
    """User input for aggregating by max"""
    id: bool
    email: bool
    int: bool
    optional_int: bool
    float: bool
    optional_float: bool
    string: bool
    optional_string: bool
    enum: bool
    optional_enum: bool
    boolean: bool
    optional_boolean: bool


class UserMinAggregateInput(TypedDict, total=False):
    """User input for aggregating by min"""
    id: bool
    email: bool
    int: bool
    optional_int: bool
    float: bool
    optional_float: bool
    string: bool
    optional_string: bool
    enum: bool
    optional_enum: bool
    boolean: bool
    optional_boolean: bool


class UserNumberAggregateInput(TypedDict, total=False):
    """User input for aggregating numbers"""
    id: bool
    int: bool
    optional_int: bool
    float: bool
    optional_float: bool


UserAvgAggregateInput = UserNumberAggregateInput
UserSumAggregateInput = UserNumberAggregateInput


UserCountAggregateInput = TypedDict(
    'UserCountAggregateInput',
    {
        'id': bool,
        'email': bool,
        'int': bool,
        'optional_int': bool,
        'float': bool,
        'optional_float': bool,
        'string': bool,
        'optional_string': bool,
        'enum': bool,
        'optional_enum': bool,
        'boolean': bool,
        'optional_boolean': bool,
        '_all': bool,
    },
    total=False,
)

UserCountAggregateOutput = TypedDict(
    'UserCountAggregateOutput',
    {
        'id': int,
        'email': int,
        'int': int,
        'optional_int': int,
        'float': int,
        'optional_float': int,
        'string': int,
        'optional_string': int,
        'enum': int,
        'optional_enum': int,
        'boolean': int,
        'optional_boolean': int,
        '_all': int,
    },
    total=False,
)


UserKeys = Literal[
    'id',
    'email',
    'int',
    'optional_int',
    'float',
    'optional_float',
    'string',
    'optional_string',
    'enum',
    'optional_enum',
    'boolean',
    'optional_boolean',
    'posts',
]
UserScalarFieldKeys = Literal[
    'id',
    'email',
    'int',
    'optional_int',
    'float',
    'optional_float',
    'string',
    'optional_string',
    'enum',
    'optional_enum',
    'boolean',
    'optional_boolean',
]
UserScalarFieldKeysT = TypeVar('UserScalarFieldKeysT', bound=UserScalarFieldKeys)

UserRelationalFieldKeys = Literal[
        'posts',
    ]


# we have to import ourselves as forward references may use 'types.XFilter' syntax
from .. import enums, types  # noqa: TID251

'''