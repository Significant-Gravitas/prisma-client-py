'''
# -*- coding: utf-8 -*-
# code generated by Prisma. DO NOT EDIT.
# pyright: reportUnusedImport=false

from typing import (
    Any,
    Dict,
    List,
    Union,
    Literal,
    TypeVar,
    Optional,
    TypedDict,
)
from builtins import int as _int, str as _str

# -- template types/_model.py.jinja --
from .. import enums, types
from ..utils import _NoneType
from .atomic import *
from .filters import *
from .list_filters import *

# --- Types for model: A --- #


# A types


class AOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the A create method"""

    name: Optional[_str]
    inc_int: _int
    inc_sInt: _int
    inc_bInt: _int
    enum: 'enums.ABeautifulEnum'


class ACreateInput(AOptionalCreateInput):
    """Required arguments to the A create method"""

    email: _str
    int: _int
    sInt: _int
    bInt: _int


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput


class AOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the A create method, without relations"""

    name: Optional[_str]
    inc_int: _int
    inc_sInt: _int
    inc_bInt: _int
    enum: 'enums.ABeautifulEnum'


class ACreateWithoutRelationsInput(AOptionalCreateWithoutRelationsInput):
    """Required arguments to the A create method, without relations"""

    email: _str
    int: _int
    sInt: _int
    bInt: _int


class AConnectOrCreateWithoutRelationsInput(TypedDict):
    create: 'ACreateWithoutRelationsInput'
    where: 'AWhereUniqueInput'


class ACreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'ACreateWithoutRelationsInput'
    connect: 'AWhereUniqueInput'
    connect_or_create: 'AConnectOrCreateWithoutRelationsInput'


class ACreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['ACreateWithoutRelationsInput', List['ACreateWithoutRelationsInput']]
    connect: Union['AWhereUniqueInput', List['AWhereUniqueInput']]
    connect_or_create: Union['AConnectOrCreateWithoutRelationsInput', List['AConnectOrCreateWithoutRelationsInput']]


_AWhereUnique_email_Input = TypedDict(
    '_AWhereUnique_email_Input',
    {
        'email': '_str',
    },
    total=True,
)

_ACompoundname_email_enumKeyInner = TypedDict(
    '_ACompoundname_email_enumKeyInner',
    {
        'name': '_str',
        'email': '_str',
        'enum': 'enums.ABeautifulEnum',
    },
    total=True,
)

_ACompoundname_email_enumKey = TypedDict(
    '_ACompoundname_email_enumKey',
    {
        'name_email_enum': '_ACompoundname_email_enumKeyInner',
    },
    total=True,
)

AWhereUniqueInput = Union[
    '_AWhereUnique_email_Input',
    '_ACompoundname_email_enumKey',
]


class AUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""

    email: _str
    name: Optional[_str]
    int: Union[AtomicIntInput, _int]
    sInt: Union[AtomicIntInput, _int]
    inc_int: Union[AtomicIntInput, _int]
    inc_sInt: Union[AtomicIntInput, _int]
    bInt: Union[AtomicBigIntInput, _int]
    inc_bInt: Union[AtomicBigIntInput, _int]
    enum: 'enums.ABeautifulEnum'


class AUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""

    email: _str
    name: Optional[_str]
    int: Union[AtomicIntInput, _int]
    sInt: Union[AtomicIntInput, _int]
    inc_int: Union[AtomicIntInput, _int]
    inc_sInt: Union[AtomicIntInput, _int]
    bInt: Union[AtomicBigIntInput, _int]
    inc_bInt: Union[AtomicBigIntInput, _int]
    enum: 'enums.ABeautifulEnum'


class AUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['ACreateWithoutRelationsInput']
    connect: List['AWhereUniqueInput']
    connect_or_create: List['AConnectOrCreateWithoutRelationsInput']
    set: List['AWhereUniqueInput']
    disconnect: List['AWhereUniqueInput']
    delete: List['AWhereUniqueInput']

    # TODO
    # update: List['AUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['AUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['AScalarWhereInput']
    # upsert: List['AUpserteWithWhereUniqueWithoutRelationsInput']


class AUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'ACreateWithoutRelationsInput'
    connect: 'AWhereUniqueInput'
    connect_or_create: 'AConnectOrCreateWithoutRelationsInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'AUpdateInput'
    # upsert: 'AUpsertWithoutRelationsInput'


class AUpsertInput(TypedDict):
    create: 'ACreateInput'
    update: 'AUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_A_email_OrderByInput = TypedDict(
    '_A_email_OrderByInput',
    {
        'email': 'SortOrder',
    },
    total=True,
)

_A_name_OrderByInput = TypedDict(
    '_A_name_OrderByInput',
    {
        'name': 'SortOrder',
    },
    total=True,
)

_A_int_OrderByInput = TypedDict(
    '_A_int_OrderByInput',
    {
        'int': 'SortOrder',
    },
    total=True,
)

_A_sInt_OrderByInput = TypedDict(
    '_A_sInt_OrderByInput',
    {
        'sInt': 'SortOrder',
    },
    total=True,
)

_A_inc_int_OrderByInput = TypedDict(
    '_A_inc_int_OrderByInput',
    {
        'inc_int': 'SortOrder',
    },
    total=True,
)

_A_inc_sInt_OrderByInput = TypedDict(
    '_A_inc_sInt_OrderByInput',
    {
        'inc_sInt': 'SortOrder',
    },
    total=True,
)

_A_bInt_OrderByInput = TypedDict(
    '_A_bInt_OrderByInput',
    {
        'bInt': 'SortOrder',
    },
    total=True,
)

_A_inc_bInt_OrderByInput = TypedDict(
    '_A_inc_bInt_OrderByInput',
    {
        'inc_bInt': 'SortOrder',
    },
    total=True,
)

_A_enum_OrderByInput = TypedDict(
    '_A_enum_OrderByInput',
    {
        'enum': 'SortOrder',
    },
    total=True,
)

_A_RelevanceInner = TypedDict(
    '_A_RelevanceInner',
    {
        'fields': 'List[AScalarFieldKeys]',
        'search': 'str',
        'sort': 'SortOrder',
    },
    total=True,
)

_A_RelevanceOrderByInput = TypedDict(
    '_A_RelevanceOrderByInput',
    {
        '_relevance': '_A_RelevanceInner',
    },
    total=True,
)

AOrderByInput = Union[
    '_A_email_OrderByInput',
    '_A_name_OrderByInput',
    '_A_int_OrderByInput',
    '_A_sInt_OrderByInput',
    '_A_inc_int_OrderByInput',
    '_A_inc_sInt_OrderByInput',
    '_A_bInt_OrderByInput',
    '_A_inc_bInt_OrderByInput',
    '_A_enum_OrderByInput',
    '_A_RelevanceOrderByInput',
]


# recursive A types
# TODO: cleanup these types


# Dict[str, Any] is a mypy limitation
# see https://github.com/RobertCraigie/prisma-client-py/issues/45
# switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/stable/reference/limitations/

ARelationFilter = TypedDict(
    'ARelationFilter',
    {
        'is': 'Dict[str, Any]',
        'is_not': 'Dict[str, Any]',
    },
    total=False,
)


class AListRelationFilter(TypedDict, total=False):
    some: 'Dict[str, Any]'
    none: 'Dict[str, Any]'
    every: 'Dict[str, Any]'


class AInclude(TypedDict, total=False):
    """A relational arguments"""


class PostIncludeFromA(TypedDict, total=False):
    """Relational arguments for A"""

    author: Union[bool, 'UserArgsFromARecursive1']


class PostIncludeFromARecursive1(TypedDict, total=False):
    """Relational arguments for A"""

    author: Union[bool, 'UserArgsFromARecursive2']


class PostIncludeFromARecursive2(TypedDict, total=False):
    """Relational arguments for A"""


class PostArgsFromA(TypedDict, total=False):
    """Arguments for A"""

    include: 'PostIncludeFromARecursive1'


class PostArgsFromARecursive1(TypedDict, total=False):
    """Arguments for A"""

    include: 'PostIncludeFromARecursive2'


class PostArgsFromARecursive2(TypedDict, total=False):
    """Arguments for A"""


class FindManyPostArgsFromA(TypedDict, total=False):
    """Arguments for A"""

    take: int
    skip: int
    order_by: Union['PostOrderByInput', List['PostOrderByInput']]
    where: 'PostWhereInput'
    cursor: 'PostWhereUniqueInput'
    distinct: List['PostScalarFieldKeys']
    include: 'PostIncludeFromARecursive1'


class FindManyPostArgsFromARecursive1(TypedDict, total=False):
    """Arguments for A"""

    take: int
    skip: int
    order_by: Union['PostOrderByInput', List['PostOrderByInput']]
    where: 'PostWhereInput'
    cursor: 'PostWhereUniqueInput'
    distinct: List['PostScalarFieldKeys']
    include: 'PostIncludeFromARecursive2'


class FindManyPostArgsFromARecursive2(TypedDict, total=False):
    """Arguments for A"""

    take: int
    skip: int
    order_by: Union['PostOrderByInput', List['PostOrderByInput']]
    where: 'PostWhereInput'
    cursor: 'PostWhereUniqueInput'
    distinct: List['PostScalarFieldKeys']


class UserIncludeFromA(TypedDict, total=False):
    """Relational arguments for A"""

    posts: Union[bool, 'FindManyPostArgsFromARecursive1']


class UserIncludeFromARecursive1(TypedDict, total=False):
    """Relational arguments for A"""

    posts: Union[bool, 'FindManyPostArgsFromARecursive2']


class UserIncludeFromARecursive2(TypedDict, total=False):
    """Relational arguments for A"""


class UserArgsFromA(TypedDict, total=False):
    """Arguments for A"""

    include: 'UserIncludeFromARecursive1'


class UserArgsFromARecursive1(TypedDict, total=False):
    """Arguments for A"""

    include: 'UserIncludeFromARecursive2'


class UserArgsFromARecursive2(TypedDict, total=False):
    """Arguments for A"""


class FindManyUserArgsFromA(TypedDict, total=False):
    """Arguments for A"""

    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromARecursive1'


class FindManyUserArgsFromARecursive1(TypedDict, total=False):
    """Arguments for A"""

    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromARecursive2'


class FindManyUserArgsFromARecursive2(TypedDict, total=False):
    """Arguments for A"""

    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']


class MIncludeFromA(TypedDict, total=False):
    """Relational arguments for A"""

    n: Union[bool, 'FindManyNArgsFromARecursive1']


class MIncludeFromARecursive1(TypedDict, total=False):
    """Relational arguments for A"""

    n: Union[bool, 'FindManyNArgsFromARecursive2']


class MIncludeFromARecursive2(TypedDict, total=False):
    """Relational arguments for A"""


class MArgsFromA(TypedDict, total=False):
    """Arguments for A"""

    include: 'MIncludeFromARecursive1'


class MArgsFromARecursive1(TypedDict, total=False):
    """Arguments for A"""

    include: 'MIncludeFromARecursive2'


class MArgsFromARecursive2(TypedDict, total=False):
    """Arguments for A"""


class FindManyMArgsFromA(TypedDict, total=False):
    """Arguments for A"""

    take: int
    skip: int
    order_by: Union['MOrderByInput', List['MOrderByInput']]
    where: 'MWhereInput'
    cursor: 'MWhereUniqueInput'
    distinct: List['MScalarFieldKeys']
    include: 'MIncludeFromARecursive1'


class FindManyMArgsFromARecursive1(TypedDict, total=False):
    """Arguments for A"""

    take: int
    skip: int
    order_by: Union['MOrderByInput', List['MOrderByInput']]
    where: 'MWhereInput'
    cursor: 'MWhereUniqueInput'
    distinct: List['MScalarFieldKeys']
    include: 'MIncludeFromARecursive2'


class FindManyMArgsFromARecursive2(TypedDict, total=False):
    """Arguments for A"""

    take: int
    skip: int
    order_by: Union['MOrderByInput', List['MOrderByInput']]
    where: 'MWhereInput'
    cursor: 'MWhereUniqueInput'
    distinct: List['MScalarFieldKeys']


class NIncludeFromA(TypedDict, total=False):
    """Relational arguments for A"""

    m: Union[bool, 'FindManyMArgsFromARecursive1']


class NIncludeFromARecursive1(TypedDict, total=False):
    """Relational arguments for A"""

    m: Union[bool, 'FindManyMArgsFromARecursive2']


class NIncludeFromARecursive2(TypedDict, total=False):
    """Relational arguments for A"""


class NArgsFromA(TypedDict, total=False):
    """Arguments for A"""

    include: 'NIncludeFromARecursive1'


class NArgsFromARecursive1(TypedDict, total=False):
    """Arguments for A"""

    include: 'NIncludeFromARecursive2'


class NArgsFromARecursive2(TypedDict, total=False):
    """Arguments for A"""


class FindManyNArgsFromA(TypedDict, total=False):
    """Arguments for A"""

    take: int
    skip: int
    order_by: Union['NOrderByInput', List['NOrderByInput']]
    where: 'NWhereInput'
    cursor: 'NWhereUniqueInput'
    distinct: List['NScalarFieldKeys']
    include: 'NIncludeFromARecursive1'


class FindManyNArgsFromARecursive1(TypedDict, total=False):
    """Arguments for A"""

    take: int
    skip: int
    order_by: Union['NOrderByInput', List['NOrderByInput']]
    where: 'NWhereInput'
    cursor: 'NWhereUniqueInput'
    distinct: List['NScalarFieldKeys']
    include: 'NIncludeFromARecursive2'


class FindManyNArgsFromARecursive2(TypedDict, total=False):
    """Arguments for A"""

    take: int
    skip: int
    order_by: Union['NOrderByInput', List['NOrderByInput']]
    where: 'NWhereInput'
    cursor: 'NWhereUniqueInput'
    distinct: List['NScalarFieldKeys']


class OneOptionalIncludeFromA(TypedDict, total=False):
    """Relational arguments for A"""

    many: Union[bool, 'FindManyManyRequiredArgsFromARecursive1']


class OneOptionalIncludeFromARecursive1(TypedDict, total=False):
    """Relational arguments for A"""

    many: Union[bool, 'FindManyManyRequiredArgsFromARecursive2']


class OneOptionalIncludeFromARecursive2(TypedDict, total=False):
    """Relational arguments for A"""


class OneOptionalArgsFromA(TypedDict, total=False):
    """Arguments for A"""

    include: 'OneOptionalIncludeFromARecursive1'


class OneOptionalArgsFromARecursive1(TypedDict, total=False):
    """Arguments for A"""

    include: 'OneOptionalIncludeFromARecursive2'


class OneOptionalArgsFromARecursive2(TypedDict, total=False):
    """Arguments for A"""


class FindManyOneOptionalArgsFromA(TypedDict, total=False):
    """Arguments for A"""

    take: int
    skip: int
    order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
    where: 'OneOptionalWhereInput'
    cursor: 'OneOptionalWhereUniqueInput'
    distinct: List['OneOptionalScalarFieldKeys']
    include: 'OneOptionalIncludeFromARecursive1'


class FindManyOneOptionalArgsFromARecursive1(TypedDict, total=False):
    """Arguments for A"""

    take: int
    skip: int
    order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
    where: 'OneOptionalWhereInput'
    cursor: 'OneOptionalWhereUniqueInput'
    distinct: List['OneOptionalScalarFieldKeys']
    include: 'OneOptionalIncludeFromARecursive2'


class FindManyOneOptionalArgsFromARecursive2(TypedDict, total=False):
    """Arguments for A"""

    take: int
    skip: int
    order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
    where: 'OneOptionalWhereInput'
    cursor: 'OneOptionalWhereUniqueInput'
    distinct: List['OneOptionalScalarFieldKeys']


class ManyRequiredIncludeFromA(TypedDict, total=False):
    """Relational arguments for A"""

    one: Union[bool, 'OneOptionalArgsFromARecursive1']


class ManyRequiredIncludeFromARecursive1(TypedDict, total=False):
    """Relational arguments for A"""

    one: Union[bool, 'OneOptionalArgsFromARecursive2']


class ManyRequiredIncludeFromARecursive2(TypedDict, total=False):
    """Relational arguments for A"""


class ManyRequiredArgsFromA(TypedDict, total=False):
    """Arguments for A"""

    include: 'ManyRequiredIncludeFromARecursive1'


class ManyRequiredArgsFromARecursive1(TypedDict, total=False):
    """Arguments for A"""

    include: 'ManyRequiredIncludeFromARecursive2'


class ManyRequiredArgsFromARecursive2(TypedDict, total=False):
    """Arguments for A"""


class FindManyManyRequiredArgsFromA(TypedDict, total=False):
    """Arguments for A"""

    take: int
    skip: int
    order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
    where: 'ManyRequiredWhereInput'
    cursor: 'ManyRequiredWhereUniqueInput'
    distinct: List['ManyRequiredScalarFieldKeys']
    include: 'ManyRequiredIncludeFromARecursive1'


class FindManyManyRequiredArgsFromARecursive1(TypedDict, total=False):
    """Arguments for A"""

    take: int
    skip: int
    order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
    where: 'ManyRequiredWhereInput'
    cursor: 'ManyRequiredWhereUniqueInput'
    distinct: List['ManyRequiredScalarFieldKeys']
    include: 'ManyRequiredIncludeFromARecursive2'


class FindManyManyRequiredArgsFromARecursive2(TypedDict, total=False):
    """Arguments for A"""

    take: int
    skip: int
    order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
    where: 'ManyRequiredWhereInput'
    cursor: 'ManyRequiredWhereUniqueInput'
    distinct: List['ManyRequiredScalarFieldKeys']


class ListsIncludeFromA(TypedDict, total=False):
    """Relational arguments for A"""


class ListsIncludeFromARecursive1(TypedDict, total=False):
    """Relational arguments for A"""


class ListsIncludeFromARecursive2(TypedDict, total=False):
    """Relational arguments for A"""


class ListsArgsFromA(TypedDict, total=False):
    """Arguments for A"""

    include: 'ListsIncludeFromARecursive1'


class ListsArgsFromARecursive1(TypedDict, total=False):
    """Arguments for A"""

    include: 'ListsIncludeFromARecursive2'


class ListsArgsFromARecursive2(TypedDict, total=False):
    """Arguments for A"""


class FindManyListsArgsFromA(TypedDict, total=False):
    """Arguments for A"""

    take: int
    skip: int
    order_by: Union['ListsOrderByInput', List['ListsOrderByInput']]
    where: 'ListsWhereInput'
    cursor: 'ListsWhereUniqueInput'
    distinct: List['ListsScalarFieldKeys']
    include: 'ListsIncludeFromARecursive1'


class FindManyListsArgsFromARecursive1(TypedDict, total=False):
    """Arguments for A"""

    take: int
    skip: int
    order_by: Union['ListsOrderByInput', List['ListsOrderByInput']]
    where: 'ListsWhereInput'
    cursor: 'ListsWhereUniqueInput'
    distinct: List['ListsScalarFieldKeys']
    include: 'ListsIncludeFromARecursive2'


class FindManyListsArgsFromARecursive2(TypedDict, total=False):
    """Arguments for A"""

    take: int
    skip: int
    order_by: Union['ListsOrderByInput', List['ListsOrderByInput']]
    where: 'ListsWhereInput'
    cursor: 'ListsWhereUniqueInput'
    distinct: List['ListsScalarFieldKeys']


class AIncludeFromA(TypedDict, total=False):
    """Relational arguments for A"""


class AIncludeFromARecursive1(TypedDict, total=False):
    """Relational arguments for A"""


class AIncludeFromARecursive2(TypedDict, total=False):
    """Relational arguments for A"""


class AArgsFromA(TypedDict, total=False):
    """Arguments for A"""

    include: 'AIncludeFromARecursive1'


class AArgsFromARecursive1(TypedDict, total=False):
    """Arguments for A"""

    include: 'AIncludeFromARecursive2'


class AArgsFromARecursive2(TypedDict, total=False):
    """Arguments for A"""


class FindManyAArgsFromA(TypedDict, total=False):
    """Arguments for A"""

    take: int
    skip: int
    order_by: Union['AOrderByInput', List['AOrderByInput']]
    where: 'AWhereInput'
    cursor: 'AWhereUniqueInput'
    distinct: List['AScalarFieldKeys']
    include: 'AIncludeFromARecursive1'


class FindManyAArgsFromARecursive1(TypedDict, total=False):
    """Arguments for A"""

    take: int
    skip: int
    order_by: Union['AOrderByInput', List['AOrderByInput']]
    where: 'AWhereInput'
    cursor: 'AWhereUniqueInput'
    distinct: List['AScalarFieldKeys']
    include: 'AIncludeFromARecursive2'


class FindManyAArgsFromARecursive2(TypedDict, total=False):
    """Arguments for A"""

    take: int
    skip: int
    order_by: Union['AOrderByInput', List['AOrderByInput']]
    where: 'AWhereInput'
    cursor: 'AWhereUniqueInput'
    distinct: List['AScalarFieldKeys']


class BIncludeFromA(TypedDict, total=False):
    """Relational arguments for A"""


class BIncludeFromARecursive1(TypedDict, total=False):
    """Relational arguments for A"""


class BIncludeFromARecursive2(TypedDict, total=False):
    """Relational arguments for A"""


class BArgsFromA(TypedDict, total=False):
    """Arguments for A"""

    include: 'BIncludeFromARecursive1'


class BArgsFromARecursive1(TypedDict, total=False):
    """Arguments for A"""

    include: 'BIncludeFromARecursive2'


class BArgsFromARecursive2(TypedDict, total=False):
    """Arguments for A"""


class FindManyBArgsFromA(TypedDict, total=False):
    """Arguments for A"""

    take: int
    skip: int
    order_by: Union['BOrderByInput', List['BOrderByInput']]
    where: 'BWhereInput'
    cursor: 'BWhereUniqueInput'
    distinct: List['BScalarFieldKeys']
    include: 'BIncludeFromARecursive1'


class FindManyBArgsFromARecursive1(TypedDict, total=False):
    """Arguments for A"""

    take: int
    skip: int
    order_by: Union['BOrderByInput', List['BOrderByInput']]
    where: 'BWhereInput'
    cursor: 'BWhereUniqueInput'
    distinct: List['BScalarFieldKeys']
    include: 'BIncludeFromARecursive2'


class FindManyBArgsFromARecursive2(TypedDict, total=False):
    """Arguments for A"""

    take: int
    skip: int
    order_by: Union['BOrderByInput', List['BOrderByInput']]
    where: 'BWhereInput'
    cursor: 'BWhereUniqueInput'
    distinct: List['BScalarFieldKeys']


class CIncludeFromA(TypedDict, total=False):
    """Relational arguments for A"""


class CIncludeFromARecursive1(TypedDict, total=False):
    """Relational arguments for A"""


class CIncludeFromARecursive2(TypedDict, total=False):
    """Relational arguments for A"""


class CArgsFromA(TypedDict, total=False):
    """Arguments for A"""

    include: 'CIncludeFromARecursive1'


class CArgsFromARecursive1(TypedDict, total=False):
    """Arguments for A"""

    include: 'CIncludeFromARecursive2'


class CArgsFromARecursive2(TypedDict, total=False):
    """Arguments for A"""


class FindManyCArgsFromA(TypedDict, total=False):
    """Arguments for A"""

    take: int
    skip: int
    order_by: Union['COrderByInput', List['COrderByInput']]
    where: 'CWhereInput'
    cursor: 'CWhereUniqueInput'
    distinct: List['CScalarFieldKeys']
    include: 'CIncludeFromARecursive1'


class FindManyCArgsFromARecursive1(TypedDict, total=False):
    """Arguments for A"""

    take: int
    skip: int
    order_by: Union['COrderByInput', List['COrderByInput']]
    where: 'CWhereInput'
    cursor: 'CWhereUniqueInput'
    distinct: List['CScalarFieldKeys']
    include: 'CIncludeFromARecursive2'


class FindManyCArgsFromARecursive2(TypedDict, total=False):
    """Arguments for A"""

    take: int
    skip: int
    order_by: Union['COrderByInput', List['COrderByInput']]
    where: 'CWhereInput'
    cursor: 'CWhereUniqueInput'
    distinct: List['CScalarFieldKeys']


class DIncludeFromA(TypedDict, total=False):
    """Relational arguments for A"""


class DIncludeFromARecursive1(TypedDict, total=False):
    """Relational arguments for A"""


class DIncludeFromARecursive2(TypedDict, total=False):
    """Relational arguments for A"""


class DArgsFromA(TypedDict, total=False):
    """Arguments for A"""

    include: 'DIncludeFromARecursive1'


class DArgsFromARecursive1(TypedDict, total=False):
    """Arguments for A"""

    include: 'DIncludeFromARecursive2'


class DArgsFromARecursive2(TypedDict, total=False):
    """Arguments for A"""


class FindManyDArgsFromA(TypedDict, total=False):
    """Arguments for A"""

    take: int
    skip: int
    order_by: Union['DOrderByInput', List['DOrderByInput']]
    where: 'DWhereInput'
    cursor: 'DWhereUniqueInput'
    distinct: List['DScalarFieldKeys']
    include: 'DIncludeFromARecursive1'


class FindManyDArgsFromARecursive1(TypedDict, total=False):
    """Arguments for A"""

    take: int
    skip: int
    order_by: Union['DOrderByInput', List['DOrderByInput']]
    where: 'DWhereInput'
    cursor: 'DWhereUniqueInput'
    distinct: List['DScalarFieldKeys']
    include: 'DIncludeFromARecursive2'


class FindManyDArgsFromARecursive2(TypedDict, total=False):
    """Arguments for A"""

    take: int
    skip: int
    order_by: Union['DOrderByInput', List['DOrderByInput']]
    where: 'DWhereInput'
    cursor: 'DWhereUniqueInput'
    distinct: List['DScalarFieldKeys']


class EIncludeFromA(TypedDict, total=False):
    """Relational arguments for A"""


class EIncludeFromARecursive1(TypedDict, total=False):
    """Relational arguments for A"""


class EIncludeFromARecursive2(TypedDict, total=False):
    """Relational arguments for A"""


class EArgsFromA(TypedDict, total=False):
    """Arguments for A"""

    include: 'EIncludeFromARecursive1'


class EArgsFromARecursive1(TypedDict, total=False):
    """Arguments for A"""

    include: 'EIncludeFromARecursive2'


class EArgsFromARecursive2(TypedDict, total=False):
    """Arguments for A"""


class FindManyEArgsFromA(TypedDict, total=False):
    """Arguments for A"""

    take: int
    skip: int
    order_by: Union['EOrderByInput', List['EOrderByInput']]
    where: 'EWhereInput'
    cursor: 'EWhereUniqueInput'
    distinct: List['EScalarFieldKeys']
    include: 'EIncludeFromARecursive1'


class FindManyEArgsFromARecursive1(TypedDict, total=False):
    """Arguments for A"""

    take: int
    skip: int
    order_by: Union['EOrderByInput', List['EOrderByInput']]
    where: 'EWhereInput'
    cursor: 'EWhereUniqueInput'
    distinct: List['EScalarFieldKeys']
    include: 'EIncludeFromARecursive2'


class FindManyEArgsFromARecursive2(TypedDict, total=False):
    """Arguments for A"""

    take: int
    skip: int
    order_by: Union['EOrderByInput', List['EOrderByInput']]
    where: 'EWhereInput'
    cursor: 'EWhereUniqueInput'
    distinct: List['EScalarFieldKeys']


FindManyAArgs = FindManyAArgsFromA
FindFirstAArgs = FindManyAArgsFromA


class AWhereInput(TypedDict, total=False):
    """A arguments for searching"""

    email: Union[_str, 'types.StringFilter']
    name: Union[None, _str, 'types.StringFilter']
    int: Union[_int, 'types.IntFilter']
    sInt: Union[_int, 'types.IntFilter']
    inc_int: Union[_int, 'types.IntFilter']
    inc_sInt: Union[_int, 'types.IntFilter']
    bInt: Union[_int, 'types.BigIntFilter']
    inc_bInt: Union[_int, 'types.BigIntFilter']
    enum: 'enums.ABeautifulEnum'

    # should be noted that AND and NOT should be Union['AWhereInputRecursive1', List['AWhereInputRecursive1']]
    # but this causes mypy to hang :/
    AND: List['AWhereInputRecursive1']
    OR: List['AWhereInputRecursive1']
    NOT: List['AWhereInputRecursive1']


class AWhereInputRecursive1(TypedDict, total=False):
    """A arguments for searching"""

    email: Union[_str, 'types.StringFilter']
    name: Union[None, _str, 'types.StringFilter']
    int: Union[_int, 'types.IntFilter']
    sInt: Union[_int, 'types.IntFilter']
    inc_int: Union[_int, 'types.IntFilter']
    inc_sInt: Union[_int, 'types.IntFilter']
    bInt: Union[_int, 'types.BigIntFilter']
    inc_bInt: Union[_int, 'types.BigIntFilter']
    enum: 'enums.ABeautifulEnum'

    # should be noted that AND and NOT should be Union['AWhereInputRecursive2', List['AWhereInputRecursive2']]
    # but this causes mypy to hang :/
    AND: List['AWhereInputRecursive2']
    OR: List['AWhereInputRecursive2']
    NOT: List['AWhereInputRecursive2']


class AWhereInputRecursive2(TypedDict, total=False):
    """A arguments for searching"""

    email: Union[_str, 'types.StringFilter']
    name: Union[None, _str, 'types.StringFilter']
    int: Union[_int, 'types.IntFilter']
    sInt: Union[_int, 'types.IntFilter']
    inc_int: Union[_int, 'types.IntFilter']
    inc_sInt: Union[_int, 'types.IntFilter']
    bInt: Union[_int, 'types.BigIntFilter']
    inc_bInt: Union[_int, 'types.BigIntFilter']
    enum: 'enums.ABeautifulEnum'


# aggregate A types


class AScalarWhereWithAggregatesInput(TypedDict, total=False):
    """A arguments for searching"""

    email: Union[_str, 'types.StringWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    int: Union[_int, 'types.IntWithAggregatesFilter']
    sInt: Union[_int, 'types.IntWithAggregatesFilter']
    inc_int: Union[_int, 'types.IntWithAggregatesFilter']
    inc_sInt: Union[_int, 'types.IntWithAggregatesFilter']
    bInt: Union[_int, 'types.BigIntWithAggregatesFilter']
    inc_bInt: Union[_int, 'types.BigIntWithAggregatesFilter']
    enum: 'enums.ABeautifulEnum'

    AND: List['AScalarWhereWithAggregatesInputRecursive1']
    OR: List['AScalarWhereWithAggregatesInputRecursive1']
    NOT: List['AScalarWhereWithAggregatesInputRecursive1']


class AScalarWhereWithAggregatesInputRecursive1(TypedDict, total=False):
    """A arguments for searching"""

    email: Union[_str, 'types.StringWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    int: Union[_int, 'types.IntWithAggregatesFilter']
    sInt: Union[_int, 'types.IntWithAggregatesFilter']
    inc_int: Union[_int, 'types.IntWithAggregatesFilter']
    inc_sInt: Union[_int, 'types.IntWithAggregatesFilter']
    bInt: Union[_int, 'types.BigIntWithAggregatesFilter']
    inc_bInt: Union[_int, 'types.BigIntWithAggregatesFilter']
    enum: 'enums.ABeautifulEnum'

    AND: List['AScalarWhereWithAggregatesInputRecursive2']
    OR: List['AScalarWhereWithAggregatesInputRecursive2']
    NOT: List['AScalarWhereWithAggregatesInputRecursive2']


class AScalarWhereWithAggregatesInputRecursive2(TypedDict, total=False):
    """A arguments for searching"""

    email: Union[_str, 'types.StringWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    int: Union[_int, 'types.IntWithAggregatesFilter']
    sInt: Union[_int, 'types.IntWithAggregatesFilter']
    inc_int: Union[_int, 'types.IntWithAggregatesFilter']
    inc_sInt: Union[_int, 'types.IntWithAggregatesFilter']
    bInt: Union[_int, 'types.BigIntWithAggregatesFilter']
    inc_bInt: Union[_int, 'types.BigIntWithAggregatesFilter']
    enum: 'enums.ABeautifulEnum'


class AGroupByOutput(TypedDict, total=False):
    email: _str
    name: _str
    int: _int
    sInt: _int
    inc_int: _int
    inc_sInt: _int
    bInt: _int
    inc_bInt: _int
    enum: 'enums.ABeautifulEnum'
    _sum: 'ASumAggregateOutput'
    _avg: 'AAvgAggregateOutput'
    _min: 'AMinAggregateOutput'
    _max: 'AMaxAggregateOutput'
    _count: 'ACountAggregateOutput'


class AAvgAggregateOutput(TypedDict, total=False):
    """A output for aggregating averages"""

    int: float
    sInt: float
    inc_int: float
    inc_sInt: float
    bInt: float
    inc_bInt: float


class ASumAggregateOutput(TypedDict, total=False):
    """A output for aggregating sums"""

    int: _int
    sInt: _int
    inc_int: _int
    inc_sInt: _int
    bInt: _int
    inc_bInt: _int


class AScalarAggregateOutput(TypedDict, total=False):
    """A output including scalar fields"""

    email: _str
    name: _str
    int: _int
    sInt: _int
    inc_int: _int
    inc_sInt: _int
    bInt: _int
    inc_bInt: _int
    enum: 'enums.ABeautifulEnum'


AMinAggregateOutput = AScalarAggregateOutput
AMaxAggregateOutput = AScalarAggregateOutput


class AMaxAggregateInput(TypedDict, total=False):
    """A input for aggregating by max"""

    email: bool
    name: bool
    int: bool
    sInt: bool
    inc_int: bool
    inc_sInt: bool
    bInt: bool
    inc_bInt: bool
    enum: bool


class AMinAggregateInput(TypedDict, total=False):
    """A input for aggregating by min"""

    email: bool
    name: bool
    int: bool
    sInt: bool
    inc_int: bool
    inc_sInt: bool
    bInt: bool
    inc_bInt: bool
    enum: bool


class ANumberAggregateInput(TypedDict, total=False):
    """A input for aggregating numbers"""

    int: bool
    sInt: bool
    inc_int: bool
    inc_sInt: bool
    bInt: bool
    inc_bInt: bool


AAvgAggregateInput = ANumberAggregateInput
ASumAggregateInput = ANumberAggregateInput


ACountAggregateInput = TypedDict(
    'ACountAggregateInput',
    {
        'email': bool,
        'name': bool,
        'int': bool,
        'sInt': bool,
        'inc_int': bool,
        'inc_sInt': bool,
        'bInt': bool,
        'inc_bInt': bool,
        'enum': bool,
        '_all': bool,
    },
    total=False,
)

ACountAggregateOutput = TypedDict(
    'ACountAggregateOutput',
    {
        'email': int,
        'name': int,
        'int': int,
        'sInt': int,
        'inc_int': int,
        'inc_sInt': int,
        'bInt': int,
        'inc_bInt': int,
        'enum': int,
        '_all': int,
    },
    total=False,
)


AKeys = Literal[
    'email',
    'name',
    'int',
    'sInt',
    'inc_int',
    'inc_sInt',
    'bInt',
    'inc_bInt',
    'enum',
]
AScalarFieldKeys = Literal[
    'email',
    'name',
    'int',
    'sInt',
    'inc_int',
    'inc_sInt',
    'bInt',
    'inc_bInt',
    'enum',
]
AScalarFieldKeysT = TypeVar('AScalarFieldKeysT', bound=AScalarFieldKeys)

ARelationalFieldKeys = _NoneType

# Cross-import related model types for resolution of forward references
from .b import (
    BWhereInput,
    BOrderByInput,
    BScalarFieldKeys,
    BWhereUniqueInput,
)
from .c import (
    CWhereInput,
    COrderByInput,
    CScalarFieldKeys,
    CWhereUniqueInput,
)
from .d import (
    DWhereInput,
    DOrderByInput,
    DScalarFieldKeys,
    DWhereUniqueInput,
)
from .e import (
    EWhereInput,
    EOrderByInput,
    EScalarFieldKeys,
    EWhereUniqueInput,
)
from .m import (
    MWhereInput,
    MOrderByInput,
    MScalarFieldKeys,
    MWhereUniqueInput,
)
from .n import (
    NWhereInput,
    NOrderByInput,
    NScalarFieldKeys,
    NWhereUniqueInput,
)
from .post import (
    PostWhereInput,
    PostOrderByInput,
    PostScalarFieldKeys,
    PostWhereUniqueInput,
)
from .user import (
    UserWhereInput,
    UserOrderByInput,
    UserScalarFieldKeys,
    UserWhereUniqueInput,
)
from .lists import (
    ListsWhereInput,
    ListsOrderByInput,
    ListsScalarFieldKeys,
    ListsWhereUniqueInput,
)
from .oneoptional import (
    OneOptionalWhereInput,
    OneOptionalOrderByInput,
    OneOptionalScalarFieldKeys,
    OneOptionalWhereUniqueInput,
)
from .manyrequired import (
    ManyRequiredWhereInput,
    ManyRequiredOrderByInput,
    ManyRequiredScalarFieldKeys,
    ManyRequiredWhereUniqueInput,
)

'''