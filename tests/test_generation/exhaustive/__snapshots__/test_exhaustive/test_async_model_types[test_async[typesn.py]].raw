'''
# -*- coding: utf-8 -*-
# code generated by Prisma. DO NOT EDIT.
# pyright: reportUnusedImport=false
# fmt: off

# global imports for type checking
from typing import (
    TYPE_CHECKING,
    Any,
    Dict,
    List,
    Union,
    Literal,
    TypeVar,
    Optional,
    TypedDict,
)
from builtins import int as _int, str as _str, bool as _bool, float as _float

LiteralString = str
# -- template types/_model.py.jinja --
# Types for model: N

from .atomic import *  # noqa: TID251
from .filters import *  # noqa: TID251
from .list_filters import *  # noqa: TID251

# Cross-import related model types for type checker resolution
if TYPE_CHECKING:
    from .a import (  # noqa: TID251
        AWhereInput,
        AOrderByInput,
        AScalarFieldKeys,
        AWhereUniqueInput,
    )
    from .b import (  # noqa: TID251
        BWhereInput,
        BOrderByInput,
        BScalarFieldKeys,
        BWhereUniqueInput,
    )
    from .c import (  # noqa: TID251
        CWhereInput,
        COrderByInput,
        CScalarFieldKeys,
        CWhereUniqueInput,
    )
    from .d import (  # noqa: TID251
        DWhereInput,
        DOrderByInput,
        DScalarFieldKeys,
        DWhereUniqueInput,
    )
    from .e import (  # noqa: TID251
        EWhereInput,
        EOrderByInput,
        EScalarFieldKeys,
        EWhereUniqueInput,
    )
    from .m import (  # noqa: TID251
        MWhereInput,
        MOrderByInput,
        MScalarFieldKeys,
        MWhereUniqueInput,
        MListRelationFilter,
        MUpdateManyWithoutRelationsInput,
        MCreateManyNestedWithoutRelationsInput,
    )
    from .post import (  # noqa: TID251
        PostWhereInput,
        PostOrderByInput,
        PostScalarFieldKeys,
        PostWhereUniqueInput,
    )
    from .user import (  # noqa: TID251
        UserWhereInput,
        UserOrderByInput,
        UserScalarFieldKeys,
        UserWhereUniqueInput,
    )
    from .lists import (  # noqa: TID251
        ListsWhereInput,
        ListsOrderByInput,
        ListsScalarFieldKeys,
        ListsWhereUniqueInput,
    )
    from .oneoptional import (  # noqa: TID251
        OneOptionalWhereInput,
        OneOptionalOrderByInput,
        OneOptionalScalarFieldKeys,
        OneOptionalWhereUniqueInput,
    )
    from .manyrequired import (  # noqa: TID251
        ManyRequiredWhereInput,
        ManyRequiredOrderByInput,
        ManyRequiredScalarFieldKeys,
        ManyRequiredWhereUniqueInput,
    )





# N types

class NOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the N create method"""
    id: _int
    m: 'MCreateManyNestedWithoutRelationsInput'
    optional_int: Optional[_int]
    optional_float: Optional[_float]
    optional_string: Optional[_str]
    optional_json: Optional['fields.Json']
    optional_enum: Optional['enums.ABeautifulEnum']
    optional_boolean: Optional[_bool]


class NCreateInput(NOptionalCreateInput):
    """Required arguments to the N create method"""
    int: _int
    float: _float
    string: _str
    json_: 'fields.Json'
    enum: 'enums.ABeautifulEnum'
    boolean: _bool


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class NOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the N create method, without relations"""
    id: _int
    optional_int: Optional[_int]
    optional_float: Optional[_float]
    optional_string: Optional[_str]
    optional_json: Optional['fields.Json']
    optional_enum: Optional['enums.ABeautifulEnum']
    optional_boolean: Optional[_bool]


class NCreateWithoutRelationsInput(NOptionalCreateWithoutRelationsInput):
    """Required arguments to the N create method, without relations"""
    int: _int
    float: _float
    string: _str
    json_: 'fields.Json'
    enum: 'enums.ABeautifulEnum'
    boolean: _bool

class NConnectOrCreateWithoutRelationsInput(TypedDict):
    create: 'NCreateWithoutRelationsInput'
    where: 'NWhereUniqueInput'

class NCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'NCreateWithoutRelationsInput'
    connect: 'NWhereUniqueInput'
    connect_or_create: 'NConnectOrCreateWithoutRelationsInput'


class NCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['NCreateWithoutRelationsInput', List['NCreateWithoutRelationsInput']]
    connect: Union['NWhereUniqueInput', List['NWhereUniqueInput']]
    connect_or_create: Union['NConnectOrCreateWithoutRelationsInput', List['NConnectOrCreateWithoutRelationsInput']]

_NWhereUnique_id_Input = TypedDict(
    '_NWhereUnique_id_Input',
    {
        'id': '_int',
    },
    total=True
)

NWhereUniqueInput = _NWhereUnique_id_Input


class NUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: Union[AtomicIntInput, _int]
    m: 'MUpdateManyWithoutRelationsInput'
    int: Union[AtomicIntInput, _int]
    optional_int: Optional[Union[AtomicIntInput, _int]]
    float: Union[AtomicFloatInput, _float]
    optional_float: Optional[Union[AtomicFloatInput, _float]]
    string: _str
    optional_string: Optional[_str]
    json_: 'fields.Json'
    optional_json: Optional['fields.Json']
    enum: 'enums.ABeautifulEnum'
    optional_enum: Optional['enums.ABeautifulEnum']
    boolean: _bool
    optional_boolean: Optional[_bool]


class NUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: Union[AtomicIntInput, _int]
    int: Union[AtomicIntInput, _int]
    optional_int: Optional[Union[AtomicIntInput, _int]]
    float: Union[AtomicFloatInput, _float]
    optional_float: Optional[Union[AtomicFloatInput, _float]]
    string: _str
    optional_string: Optional[_str]
    json_: 'fields.Json'
    optional_json: Optional['fields.Json']
    enum: 'enums.ABeautifulEnum'
    optional_enum: Optional['enums.ABeautifulEnum']
    boolean: _bool
    optional_boolean: Optional[_bool]


class NUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['NCreateWithoutRelationsInput']
    connect: List['NWhereUniqueInput']
    connect_or_create: List['NConnectOrCreateWithoutRelationsInput']
    set: List['NWhereUniqueInput']
    disconnect: List['NWhereUniqueInput']
    delete: List['NWhereUniqueInput']

    # TODO
    # update: List['NUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['NUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['NScalarWhereInput']
    # upsert: List['NUpserteWithWhereUniqueWithoutRelationsInput']


class NUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'NCreateWithoutRelationsInput'
    connect: 'NWhereUniqueInput'
    connect_or_create: 'NConnectOrCreateWithoutRelationsInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'NUpdateInput'
    # upsert: 'NUpsertWithoutRelationsInput'


class NUpsertInput(TypedDict):
    create: 'NCreateInput'
    update: 'NUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_N_id_OrderByInput = TypedDict(
    '_N_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_N_int_OrderByInput = TypedDict(
    '_N_int_OrderByInput',
    {
        'int': 'SortOrder',
    },
    total=True
)

_N_optional_int_OrderByInput = TypedDict(
    '_N_optional_int_OrderByInput',
    {
        'optional_int': 'SortOrder',
    },
    total=True
)

_N_float_OrderByInput = TypedDict(
    '_N_float_OrderByInput',
    {
        'float': 'SortOrder',
    },
    total=True
)

_N_optional_float_OrderByInput = TypedDict(
    '_N_optional_float_OrderByInput',
    {
        'optional_float': 'SortOrder',
    },
    total=True
)

_N_string_OrderByInput = TypedDict(
    '_N_string_OrderByInput',
    {
        'string': 'SortOrder',
    },
    total=True
)

_N_optional_string_OrderByInput = TypedDict(
    '_N_optional_string_OrderByInput',
    {
        'optional_string': 'SortOrder',
    },
    total=True
)

_N_json__OrderByInput = TypedDict(
    '_N_json__OrderByInput',
    {
        'json_': 'SortOrder',
    },
    total=True
)

_N_optional_json_OrderByInput = TypedDict(
    '_N_optional_json_OrderByInput',
    {
        'optional_json': 'SortOrder',
    },
    total=True
)

_N_enum_OrderByInput = TypedDict(
    '_N_enum_OrderByInput',
    {
        'enum': 'SortOrder',
    },
    total=True
)

_N_optional_enum_OrderByInput = TypedDict(
    '_N_optional_enum_OrderByInput',
    {
        'optional_enum': 'SortOrder',
    },
    total=True
)

_N_boolean_OrderByInput = TypedDict(
    '_N_boolean_OrderByInput',
    {
        'boolean': 'SortOrder',
    },
    total=True
)

_N_optional_boolean_OrderByInput = TypedDict(
    '_N_optional_boolean_OrderByInput',
    {
        'optional_boolean': 'SortOrder',
    },
    total=True
)

_N_RelevanceInner = TypedDict(
    '_N_RelevanceInner',
    {
        'fields': 'List[NScalarFieldKeys]',
        'search': 'str',
        'sort': 'SortOrder',
    },
    total=True
)

_N_RelevanceOrderByInput = TypedDict(
    '_N_RelevanceOrderByInput',
    {
        '_relevance': '_N_RelevanceInner',
    },
    total=True
)

NOrderByInput = Union[
    '_N_id_OrderByInput',
    '_N_int_OrderByInput',
    '_N_optional_int_OrderByInput',
    '_N_float_OrderByInput',
    '_N_optional_float_OrderByInput',
    '_N_string_OrderByInput',
    '_N_optional_string_OrderByInput',
    '_N_json__OrderByInput',
    '_N_optional_json_OrderByInput',
    '_N_enum_OrderByInput',
    '_N_optional_enum_OrderByInput',
    '_N_boolean_OrderByInput',
    '_N_optional_boolean_OrderByInput',
    '_N_RelevanceOrderByInput',
]



# recursive N types
# TODO: cleanup these types


# Dict[str, Any] is a mypy limitation
# see https://github.com/RobertCraigie/prisma-client-py/issues/45
# switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/stable/reference/limitations/

NRelationFilter = TypedDict(
    'NRelationFilter',
    {
        'is': 'Dict[str, Any]',
        'is_not': 'Dict[str, Any]',
    },
    total=False,
)


class NListRelationFilter(TypedDict, total=False):
    some: 'Dict[str, Any]'
    none: 'Dict[str, Any]'
    every: 'Dict[str, Any]'


class NInclude(TypedDict, total=False):
    """N relational arguments"""
    m: Union[bool, 'FindManyMArgsFromN']


    

class PostIncludeFromN(TypedDict, total=False):
    """Relational arguments for N"""
    author: Union[bool, 'UserArgsFromNRecursive1']


class PostIncludeFromNRecursive1(TypedDict, total=False):
    """Relational arguments for N"""
    author: Union[bool, 'UserArgsFromNRecursive2']


class PostIncludeFromNRecursive2(TypedDict, total=False):
    """Relational arguments for N"""

    

class PostArgsFromN(TypedDict, total=False):
    """Arguments for N"""
    include: 'PostIncludeFromNRecursive1'


class PostArgsFromNRecursive1(TypedDict, total=False):
    """Arguments for N"""
    include: 'PostIncludeFromNRecursive2'


class PostArgsFromNRecursive2(TypedDict, total=False):
    """Arguments for N"""
    
    

class FindManyPostArgsFromN(TypedDict, total=False):
    """Arguments for N"""
    take: int
    skip: int
    order_by: Union['PostOrderByInput', List['PostOrderByInput']]
    where: 'PostWhereInput'
    cursor: 'PostWhereUniqueInput'
    distinct: List['PostScalarFieldKeys']
    include: 'PostIncludeFromNRecursive1'


class FindManyPostArgsFromNRecursive1(TypedDict, total=False):
    """Arguments for N"""
    take: int
    skip: int
    order_by: Union['PostOrderByInput', List['PostOrderByInput']]
    where: 'PostWhereInput'
    cursor: 'PostWhereUniqueInput'
    distinct: List['PostScalarFieldKeys']
    include: 'PostIncludeFromNRecursive2'


class FindManyPostArgsFromNRecursive2(TypedDict, total=False):
    """Arguments for N"""
    take: int
    skip: int
    order_by: Union['PostOrderByInput', List['PostOrderByInput']]
    where: 'PostWhereInput'
    cursor: 'PostWhereUniqueInput'
    distinct: List['PostScalarFieldKeys']
        

class UserIncludeFromN(TypedDict, total=False):
    """Relational arguments for N"""
    posts: Union[bool, 'FindManyPostArgsFromNRecursive1']


class UserIncludeFromNRecursive1(TypedDict, total=False):
    """Relational arguments for N"""
    posts: Union[bool, 'FindManyPostArgsFromNRecursive2']


class UserIncludeFromNRecursive2(TypedDict, total=False):
    """Relational arguments for N"""

    

class UserArgsFromN(TypedDict, total=False):
    """Arguments for N"""
    include: 'UserIncludeFromNRecursive1'


class UserArgsFromNRecursive1(TypedDict, total=False):
    """Arguments for N"""
    include: 'UserIncludeFromNRecursive2'


class UserArgsFromNRecursive2(TypedDict, total=False):
    """Arguments for N"""
    
    

class FindManyUserArgsFromN(TypedDict, total=False):
    """Arguments for N"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromNRecursive1'


class FindManyUserArgsFromNRecursive1(TypedDict, total=False):
    """Arguments for N"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromNRecursive2'


class FindManyUserArgsFromNRecursive2(TypedDict, total=False):
    """Arguments for N"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
        

class MIncludeFromN(TypedDict, total=False):
    """Relational arguments for N"""
    n: Union[bool, 'FindManyNArgsFromNRecursive1']


class MIncludeFromNRecursive1(TypedDict, total=False):
    """Relational arguments for N"""
    n: Union[bool, 'FindManyNArgsFromNRecursive2']


class MIncludeFromNRecursive2(TypedDict, total=False):
    """Relational arguments for N"""

    

class MArgsFromN(TypedDict, total=False):
    """Arguments for N"""
    include: 'MIncludeFromNRecursive1'


class MArgsFromNRecursive1(TypedDict, total=False):
    """Arguments for N"""
    include: 'MIncludeFromNRecursive2'


class MArgsFromNRecursive2(TypedDict, total=False):
    """Arguments for N"""
    
    

class FindManyMArgsFromN(TypedDict, total=False):
    """Arguments for N"""
    take: int
    skip: int
    order_by: Union['MOrderByInput', List['MOrderByInput']]
    where: 'MWhereInput'
    cursor: 'MWhereUniqueInput'
    distinct: List['MScalarFieldKeys']
    include: 'MIncludeFromNRecursive1'


class FindManyMArgsFromNRecursive1(TypedDict, total=False):
    """Arguments for N"""
    take: int
    skip: int
    order_by: Union['MOrderByInput', List['MOrderByInput']]
    where: 'MWhereInput'
    cursor: 'MWhereUniqueInput'
    distinct: List['MScalarFieldKeys']
    include: 'MIncludeFromNRecursive2'


class FindManyMArgsFromNRecursive2(TypedDict, total=False):
    """Arguments for N"""
    take: int
    skip: int
    order_by: Union['MOrderByInput', List['MOrderByInput']]
    where: 'MWhereInput'
    cursor: 'MWhereUniqueInput'
    distinct: List['MScalarFieldKeys']
        

class NIncludeFromN(TypedDict, total=False):
    """Relational arguments for N"""
    m: Union[bool, 'FindManyMArgsFromNRecursive1']


class NIncludeFromNRecursive1(TypedDict, total=False):
    """Relational arguments for N"""
    m: Union[bool, 'FindManyMArgsFromNRecursive2']


class NIncludeFromNRecursive2(TypedDict, total=False):
    """Relational arguments for N"""

    

class NArgsFromN(TypedDict, total=False):
    """Arguments for N"""
    include: 'NIncludeFromNRecursive1'


class NArgsFromNRecursive1(TypedDict, total=False):
    """Arguments for N"""
    include: 'NIncludeFromNRecursive2'


class NArgsFromNRecursive2(TypedDict, total=False):
    """Arguments for N"""
    
    

class FindManyNArgsFromN(TypedDict, total=False):
    """Arguments for N"""
    take: int
    skip: int
    order_by: Union['NOrderByInput', List['NOrderByInput']]
    where: 'NWhereInput'
    cursor: 'NWhereUniqueInput'
    distinct: List['NScalarFieldKeys']
    include: 'NIncludeFromNRecursive1'


class FindManyNArgsFromNRecursive1(TypedDict, total=False):
    """Arguments for N"""
    take: int
    skip: int
    order_by: Union['NOrderByInput', List['NOrderByInput']]
    where: 'NWhereInput'
    cursor: 'NWhereUniqueInput'
    distinct: List['NScalarFieldKeys']
    include: 'NIncludeFromNRecursive2'


class FindManyNArgsFromNRecursive2(TypedDict, total=False):
    """Arguments for N"""
    take: int
    skip: int
    order_by: Union['NOrderByInput', List['NOrderByInput']]
    where: 'NWhereInput'
    cursor: 'NWhereUniqueInput'
    distinct: List['NScalarFieldKeys']
        

class OneOptionalIncludeFromN(TypedDict, total=False):
    """Relational arguments for N"""
    many: Union[bool, 'FindManyManyRequiredArgsFromNRecursive1']


class OneOptionalIncludeFromNRecursive1(TypedDict, total=False):
    """Relational arguments for N"""
    many: Union[bool, 'FindManyManyRequiredArgsFromNRecursive2']


class OneOptionalIncludeFromNRecursive2(TypedDict, total=False):
    """Relational arguments for N"""

    

class OneOptionalArgsFromN(TypedDict, total=False):
    """Arguments for N"""
    include: 'OneOptionalIncludeFromNRecursive1'


class OneOptionalArgsFromNRecursive1(TypedDict, total=False):
    """Arguments for N"""
    include: 'OneOptionalIncludeFromNRecursive2'


class OneOptionalArgsFromNRecursive2(TypedDict, total=False):
    """Arguments for N"""
    
    

class FindManyOneOptionalArgsFromN(TypedDict, total=False):
    """Arguments for N"""
    take: int
    skip: int
    order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
    where: 'OneOptionalWhereInput'
    cursor: 'OneOptionalWhereUniqueInput'
    distinct: List['OneOptionalScalarFieldKeys']
    include: 'OneOptionalIncludeFromNRecursive1'


class FindManyOneOptionalArgsFromNRecursive1(TypedDict, total=False):
    """Arguments for N"""
    take: int
    skip: int
    order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
    where: 'OneOptionalWhereInput'
    cursor: 'OneOptionalWhereUniqueInput'
    distinct: List['OneOptionalScalarFieldKeys']
    include: 'OneOptionalIncludeFromNRecursive2'


class FindManyOneOptionalArgsFromNRecursive2(TypedDict, total=False):
    """Arguments for N"""
    take: int
    skip: int
    order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
    where: 'OneOptionalWhereInput'
    cursor: 'OneOptionalWhereUniqueInput'
    distinct: List['OneOptionalScalarFieldKeys']
        

class ManyRequiredIncludeFromN(TypedDict, total=False):
    """Relational arguments for N"""
    one: Union[bool, 'OneOptionalArgsFromNRecursive1']


class ManyRequiredIncludeFromNRecursive1(TypedDict, total=False):
    """Relational arguments for N"""
    one: Union[bool, 'OneOptionalArgsFromNRecursive2']


class ManyRequiredIncludeFromNRecursive2(TypedDict, total=False):
    """Relational arguments for N"""

    

class ManyRequiredArgsFromN(TypedDict, total=False):
    """Arguments for N"""
    include: 'ManyRequiredIncludeFromNRecursive1'


class ManyRequiredArgsFromNRecursive1(TypedDict, total=False):
    """Arguments for N"""
    include: 'ManyRequiredIncludeFromNRecursive2'


class ManyRequiredArgsFromNRecursive2(TypedDict, total=False):
    """Arguments for N"""
    
    

class FindManyManyRequiredArgsFromN(TypedDict, total=False):
    """Arguments for N"""
    take: int
    skip: int
    order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
    where: 'ManyRequiredWhereInput'
    cursor: 'ManyRequiredWhereUniqueInput'
    distinct: List['ManyRequiredScalarFieldKeys']
    include: 'ManyRequiredIncludeFromNRecursive1'


class FindManyManyRequiredArgsFromNRecursive1(TypedDict, total=False):
    """Arguments for N"""
    take: int
    skip: int
    order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
    where: 'ManyRequiredWhereInput'
    cursor: 'ManyRequiredWhereUniqueInput'
    distinct: List['ManyRequiredScalarFieldKeys']
    include: 'ManyRequiredIncludeFromNRecursive2'


class FindManyManyRequiredArgsFromNRecursive2(TypedDict, total=False):
    """Arguments for N"""
    take: int
    skip: int
    order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
    where: 'ManyRequiredWhereInput'
    cursor: 'ManyRequiredWhereUniqueInput'
    distinct: List['ManyRequiredScalarFieldKeys']
        

class ListsIncludeFromN(TypedDict, total=False):
    """Relational arguments for N"""


class ListsIncludeFromNRecursive1(TypedDict, total=False):
    """Relational arguments for N"""


class ListsIncludeFromNRecursive2(TypedDict, total=False):
    """Relational arguments for N"""

    

class ListsArgsFromN(TypedDict, total=False):
    """Arguments for N"""
    include: 'ListsIncludeFromNRecursive1'


class ListsArgsFromNRecursive1(TypedDict, total=False):
    """Arguments for N"""
    include: 'ListsIncludeFromNRecursive2'


class ListsArgsFromNRecursive2(TypedDict, total=False):
    """Arguments for N"""
    
    

class FindManyListsArgsFromN(TypedDict, total=False):
    """Arguments for N"""
    take: int
    skip: int
    order_by: Union['ListsOrderByInput', List['ListsOrderByInput']]
    where: 'ListsWhereInput'
    cursor: 'ListsWhereUniqueInput'
    distinct: List['ListsScalarFieldKeys']
    include: 'ListsIncludeFromNRecursive1'


class FindManyListsArgsFromNRecursive1(TypedDict, total=False):
    """Arguments for N"""
    take: int
    skip: int
    order_by: Union['ListsOrderByInput', List['ListsOrderByInput']]
    where: 'ListsWhereInput'
    cursor: 'ListsWhereUniqueInput'
    distinct: List['ListsScalarFieldKeys']
    include: 'ListsIncludeFromNRecursive2'


class FindManyListsArgsFromNRecursive2(TypedDict, total=False):
    """Arguments for N"""
    take: int
    skip: int
    order_by: Union['ListsOrderByInput', List['ListsOrderByInput']]
    where: 'ListsWhereInput'
    cursor: 'ListsWhereUniqueInput'
    distinct: List['ListsScalarFieldKeys']
        

class AIncludeFromN(TypedDict, total=False):
    """Relational arguments for N"""


class AIncludeFromNRecursive1(TypedDict, total=False):
    """Relational arguments for N"""


class AIncludeFromNRecursive2(TypedDict, total=False):
    """Relational arguments for N"""

    

class AArgsFromN(TypedDict, total=False):
    """Arguments for N"""
    include: 'AIncludeFromNRecursive1'


class AArgsFromNRecursive1(TypedDict, total=False):
    """Arguments for N"""
    include: 'AIncludeFromNRecursive2'


class AArgsFromNRecursive2(TypedDict, total=False):
    """Arguments for N"""
    
    

class FindManyAArgsFromN(TypedDict, total=False):
    """Arguments for N"""
    take: int
    skip: int
    order_by: Union['AOrderByInput', List['AOrderByInput']]
    where: 'AWhereInput'
    cursor: 'AWhereUniqueInput'
    distinct: List['AScalarFieldKeys']
    include: 'AIncludeFromNRecursive1'


class FindManyAArgsFromNRecursive1(TypedDict, total=False):
    """Arguments for N"""
    take: int
    skip: int
    order_by: Union['AOrderByInput', List['AOrderByInput']]
    where: 'AWhereInput'
    cursor: 'AWhereUniqueInput'
    distinct: List['AScalarFieldKeys']
    include: 'AIncludeFromNRecursive2'


class FindManyAArgsFromNRecursive2(TypedDict, total=False):
    """Arguments for N"""
    take: int
    skip: int
    order_by: Union['AOrderByInput', List['AOrderByInput']]
    where: 'AWhereInput'
    cursor: 'AWhereUniqueInput'
    distinct: List['AScalarFieldKeys']
        

class BIncludeFromN(TypedDict, total=False):
    """Relational arguments for N"""


class BIncludeFromNRecursive1(TypedDict, total=False):
    """Relational arguments for N"""


class BIncludeFromNRecursive2(TypedDict, total=False):
    """Relational arguments for N"""

    

class BArgsFromN(TypedDict, total=False):
    """Arguments for N"""
    include: 'BIncludeFromNRecursive1'


class BArgsFromNRecursive1(TypedDict, total=False):
    """Arguments for N"""
    include: 'BIncludeFromNRecursive2'


class BArgsFromNRecursive2(TypedDict, total=False):
    """Arguments for N"""
    
    

class FindManyBArgsFromN(TypedDict, total=False):
    """Arguments for N"""
    take: int
    skip: int
    order_by: Union['BOrderByInput', List['BOrderByInput']]
    where: 'BWhereInput'
    cursor: 'BWhereUniqueInput'
    distinct: List['BScalarFieldKeys']
    include: 'BIncludeFromNRecursive1'


class FindManyBArgsFromNRecursive1(TypedDict, total=False):
    """Arguments for N"""
    take: int
    skip: int
    order_by: Union['BOrderByInput', List['BOrderByInput']]
    where: 'BWhereInput'
    cursor: 'BWhereUniqueInput'
    distinct: List['BScalarFieldKeys']
    include: 'BIncludeFromNRecursive2'


class FindManyBArgsFromNRecursive2(TypedDict, total=False):
    """Arguments for N"""
    take: int
    skip: int
    order_by: Union['BOrderByInput', List['BOrderByInput']]
    where: 'BWhereInput'
    cursor: 'BWhereUniqueInput'
    distinct: List['BScalarFieldKeys']
        

class CIncludeFromN(TypedDict, total=False):
    """Relational arguments for N"""


class CIncludeFromNRecursive1(TypedDict, total=False):
    """Relational arguments for N"""


class CIncludeFromNRecursive2(TypedDict, total=False):
    """Relational arguments for N"""

    

class CArgsFromN(TypedDict, total=False):
    """Arguments for N"""
    include: 'CIncludeFromNRecursive1'


class CArgsFromNRecursive1(TypedDict, total=False):
    """Arguments for N"""
    include: 'CIncludeFromNRecursive2'


class CArgsFromNRecursive2(TypedDict, total=False):
    """Arguments for N"""
    
    

class FindManyCArgsFromN(TypedDict, total=False):
    """Arguments for N"""
    take: int
    skip: int
    order_by: Union['COrderByInput', List['COrderByInput']]
    where: 'CWhereInput'
    cursor: 'CWhereUniqueInput'
    distinct: List['CScalarFieldKeys']
    include: 'CIncludeFromNRecursive1'


class FindManyCArgsFromNRecursive1(TypedDict, total=False):
    """Arguments for N"""
    take: int
    skip: int
    order_by: Union['COrderByInput', List['COrderByInput']]
    where: 'CWhereInput'
    cursor: 'CWhereUniqueInput'
    distinct: List['CScalarFieldKeys']
    include: 'CIncludeFromNRecursive2'


class FindManyCArgsFromNRecursive2(TypedDict, total=False):
    """Arguments for N"""
    take: int
    skip: int
    order_by: Union['COrderByInput', List['COrderByInput']]
    where: 'CWhereInput'
    cursor: 'CWhereUniqueInput'
    distinct: List['CScalarFieldKeys']
        

class DIncludeFromN(TypedDict, total=False):
    """Relational arguments for N"""


class DIncludeFromNRecursive1(TypedDict, total=False):
    """Relational arguments for N"""


class DIncludeFromNRecursive2(TypedDict, total=False):
    """Relational arguments for N"""

    

class DArgsFromN(TypedDict, total=False):
    """Arguments for N"""
    include: 'DIncludeFromNRecursive1'


class DArgsFromNRecursive1(TypedDict, total=False):
    """Arguments for N"""
    include: 'DIncludeFromNRecursive2'


class DArgsFromNRecursive2(TypedDict, total=False):
    """Arguments for N"""
    
    

class FindManyDArgsFromN(TypedDict, total=False):
    """Arguments for N"""
    take: int
    skip: int
    order_by: Union['DOrderByInput', List['DOrderByInput']]
    where: 'DWhereInput'
    cursor: 'DWhereUniqueInput'
    distinct: List['DScalarFieldKeys']
    include: 'DIncludeFromNRecursive1'


class FindManyDArgsFromNRecursive1(TypedDict, total=False):
    """Arguments for N"""
    take: int
    skip: int
    order_by: Union['DOrderByInput', List['DOrderByInput']]
    where: 'DWhereInput'
    cursor: 'DWhereUniqueInput'
    distinct: List['DScalarFieldKeys']
    include: 'DIncludeFromNRecursive2'


class FindManyDArgsFromNRecursive2(TypedDict, total=False):
    """Arguments for N"""
    take: int
    skip: int
    order_by: Union['DOrderByInput', List['DOrderByInput']]
    where: 'DWhereInput'
    cursor: 'DWhereUniqueInput'
    distinct: List['DScalarFieldKeys']
        

class EIncludeFromN(TypedDict, total=False):
    """Relational arguments for N"""


class EIncludeFromNRecursive1(TypedDict, total=False):
    """Relational arguments for N"""


class EIncludeFromNRecursive2(TypedDict, total=False):
    """Relational arguments for N"""

    

class EArgsFromN(TypedDict, total=False):
    """Arguments for N"""
    include: 'EIncludeFromNRecursive1'


class EArgsFromNRecursive1(TypedDict, total=False):
    """Arguments for N"""
    include: 'EIncludeFromNRecursive2'


class EArgsFromNRecursive2(TypedDict, total=False):
    """Arguments for N"""
    
    

class FindManyEArgsFromN(TypedDict, total=False):
    """Arguments for N"""
    take: int
    skip: int
    order_by: Union['EOrderByInput', List['EOrderByInput']]
    where: 'EWhereInput'
    cursor: 'EWhereUniqueInput'
    distinct: List['EScalarFieldKeys']
    include: 'EIncludeFromNRecursive1'


class FindManyEArgsFromNRecursive1(TypedDict, total=False):
    """Arguments for N"""
    take: int
    skip: int
    order_by: Union['EOrderByInput', List['EOrderByInput']]
    where: 'EWhereInput'
    cursor: 'EWhereUniqueInput'
    distinct: List['EScalarFieldKeys']
    include: 'EIncludeFromNRecursive2'


class FindManyEArgsFromNRecursive2(TypedDict, total=False):
    """Arguments for N"""
    take: int
    skip: int
    order_by: Union['EOrderByInput', List['EOrderByInput']]
    where: 'EWhereInput'
    cursor: 'EWhereUniqueInput'
    distinct: List['EScalarFieldKeys']
    

FindManyNArgs = FindManyNArgsFromN
FindFirstNArgs = FindManyNArgsFromN


    

class NWhereInput(TypedDict, total=False):
    """N arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    m: 'MListRelationFilter'
    int: Union[_int, 'types.IntFilter']
    optional_int: Union[None, _int, 'types.IntFilter']
    float: Union[_float, 'types.FloatFilter']
    optional_float: Union[None, _float, 'types.FloatFilter']
    string: Union[_str, 'types.StringFilter']
    optional_string: Union[None, _str, 'types.StringFilter']
    json_: Union['fields.Json', 'types.JsonFilter']
    optional_json: Union[None, 'fields.Json', 'types.JsonFilter']
    enum: 'enums.ABeautifulEnum'
    optional_enum: 'enums.ABeautifulEnum'
    boolean: Union[_bool, 'types.BooleanFilter']
    optional_boolean: Union[None, _bool, 'types.BooleanFilter']

    # should be noted that AND and NOT should be Union['NWhereInputRecursive1', List['NWhereInputRecursive1']]
    # but this causes mypy to hang :/
    AND: List['NWhereInputRecursive1']
    OR: List['NWhereInputRecursive1']
    NOT: List['NWhereInputRecursive1']


class NWhereInputRecursive1(TypedDict, total=False):
    """N arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    m: 'MListRelationFilter'
    int: Union[_int, 'types.IntFilter']
    optional_int: Union[None, _int, 'types.IntFilter']
    float: Union[_float, 'types.FloatFilter']
    optional_float: Union[None, _float, 'types.FloatFilter']
    string: Union[_str, 'types.StringFilter']
    optional_string: Union[None, _str, 'types.StringFilter']
    json_: Union['fields.Json', 'types.JsonFilter']
    optional_json: Union[None, 'fields.Json', 'types.JsonFilter']
    enum: 'enums.ABeautifulEnum'
    optional_enum: 'enums.ABeautifulEnum'
    boolean: Union[_bool, 'types.BooleanFilter']
    optional_boolean: Union[None, _bool, 'types.BooleanFilter']

    # should be noted that AND and NOT should be Union['NWhereInputRecursive2', List['NWhereInputRecursive2']]
    # but this causes mypy to hang :/
    AND: List['NWhereInputRecursive2']
    OR: List['NWhereInputRecursive2']
    NOT: List['NWhereInputRecursive2']


class NWhereInputRecursive2(TypedDict, total=False):
    """N arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    m: 'MListRelationFilter'
    int: Union[_int, 'types.IntFilter']
    optional_int: Union[None, _int, 'types.IntFilter']
    float: Union[_float, 'types.FloatFilter']
    optional_float: Union[None, _float, 'types.FloatFilter']
    string: Union[_str, 'types.StringFilter']
    optional_string: Union[None, _str, 'types.StringFilter']
    json_: Union['fields.Json', 'types.JsonFilter']
    optional_json: Union[None, 'fields.Json', 'types.JsonFilter']
    enum: 'enums.ABeautifulEnum'
    optional_enum: 'enums.ABeautifulEnum'
    boolean: Union[_bool, 'types.BooleanFilter']
    optional_boolean: Union[None, _bool, 'types.BooleanFilter']



# aggregate N types


    

class NScalarWhereWithAggregatesInput(TypedDict, total=False):
    """N arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    int: Union[_int, 'types.IntWithAggregatesFilter']
    optional_int: Union[_int, 'types.IntWithAggregatesFilter']
    float: Union[_float, 'types.FloatWithAggregatesFilter']
    optional_float: Union[_float, 'types.FloatWithAggregatesFilter']
    string: Union[_str, 'types.StringWithAggregatesFilter']
    optional_string: Union[_str, 'types.StringWithAggregatesFilter']
    json_: Union['fields.Json', 'types.JsonWithAggregatesFilter']
    optional_json: Union['fields.Json', 'types.JsonWithAggregatesFilter']
    enum: 'enums.ABeautifulEnum'
    optional_enum: 'enums.ABeautifulEnum'
    boolean: Union[_bool, 'types.BooleanWithAggregatesFilter']
    optional_boolean: Union[_bool, 'types.BooleanWithAggregatesFilter']

    AND: List['NScalarWhereWithAggregatesInputRecursive1']
    OR: List['NScalarWhereWithAggregatesInputRecursive1']
    NOT: List['NScalarWhereWithAggregatesInputRecursive1']


class NScalarWhereWithAggregatesInputRecursive1(TypedDict, total=False):
    """N arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    int: Union[_int, 'types.IntWithAggregatesFilter']
    optional_int: Union[_int, 'types.IntWithAggregatesFilter']
    float: Union[_float, 'types.FloatWithAggregatesFilter']
    optional_float: Union[_float, 'types.FloatWithAggregatesFilter']
    string: Union[_str, 'types.StringWithAggregatesFilter']
    optional_string: Union[_str, 'types.StringWithAggregatesFilter']
    json_: Union['fields.Json', 'types.JsonWithAggregatesFilter']
    optional_json: Union['fields.Json', 'types.JsonWithAggregatesFilter']
    enum: 'enums.ABeautifulEnum'
    optional_enum: 'enums.ABeautifulEnum'
    boolean: Union[_bool, 'types.BooleanWithAggregatesFilter']
    optional_boolean: Union[_bool, 'types.BooleanWithAggregatesFilter']

    AND: List['NScalarWhereWithAggregatesInputRecursive2']
    OR: List['NScalarWhereWithAggregatesInputRecursive2']
    NOT: List['NScalarWhereWithAggregatesInputRecursive2']


class NScalarWhereWithAggregatesInputRecursive2(TypedDict, total=False):
    """N arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    int: Union[_int, 'types.IntWithAggregatesFilter']
    optional_int: Union[_int, 'types.IntWithAggregatesFilter']
    float: Union[_float, 'types.FloatWithAggregatesFilter']
    optional_float: Union[_float, 'types.FloatWithAggregatesFilter']
    string: Union[_str, 'types.StringWithAggregatesFilter']
    optional_string: Union[_str, 'types.StringWithAggregatesFilter']
    json_: Union['fields.Json', 'types.JsonWithAggregatesFilter']
    optional_json: Union['fields.Json', 'types.JsonWithAggregatesFilter']
    enum: 'enums.ABeautifulEnum'
    optional_enum: 'enums.ABeautifulEnum'
    boolean: Union[_bool, 'types.BooleanWithAggregatesFilter']
    optional_boolean: Union[_bool, 'types.BooleanWithAggregatesFilter']



class NGroupByOutput(TypedDict, total=False):
    id: _int
    int: _int
    optional_int: _int
    float: _float
    optional_float: _float
    string: _str
    optional_string: _str
    json_: 'fields.Json'
    optional_json: 'fields.Json'
    enum: 'enums.ABeautifulEnum'
    optional_enum: 'enums.ABeautifulEnum'
    boolean: _bool
    optional_boolean: _bool
    _sum: 'NSumAggregateOutput'
    _avg: 'NAvgAggregateOutput'
    _min: 'NMinAggregateOutput'
    _max: 'NMaxAggregateOutput'
    _count: 'NCountAggregateOutput'


class NAvgAggregateOutput(TypedDict, total=False):
    """N output for aggregating averages"""
    id: float
    int: float
    optional_int: float
    float: float
    optional_float: float


class NSumAggregateOutput(TypedDict, total=False):
    """N output for aggregating sums"""
    id: _int
    int: _int
    optional_int: _int
    float: _float
    optional_float: _float


class NScalarAggregateOutput(TypedDict, total=False):
    """N output including scalar fields"""
    id: _int
    int: _int
    optional_int: _int
    float: _float
    optional_float: _float
    string: _str
    optional_string: _str
    json_: 'fields.Json'
    optional_json: 'fields.Json'
    enum: 'enums.ABeautifulEnum'
    optional_enum: 'enums.ABeautifulEnum'
    boolean: _bool
    optional_boolean: _bool


NMinAggregateOutput = NScalarAggregateOutput
NMaxAggregateOutput = NScalarAggregateOutput


class NMaxAggregateInput(TypedDict, total=False):
    """N input for aggregating by max"""
    id: bool
    int: bool
    optional_int: bool
    float: bool
    optional_float: bool
    string: bool
    optional_string: bool
    json_: bool
    optional_json: bool
    enum: bool
    optional_enum: bool
    boolean: bool
    optional_boolean: bool


class NMinAggregateInput(TypedDict, total=False):
    """N input for aggregating by min"""
    id: bool
    int: bool
    optional_int: bool
    float: bool
    optional_float: bool
    string: bool
    optional_string: bool
    json_: bool
    optional_json: bool
    enum: bool
    optional_enum: bool
    boolean: bool
    optional_boolean: bool


class NNumberAggregateInput(TypedDict, total=False):
    """N input for aggregating numbers"""
    id: bool
    int: bool
    optional_int: bool
    float: bool
    optional_float: bool


NAvgAggregateInput = NNumberAggregateInput
NSumAggregateInput = NNumberAggregateInput


NCountAggregateInput = TypedDict(
    'NCountAggregateInput',
    {
        'id': bool,
        'int': bool,
        'optional_int': bool,
        'float': bool,
        'optional_float': bool,
        'string': bool,
        'optional_string': bool,
        'json_': bool,
        'optional_json': bool,
        'enum': bool,
        'optional_enum': bool,
        'boolean': bool,
        'optional_boolean': bool,
        '_all': bool,
    },
    total=False,
)

NCountAggregateOutput = TypedDict(
    'NCountAggregateOutput',
    {
        'id': int,
        'int': int,
        'optional_int': int,
        'float': int,
        'optional_float': int,
        'string': int,
        'optional_string': int,
        'json_': int,
        'optional_json': int,
        'enum': int,
        'optional_enum': int,
        'boolean': int,
        'optional_boolean': int,
        '_all': int,
    },
    total=False,
)


NKeys = Literal[
    'id',
    'm',
    'int',
    'optional_int',
    'float',
    'optional_float',
    'string',
    'optional_string',
    'json_',
    'optional_json',
    'enum',
    'optional_enum',
    'boolean',
    'optional_boolean',
]
NScalarFieldKeys = Literal[
    'id',
    'int',
    'optional_int',
    'float',
    'optional_float',
    'string',
    'optional_string',
    'json_',
    'optional_json',
    'enum',
    'optional_enum',
    'boolean',
    'optional_boolean',
]
NScalarFieldKeysT = TypeVar('NScalarFieldKeysT', bound=NScalarFieldKeys)

NRelationalFieldKeys = Literal[
        'm',
    ]


# we have to import ourselves as forward references may use 'types.XFilter' syntax
from .. import enums, types, fields  # noqa: TID251

'''