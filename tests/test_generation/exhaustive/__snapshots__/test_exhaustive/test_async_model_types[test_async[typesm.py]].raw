'''
# -*- coding: utf-8 -*-
# code generated by Prisma. DO NOT EDIT.
# pyright: reportUnusedImport=false
# fmt: off

# global imports for type checking
from typing import (
    TYPE_CHECKING,
    Any,
    Dict,
    List,
    Union,
    Literal,
    TypeVar,
    Optional,
    TypedDict,
)
from builtins import int as _int, str as _str, bool as _bool, float as _float

LiteralString = str
# -- template types/_model.py.jinja --
# Types for model: M

from .atomic import *  # noqa: TID251
from .filters import *  # noqa: TID251
from .list_filters import *  # noqa: TID251

# Cross-import related model types for type checker resolution
if TYPE_CHECKING:
    from .a import (  # noqa: TID251
        AWhereInput,
        AOrderByInput,
        AScalarFieldKeys,
        AWhereUniqueInput,
    )
    from .b import (  # noqa: TID251
        BWhereInput,
        BOrderByInput,
        BScalarFieldKeys,
        BWhereUniqueInput,
    )
    from .c import (  # noqa: TID251
        CWhereInput,
        COrderByInput,
        CScalarFieldKeys,
        CWhereUniqueInput,
    )
    from .d import (  # noqa: TID251
        DWhereInput,
        DOrderByInput,
        DScalarFieldKeys,
        DWhereUniqueInput,
    )
    from .e import (  # noqa: TID251
        EWhereInput,
        EOrderByInput,
        EScalarFieldKeys,
        EWhereUniqueInput,
    )
    from .n import (  # noqa: TID251
        NWhereInput,
        NOrderByInput,
        NScalarFieldKeys,
        NWhereUniqueInput,
        NListRelationFilter,
        NUpdateManyWithoutRelationsInput,
        NCreateManyNestedWithoutRelationsInput,
    )
    from .post import (  # noqa: TID251
        PostWhereInput,
        PostOrderByInput,
        PostScalarFieldKeys,
        PostWhereUniqueInput,
    )
    from .user import (  # noqa: TID251
        UserWhereInput,
        UserOrderByInput,
        UserScalarFieldKeys,
        UserWhereUniqueInput,
    )
    from .lists import (  # noqa: TID251
        ListsWhereInput,
        ListsOrderByInput,
        ListsScalarFieldKeys,
        ListsWhereUniqueInput,
    )
    from .oneoptional import (  # noqa: TID251
        OneOptionalWhereInput,
        OneOptionalOrderByInput,
        OneOptionalScalarFieldKeys,
        OneOptionalWhereUniqueInput,
    )
    from .manyrequired import (  # noqa: TID251
        ManyRequiredWhereInput,
        ManyRequiredOrderByInput,
        ManyRequiredScalarFieldKeys,
        ManyRequiredWhereUniqueInput,
    )





# M types

class MOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the M create method"""
    id: _int
    n: 'NCreateManyNestedWithoutRelationsInput'
    optional_int: Optional[_int]
    optional_float: Optional[_float]
    optional_string: Optional[_str]
    optional_enum: Optional['enums.ABeautifulEnum']
    optional_boolean: Optional[_bool]


class MCreateInput(MOptionalCreateInput):
    """Required arguments to the M create method"""
    int: _int
    float: _float
    string: _str
    enum: 'enums.ABeautifulEnum'
    boolean: _bool


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class MOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the M create method, without relations"""
    id: _int
    optional_int: Optional[_int]
    optional_float: Optional[_float]
    optional_string: Optional[_str]
    optional_enum: Optional['enums.ABeautifulEnum']
    optional_boolean: Optional[_bool]


class MCreateWithoutRelationsInput(MOptionalCreateWithoutRelationsInput):
    """Required arguments to the M create method, without relations"""
    int: _int
    float: _float
    string: _str
    enum: 'enums.ABeautifulEnum'
    boolean: _bool

class MConnectOrCreateWithoutRelationsInput(TypedDict):
    create: 'MCreateWithoutRelationsInput'
    where: 'MWhereUniqueInput'

class MCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'MCreateWithoutRelationsInput'
    connect: 'MWhereUniqueInput'
    connect_or_create: 'MConnectOrCreateWithoutRelationsInput'


class MCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['MCreateWithoutRelationsInput', List['MCreateWithoutRelationsInput']]
    connect: Union['MWhereUniqueInput', List['MWhereUniqueInput']]
    connect_or_create: Union['MConnectOrCreateWithoutRelationsInput', List['MConnectOrCreateWithoutRelationsInput']]

_MWhereUnique_id_Input = TypedDict(
    '_MWhereUnique_id_Input',
    {
        'id': '_int',
    },
    total=True
)

MWhereUniqueInput = _MWhereUnique_id_Input


class MUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: Union[AtomicIntInput, _int]
    n: 'NUpdateManyWithoutRelationsInput'
    int: Union[AtomicIntInput, _int]
    optional_int: Optional[Union[AtomicIntInput, _int]]
    float: Union[AtomicFloatInput, _float]
    optional_float: Optional[Union[AtomicFloatInput, _float]]
    string: _str
    optional_string: Optional[_str]
    enum: 'enums.ABeautifulEnum'
    optional_enum: Optional['enums.ABeautifulEnum']
    boolean: _bool
    optional_boolean: Optional[_bool]


class MUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: Union[AtomicIntInput, _int]
    int: Union[AtomicIntInput, _int]
    optional_int: Optional[Union[AtomicIntInput, _int]]
    float: Union[AtomicFloatInput, _float]
    optional_float: Optional[Union[AtomicFloatInput, _float]]
    string: _str
    optional_string: Optional[_str]
    enum: 'enums.ABeautifulEnum'
    optional_enum: Optional['enums.ABeautifulEnum']
    boolean: _bool
    optional_boolean: Optional[_bool]


class MUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['MCreateWithoutRelationsInput']
    connect: List['MWhereUniqueInput']
    connect_or_create: List['MConnectOrCreateWithoutRelationsInput']
    set: List['MWhereUniqueInput']
    disconnect: List['MWhereUniqueInput']
    delete: List['MWhereUniqueInput']

    # TODO
    # update: List['MUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['MUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['MScalarWhereInput']
    # upsert: List['MUpserteWithWhereUniqueWithoutRelationsInput']


class MUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'MCreateWithoutRelationsInput'
    connect: 'MWhereUniqueInput'
    connect_or_create: 'MConnectOrCreateWithoutRelationsInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'MUpdateInput'
    # upsert: 'MUpsertWithoutRelationsInput'


class MUpsertInput(TypedDict):
    create: 'MCreateInput'
    update: 'MUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_M_id_OrderByInput = TypedDict(
    '_M_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_M_int_OrderByInput = TypedDict(
    '_M_int_OrderByInput',
    {
        'int': 'SortOrder',
    },
    total=True
)

_M_optional_int_OrderByInput = TypedDict(
    '_M_optional_int_OrderByInput',
    {
        'optional_int': 'SortOrder',
    },
    total=True
)

_M_float_OrderByInput = TypedDict(
    '_M_float_OrderByInput',
    {
        'float': 'SortOrder',
    },
    total=True
)

_M_optional_float_OrderByInput = TypedDict(
    '_M_optional_float_OrderByInput',
    {
        'optional_float': 'SortOrder',
    },
    total=True
)

_M_string_OrderByInput = TypedDict(
    '_M_string_OrderByInput',
    {
        'string': 'SortOrder',
    },
    total=True
)

_M_optional_string_OrderByInput = TypedDict(
    '_M_optional_string_OrderByInput',
    {
        'optional_string': 'SortOrder',
    },
    total=True
)

_M_enum_OrderByInput = TypedDict(
    '_M_enum_OrderByInput',
    {
        'enum': 'SortOrder',
    },
    total=True
)

_M_optional_enum_OrderByInput = TypedDict(
    '_M_optional_enum_OrderByInput',
    {
        'optional_enum': 'SortOrder',
    },
    total=True
)

_M_boolean_OrderByInput = TypedDict(
    '_M_boolean_OrderByInput',
    {
        'boolean': 'SortOrder',
    },
    total=True
)

_M_optional_boolean_OrderByInput = TypedDict(
    '_M_optional_boolean_OrderByInput',
    {
        'optional_boolean': 'SortOrder',
    },
    total=True
)

_M_RelevanceInner = TypedDict(
    '_M_RelevanceInner',
    {
        'fields': 'List[MScalarFieldKeys]',
        'search': 'str',
        'sort': 'SortOrder',
    },
    total=True
)

_M_RelevanceOrderByInput = TypedDict(
    '_M_RelevanceOrderByInput',
    {
        '_relevance': '_M_RelevanceInner',
    },
    total=True
)

MOrderByInput = Union[
    '_M_id_OrderByInput',
    '_M_int_OrderByInput',
    '_M_optional_int_OrderByInput',
    '_M_float_OrderByInput',
    '_M_optional_float_OrderByInput',
    '_M_string_OrderByInput',
    '_M_optional_string_OrderByInput',
    '_M_enum_OrderByInput',
    '_M_optional_enum_OrderByInput',
    '_M_boolean_OrderByInput',
    '_M_optional_boolean_OrderByInput',
    '_M_RelevanceOrderByInput',
]



# recursive M types
# TODO: cleanup these types


# Dict[str, Any] is a mypy limitation
# see https://github.com/RobertCraigie/prisma-client-py/issues/45
# switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/stable/reference/limitations/

MRelationFilter = TypedDict(
    'MRelationFilter',
    {
        'is': 'Dict[str, Any]',
        'is_not': 'Dict[str, Any]',
    },
    total=False,
)


class MListRelationFilter(TypedDict, total=False):
    some: 'Dict[str, Any]'
    none: 'Dict[str, Any]'
    every: 'Dict[str, Any]'


class MInclude(TypedDict, total=False):
    """M relational arguments"""
    n: Union[bool, 'FindManyNArgsFromM']


    

class PostIncludeFromM(TypedDict, total=False):
    """Relational arguments for M"""
    author: Union[bool, 'UserArgsFromMRecursive1']


class PostIncludeFromMRecursive1(TypedDict, total=False):
    """Relational arguments for M"""
    author: Union[bool, 'UserArgsFromMRecursive2']


class PostIncludeFromMRecursive2(TypedDict, total=False):
    """Relational arguments for M"""

    

class PostArgsFromM(TypedDict, total=False):
    """Arguments for M"""
    include: 'PostIncludeFromMRecursive1'


class PostArgsFromMRecursive1(TypedDict, total=False):
    """Arguments for M"""
    include: 'PostIncludeFromMRecursive2'


class PostArgsFromMRecursive2(TypedDict, total=False):
    """Arguments for M"""
    
    

class FindManyPostArgsFromM(TypedDict, total=False):
    """Arguments for M"""
    take: int
    skip: int
    order_by: Union['PostOrderByInput', List['PostOrderByInput']]
    where: 'PostWhereInput'
    cursor: 'PostWhereUniqueInput'
    distinct: List['PostScalarFieldKeys']
    include: 'PostIncludeFromMRecursive1'


class FindManyPostArgsFromMRecursive1(TypedDict, total=False):
    """Arguments for M"""
    take: int
    skip: int
    order_by: Union['PostOrderByInput', List['PostOrderByInput']]
    where: 'PostWhereInput'
    cursor: 'PostWhereUniqueInput'
    distinct: List['PostScalarFieldKeys']
    include: 'PostIncludeFromMRecursive2'


class FindManyPostArgsFromMRecursive2(TypedDict, total=False):
    """Arguments for M"""
    take: int
    skip: int
    order_by: Union['PostOrderByInput', List['PostOrderByInput']]
    where: 'PostWhereInput'
    cursor: 'PostWhereUniqueInput'
    distinct: List['PostScalarFieldKeys']
        

class UserIncludeFromM(TypedDict, total=False):
    """Relational arguments for M"""
    posts: Union[bool, 'FindManyPostArgsFromMRecursive1']


class UserIncludeFromMRecursive1(TypedDict, total=False):
    """Relational arguments for M"""
    posts: Union[bool, 'FindManyPostArgsFromMRecursive2']


class UserIncludeFromMRecursive2(TypedDict, total=False):
    """Relational arguments for M"""

    

class UserArgsFromM(TypedDict, total=False):
    """Arguments for M"""
    include: 'UserIncludeFromMRecursive1'


class UserArgsFromMRecursive1(TypedDict, total=False):
    """Arguments for M"""
    include: 'UserIncludeFromMRecursive2'


class UserArgsFromMRecursive2(TypedDict, total=False):
    """Arguments for M"""
    
    

class FindManyUserArgsFromM(TypedDict, total=False):
    """Arguments for M"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromMRecursive1'


class FindManyUserArgsFromMRecursive1(TypedDict, total=False):
    """Arguments for M"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromMRecursive2'


class FindManyUserArgsFromMRecursive2(TypedDict, total=False):
    """Arguments for M"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
        

class MIncludeFromM(TypedDict, total=False):
    """Relational arguments for M"""
    n: Union[bool, 'FindManyNArgsFromMRecursive1']


class MIncludeFromMRecursive1(TypedDict, total=False):
    """Relational arguments for M"""
    n: Union[bool, 'FindManyNArgsFromMRecursive2']


class MIncludeFromMRecursive2(TypedDict, total=False):
    """Relational arguments for M"""

    

class MArgsFromM(TypedDict, total=False):
    """Arguments for M"""
    include: 'MIncludeFromMRecursive1'


class MArgsFromMRecursive1(TypedDict, total=False):
    """Arguments for M"""
    include: 'MIncludeFromMRecursive2'


class MArgsFromMRecursive2(TypedDict, total=False):
    """Arguments for M"""
    
    

class FindManyMArgsFromM(TypedDict, total=False):
    """Arguments for M"""
    take: int
    skip: int
    order_by: Union['MOrderByInput', List['MOrderByInput']]
    where: 'MWhereInput'
    cursor: 'MWhereUniqueInput'
    distinct: List['MScalarFieldKeys']
    include: 'MIncludeFromMRecursive1'


class FindManyMArgsFromMRecursive1(TypedDict, total=False):
    """Arguments for M"""
    take: int
    skip: int
    order_by: Union['MOrderByInput', List['MOrderByInput']]
    where: 'MWhereInput'
    cursor: 'MWhereUniqueInput'
    distinct: List['MScalarFieldKeys']
    include: 'MIncludeFromMRecursive2'


class FindManyMArgsFromMRecursive2(TypedDict, total=False):
    """Arguments for M"""
    take: int
    skip: int
    order_by: Union['MOrderByInput', List['MOrderByInput']]
    where: 'MWhereInput'
    cursor: 'MWhereUniqueInput'
    distinct: List['MScalarFieldKeys']
        

class NIncludeFromM(TypedDict, total=False):
    """Relational arguments for M"""
    m: Union[bool, 'FindManyMArgsFromMRecursive1']


class NIncludeFromMRecursive1(TypedDict, total=False):
    """Relational arguments for M"""
    m: Union[bool, 'FindManyMArgsFromMRecursive2']


class NIncludeFromMRecursive2(TypedDict, total=False):
    """Relational arguments for M"""

    

class NArgsFromM(TypedDict, total=False):
    """Arguments for M"""
    include: 'NIncludeFromMRecursive1'


class NArgsFromMRecursive1(TypedDict, total=False):
    """Arguments for M"""
    include: 'NIncludeFromMRecursive2'


class NArgsFromMRecursive2(TypedDict, total=False):
    """Arguments for M"""
    
    

class FindManyNArgsFromM(TypedDict, total=False):
    """Arguments for M"""
    take: int
    skip: int
    order_by: Union['NOrderByInput', List['NOrderByInput']]
    where: 'NWhereInput'
    cursor: 'NWhereUniqueInput'
    distinct: List['NScalarFieldKeys']
    include: 'NIncludeFromMRecursive1'


class FindManyNArgsFromMRecursive1(TypedDict, total=False):
    """Arguments for M"""
    take: int
    skip: int
    order_by: Union['NOrderByInput', List['NOrderByInput']]
    where: 'NWhereInput'
    cursor: 'NWhereUniqueInput'
    distinct: List['NScalarFieldKeys']
    include: 'NIncludeFromMRecursive2'


class FindManyNArgsFromMRecursive2(TypedDict, total=False):
    """Arguments for M"""
    take: int
    skip: int
    order_by: Union['NOrderByInput', List['NOrderByInput']]
    where: 'NWhereInput'
    cursor: 'NWhereUniqueInput'
    distinct: List['NScalarFieldKeys']
        

class OneOptionalIncludeFromM(TypedDict, total=False):
    """Relational arguments for M"""
    many: Union[bool, 'FindManyManyRequiredArgsFromMRecursive1']


class OneOptionalIncludeFromMRecursive1(TypedDict, total=False):
    """Relational arguments for M"""
    many: Union[bool, 'FindManyManyRequiredArgsFromMRecursive2']


class OneOptionalIncludeFromMRecursive2(TypedDict, total=False):
    """Relational arguments for M"""

    

class OneOptionalArgsFromM(TypedDict, total=False):
    """Arguments for M"""
    include: 'OneOptionalIncludeFromMRecursive1'


class OneOptionalArgsFromMRecursive1(TypedDict, total=False):
    """Arguments for M"""
    include: 'OneOptionalIncludeFromMRecursive2'


class OneOptionalArgsFromMRecursive2(TypedDict, total=False):
    """Arguments for M"""
    
    

class FindManyOneOptionalArgsFromM(TypedDict, total=False):
    """Arguments for M"""
    take: int
    skip: int
    order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
    where: 'OneOptionalWhereInput'
    cursor: 'OneOptionalWhereUniqueInput'
    distinct: List['OneOptionalScalarFieldKeys']
    include: 'OneOptionalIncludeFromMRecursive1'


class FindManyOneOptionalArgsFromMRecursive1(TypedDict, total=False):
    """Arguments for M"""
    take: int
    skip: int
    order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
    where: 'OneOptionalWhereInput'
    cursor: 'OneOptionalWhereUniqueInput'
    distinct: List['OneOptionalScalarFieldKeys']
    include: 'OneOptionalIncludeFromMRecursive2'


class FindManyOneOptionalArgsFromMRecursive2(TypedDict, total=False):
    """Arguments for M"""
    take: int
    skip: int
    order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
    where: 'OneOptionalWhereInput'
    cursor: 'OneOptionalWhereUniqueInput'
    distinct: List['OneOptionalScalarFieldKeys']
        

class ManyRequiredIncludeFromM(TypedDict, total=False):
    """Relational arguments for M"""
    one: Union[bool, 'OneOptionalArgsFromMRecursive1']


class ManyRequiredIncludeFromMRecursive1(TypedDict, total=False):
    """Relational arguments for M"""
    one: Union[bool, 'OneOptionalArgsFromMRecursive2']


class ManyRequiredIncludeFromMRecursive2(TypedDict, total=False):
    """Relational arguments for M"""

    

class ManyRequiredArgsFromM(TypedDict, total=False):
    """Arguments for M"""
    include: 'ManyRequiredIncludeFromMRecursive1'


class ManyRequiredArgsFromMRecursive1(TypedDict, total=False):
    """Arguments for M"""
    include: 'ManyRequiredIncludeFromMRecursive2'


class ManyRequiredArgsFromMRecursive2(TypedDict, total=False):
    """Arguments for M"""
    
    

class FindManyManyRequiredArgsFromM(TypedDict, total=False):
    """Arguments for M"""
    take: int
    skip: int
    order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
    where: 'ManyRequiredWhereInput'
    cursor: 'ManyRequiredWhereUniqueInput'
    distinct: List['ManyRequiredScalarFieldKeys']
    include: 'ManyRequiredIncludeFromMRecursive1'


class FindManyManyRequiredArgsFromMRecursive1(TypedDict, total=False):
    """Arguments for M"""
    take: int
    skip: int
    order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
    where: 'ManyRequiredWhereInput'
    cursor: 'ManyRequiredWhereUniqueInput'
    distinct: List['ManyRequiredScalarFieldKeys']
    include: 'ManyRequiredIncludeFromMRecursive2'


class FindManyManyRequiredArgsFromMRecursive2(TypedDict, total=False):
    """Arguments for M"""
    take: int
    skip: int
    order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
    where: 'ManyRequiredWhereInput'
    cursor: 'ManyRequiredWhereUniqueInput'
    distinct: List['ManyRequiredScalarFieldKeys']
        

class ListsIncludeFromM(TypedDict, total=False):
    """Relational arguments for M"""


class ListsIncludeFromMRecursive1(TypedDict, total=False):
    """Relational arguments for M"""


class ListsIncludeFromMRecursive2(TypedDict, total=False):
    """Relational arguments for M"""

    

class ListsArgsFromM(TypedDict, total=False):
    """Arguments for M"""
    include: 'ListsIncludeFromMRecursive1'


class ListsArgsFromMRecursive1(TypedDict, total=False):
    """Arguments for M"""
    include: 'ListsIncludeFromMRecursive2'


class ListsArgsFromMRecursive2(TypedDict, total=False):
    """Arguments for M"""
    
    

class FindManyListsArgsFromM(TypedDict, total=False):
    """Arguments for M"""
    take: int
    skip: int
    order_by: Union['ListsOrderByInput', List['ListsOrderByInput']]
    where: 'ListsWhereInput'
    cursor: 'ListsWhereUniqueInput'
    distinct: List['ListsScalarFieldKeys']
    include: 'ListsIncludeFromMRecursive1'


class FindManyListsArgsFromMRecursive1(TypedDict, total=False):
    """Arguments for M"""
    take: int
    skip: int
    order_by: Union['ListsOrderByInput', List['ListsOrderByInput']]
    where: 'ListsWhereInput'
    cursor: 'ListsWhereUniqueInput'
    distinct: List['ListsScalarFieldKeys']
    include: 'ListsIncludeFromMRecursive2'


class FindManyListsArgsFromMRecursive2(TypedDict, total=False):
    """Arguments for M"""
    take: int
    skip: int
    order_by: Union['ListsOrderByInput', List['ListsOrderByInput']]
    where: 'ListsWhereInput'
    cursor: 'ListsWhereUniqueInput'
    distinct: List['ListsScalarFieldKeys']
        

class AIncludeFromM(TypedDict, total=False):
    """Relational arguments for M"""


class AIncludeFromMRecursive1(TypedDict, total=False):
    """Relational arguments for M"""


class AIncludeFromMRecursive2(TypedDict, total=False):
    """Relational arguments for M"""

    

class AArgsFromM(TypedDict, total=False):
    """Arguments for M"""
    include: 'AIncludeFromMRecursive1'


class AArgsFromMRecursive1(TypedDict, total=False):
    """Arguments for M"""
    include: 'AIncludeFromMRecursive2'


class AArgsFromMRecursive2(TypedDict, total=False):
    """Arguments for M"""
    
    

class FindManyAArgsFromM(TypedDict, total=False):
    """Arguments for M"""
    take: int
    skip: int
    order_by: Union['AOrderByInput', List['AOrderByInput']]
    where: 'AWhereInput'
    cursor: 'AWhereUniqueInput'
    distinct: List['AScalarFieldKeys']
    include: 'AIncludeFromMRecursive1'


class FindManyAArgsFromMRecursive1(TypedDict, total=False):
    """Arguments for M"""
    take: int
    skip: int
    order_by: Union['AOrderByInput', List['AOrderByInput']]
    where: 'AWhereInput'
    cursor: 'AWhereUniqueInput'
    distinct: List['AScalarFieldKeys']
    include: 'AIncludeFromMRecursive2'


class FindManyAArgsFromMRecursive2(TypedDict, total=False):
    """Arguments for M"""
    take: int
    skip: int
    order_by: Union['AOrderByInput', List['AOrderByInput']]
    where: 'AWhereInput'
    cursor: 'AWhereUniqueInput'
    distinct: List['AScalarFieldKeys']
        

class BIncludeFromM(TypedDict, total=False):
    """Relational arguments for M"""


class BIncludeFromMRecursive1(TypedDict, total=False):
    """Relational arguments for M"""


class BIncludeFromMRecursive2(TypedDict, total=False):
    """Relational arguments for M"""

    

class BArgsFromM(TypedDict, total=False):
    """Arguments for M"""
    include: 'BIncludeFromMRecursive1'


class BArgsFromMRecursive1(TypedDict, total=False):
    """Arguments for M"""
    include: 'BIncludeFromMRecursive2'


class BArgsFromMRecursive2(TypedDict, total=False):
    """Arguments for M"""
    
    

class FindManyBArgsFromM(TypedDict, total=False):
    """Arguments for M"""
    take: int
    skip: int
    order_by: Union['BOrderByInput', List['BOrderByInput']]
    where: 'BWhereInput'
    cursor: 'BWhereUniqueInput'
    distinct: List['BScalarFieldKeys']
    include: 'BIncludeFromMRecursive1'


class FindManyBArgsFromMRecursive1(TypedDict, total=False):
    """Arguments for M"""
    take: int
    skip: int
    order_by: Union['BOrderByInput', List['BOrderByInput']]
    where: 'BWhereInput'
    cursor: 'BWhereUniqueInput'
    distinct: List['BScalarFieldKeys']
    include: 'BIncludeFromMRecursive2'


class FindManyBArgsFromMRecursive2(TypedDict, total=False):
    """Arguments for M"""
    take: int
    skip: int
    order_by: Union['BOrderByInput', List['BOrderByInput']]
    where: 'BWhereInput'
    cursor: 'BWhereUniqueInput'
    distinct: List['BScalarFieldKeys']
        

class CIncludeFromM(TypedDict, total=False):
    """Relational arguments for M"""


class CIncludeFromMRecursive1(TypedDict, total=False):
    """Relational arguments for M"""


class CIncludeFromMRecursive2(TypedDict, total=False):
    """Relational arguments for M"""

    

class CArgsFromM(TypedDict, total=False):
    """Arguments for M"""
    include: 'CIncludeFromMRecursive1'


class CArgsFromMRecursive1(TypedDict, total=False):
    """Arguments for M"""
    include: 'CIncludeFromMRecursive2'


class CArgsFromMRecursive2(TypedDict, total=False):
    """Arguments for M"""
    
    

class FindManyCArgsFromM(TypedDict, total=False):
    """Arguments for M"""
    take: int
    skip: int
    order_by: Union['COrderByInput', List['COrderByInput']]
    where: 'CWhereInput'
    cursor: 'CWhereUniqueInput'
    distinct: List['CScalarFieldKeys']
    include: 'CIncludeFromMRecursive1'


class FindManyCArgsFromMRecursive1(TypedDict, total=False):
    """Arguments for M"""
    take: int
    skip: int
    order_by: Union['COrderByInput', List['COrderByInput']]
    where: 'CWhereInput'
    cursor: 'CWhereUniqueInput'
    distinct: List['CScalarFieldKeys']
    include: 'CIncludeFromMRecursive2'


class FindManyCArgsFromMRecursive2(TypedDict, total=False):
    """Arguments for M"""
    take: int
    skip: int
    order_by: Union['COrderByInput', List['COrderByInput']]
    where: 'CWhereInput'
    cursor: 'CWhereUniqueInput'
    distinct: List['CScalarFieldKeys']
        

class DIncludeFromM(TypedDict, total=False):
    """Relational arguments for M"""


class DIncludeFromMRecursive1(TypedDict, total=False):
    """Relational arguments for M"""


class DIncludeFromMRecursive2(TypedDict, total=False):
    """Relational arguments for M"""

    

class DArgsFromM(TypedDict, total=False):
    """Arguments for M"""
    include: 'DIncludeFromMRecursive1'


class DArgsFromMRecursive1(TypedDict, total=False):
    """Arguments for M"""
    include: 'DIncludeFromMRecursive2'


class DArgsFromMRecursive2(TypedDict, total=False):
    """Arguments for M"""
    
    

class FindManyDArgsFromM(TypedDict, total=False):
    """Arguments for M"""
    take: int
    skip: int
    order_by: Union['DOrderByInput', List['DOrderByInput']]
    where: 'DWhereInput'
    cursor: 'DWhereUniqueInput'
    distinct: List['DScalarFieldKeys']
    include: 'DIncludeFromMRecursive1'


class FindManyDArgsFromMRecursive1(TypedDict, total=False):
    """Arguments for M"""
    take: int
    skip: int
    order_by: Union['DOrderByInput', List['DOrderByInput']]
    where: 'DWhereInput'
    cursor: 'DWhereUniqueInput'
    distinct: List['DScalarFieldKeys']
    include: 'DIncludeFromMRecursive2'


class FindManyDArgsFromMRecursive2(TypedDict, total=False):
    """Arguments for M"""
    take: int
    skip: int
    order_by: Union['DOrderByInput', List['DOrderByInput']]
    where: 'DWhereInput'
    cursor: 'DWhereUniqueInput'
    distinct: List['DScalarFieldKeys']
        

class EIncludeFromM(TypedDict, total=False):
    """Relational arguments for M"""


class EIncludeFromMRecursive1(TypedDict, total=False):
    """Relational arguments for M"""


class EIncludeFromMRecursive2(TypedDict, total=False):
    """Relational arguments for M"""

    

class EArgsFromM(TypedDict, total=False):
    """Arguments for M"""
    include: 'EIncludeFromMRecursive1'


class EArgsFromMRecursive1(TypedDict, total=False):
    """Arguments for M"""
    include: 'EIncludeFromMRecursive2'


class EArgsFromMRecursive2(TypedDict, total=False):
    """Arguments for M"""
    
    

class FindManyEArgsFromM(TypedDict, total=False):
    """Arguments for M"""
    take: int
    skip: int
    order_by: Union['EOrderByInput', List['EOrderByInput']]
    where: 'EWhereInput'
    cursor: 'EWhereUniqueInput'
    distinct: List['EScalarFieldKeys']
    include: 'EIncludeFromMRecursive1'


class FindManyEArgsFromMRecursive1(TypedDict, total=False):
    """Arguments for M"""
    take: int
    skip: int
    order_by: Union['EOrderByInput', List['EOrderByInput']]
    where: 'EWhereInput'
    cursor: 'EWhereUniqueInput'
    distinct: List['EScalarFieldKeys']
    include: 'EIncludeFromMRecursive2'


class FindManyEArgsFromMRecursive2(TypedDict, total=False):
    """Arguments for M"""
    take: int
    skip: int
    order_by: Union['EOrderByInput', List['EOrderByInput']]
    where: 'EWhereInput'
    cursor: 'EWhereUniqueInput'
    distinct: List['EScalarFieldKeys']
    

FindManyMArgs = FindManyMArgsFromM
FindFirstMArgs = FindManyMArgsFromM


    

class MWhereInput(TypedDict, total=False):
    """M arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    n: 'NListRelationFilter'
    int: Union[_int, 'types.IntFilter']
    optional_int: Union[None, _int, 'types.IntFilter']
    float: Union[_float, 'types.FloatFilter']
    optional_float: Union[None, _float, 'types.FloatFilter']
    string: Union[_str, 'types.StringFilter']
    optional_string: Union[None, _str, 'types.StringFilter']
    enum: 'enums.ABeautifulEnum'
    optional_enum: 'enums.ABeautifulEnum'
    boolean: Union[_bool, 'types.BooleanFilter']
    optional_boolean: Union[None, _bool, 'types.BooleanFilter']

    # should be noted that AND and NOT should be Union['MWhereInputRecursive1', List['MWhereInputRecursive1']]
    # but this causes mypy to hang :/
    AND: List['MWhereInputRecursive1']
    OR: List['MWhereInputRecursive1']
    NOT: List['MWhereInputRecursive1']


class MWhereInputRecursive1(TypedDict, total=False):
    """M arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    n: 'NListRelationFilter'
    int: Union[_int, 'types.IntFilter']
    optional_int: Union[None, _int, 'types.IntFilter']
    float: Union[_float, 'types.FloatFilter']
    optional_float: Union[None, _float, 'types.FloatFilter']
    string: Union[_str, 'types.StringFilter']
    optional_string: Union[None, _str, 'types.StringFilter']
    enum: 'enums.ABeautifulEnum'
    optional_enum: 'enums.ABeautifulEnum'
    boolean: Union[_bool, 'types.BooleanFilter']
    optional_boolean: Union[None, _bool, 'types.BooleanFilter']

    # should be noted that AND and NOT should be Union['MWhereInputRecursive2', List['MWhereInputRecursive2']]
    # but this causes mypy to hang :/
    AND: List['MWhereInputRecursive2']
    OR: List['MWhereInputRecursive2']
    NOT: List['MWhereInputRecursive2']


class MWhereInputRecursive2(TypedDict, total=False):
    """M arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    n: 'NListRelationFilter'
    int: Union[_int, 'types.IntFilter']
    optional_int: Union[None, _int, 'types.IntFilter']
    float: Union[_float, 'types.FloatFilter']
    optional_float: Union[None, _float, 'types.FloatFilter']
    string: Union[_str, 'types.StringFilter']
    optional_string: Union[None, _str, 'types.StringFilter']
    enum: 'enums.ABeautifulEnum'
    optional_enum: 'enums.ABeautifulEnum'
    boolean: Union[_bool, 'types.BooleanFilter']
    optional_boolean: Union[None, _bool, 'types.BooleanFilter']



# aggregate M types


    

class MScalarWhereWithAggregatesInput(TypedDict, total=False):
    """M arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    int: Union[_int, 'types.IntWithAggregatesFilter']
    optional_int: Union[_int, 'types.IntWithAggregatesFilter']
    float: Union[_float, 'types.FloatWithAggregatesFilter']
    optional_float: Union[_float, 'types.FloatWithAggregatesFilter']
    string: Union[_str, 'types.StringWithAggregatesFilter']
    optional_string: Union[_str, 'types.StringWithAggregatesFilter']
    enum: 'enums.ABeautifulEnum'
    optional_enum: 'enums.ABeautifulEnum'
    boolean: Union[_bool, 'types.BooleanWithAggregatesFilter']
    optional_boolean: Union[_bool, 'types.BooleanWithAggregatesFilter']

    AND: List['MScalarWhereWithAggregatesInputRecursive1']
    OR: List['MScalarWhereWithAggregatesInputRecursive1']
    NOT: List['MScalarWhereWithAggregatesInputRecursive1']


class MScalarWhereWithAggregatesInputRecursive1(TypedDict, total=False):
    """M arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    int: Union[_int, 'types.IntWithAggregatesFilter']
    optional_int: Union[_int, 'types.IntWithAggregatesFilter']
    float: Union[_float, 'types.FloatWithAggregatesFilter']
    optional_float: Union[_float, 'types.FloatWithAggregatesFilter']
    string: Union[_str, 'types.StringWithAggregatesFilter']
    optional_string: Union[_str, 'types.StringWithAggregatesFilter']
    enum: 'enums.ABeautifulEnum'
    optional_enum: 'enums.ABeautifulEnum'
    boolean: Union[_bool, 'types.BooleanWithAggregatesFilter']
    optional_boolean: Union[_bool, 'types.BooleanWithAggregatesFilter']

    AND: List['MScalarWhereWithAggregatesInputRecursive2']
    OR: List['MScalarWhereWithAggregatesInputRecursive2']
    NOT: List['MScalarWhereWithAggregatesInputRecursive2']


class MScalarWhereWithAggregatesInputRecursive2(TypedDict, total=False):
    """M arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    int: Union[_int, 'types.IntWithAggregatesFilter']
    optional_int: Union[_int, 'types.IntWithAggregatesFilter']
    float: Union[_float, 'types.FloatWithAggregatesFilter']
    optional_float: Union[_float, 'types.FloatWithAggregatesFilter']
    string: Union[_str, 'types.StringWithAggregatesFilter']
    optional_string: Union[_str, 'types.StringWithAggregatesFilter']
    enum: 'enums.ABeautifulEnum'
    optional_enum: 'enums.ABeautifulEnum'
    boolean: Union[_bool, 'types.BooleanWithAggregatesFilter']
    optional_boolean: Union[_bool, 'types.BooleanWithAggregatesFilter']



class MGroupByOutput(TypedDict, total=False):
    id: _int
    int: _int
    optional_int: _int
    float: _float
    optional_float: _float
    string: _str
    optional_string: _str
    enum: 'enums.ABeautifulEnum'
    optional_enum: 'enums.ABeautifulEnum'
    boolean: _bool
    optional_boolean: _bool
    _sum: 'MSumAggregateOutput'
    _avg: 'MAvgAggregateOutput'
    _min: 'MMinAggregateOutput'
    _max: 'MMaxAggregateOutput'
    _count: 'MCountAggregateOutput'


class MAvgAggregateOutput(TypedDict, total=False):
    """M output for aggregating averages"""
    id: float
    int: float
    optional_int: float
    float: float
    optional_float: float


class MSumAggregateOutput(TypedDict, total=False):
    """M output for aggregating sums"""
    id: _int
    int: _int
    optional_int: _int
    float: _float
    optional_float: _float


class MScalarAggregateOutput(TypedDict, total=False):
    """M output including scalar fields"""
    id: _int
    int: _int
    optional_int: _int
    float: _float
    optional_float: _float
    string: _str
    optional_string: _str
    enum: 'enums.ABeautifulEnum'
    optional_enum: 'enums.ABeautifulEnum'
    boolean: _bool
    optional_boolean: _bool


MMinAggregateOutput = MScalarAggregateOutput
MMaxAggregateOutput = MScalarAggregateOutput


class MMaxAggregateInput(TypedDict, total=False):
    """M input for aggregating by max"""
    id: bool
    int: bool
    optional_int: bool
    float: bool
    optional_float: bool
    string: bool
    optional_string: bool
    enum: bool
    optional_enum: bool
    boolean: bool
    optional_boolean: bool


class MMinAggregateInput(TypedDict, total=False):
    """M input for aggregating by min"""
    id: bool
    int: bool
    optional_int: bool
    float: bool
    optional_float: bool
    string: bool
    optional_string: bool
    enum: bool
    optional_enum: bool
    boolean: bool
    optional_boolean: bool


class MNumberAggregateInput(TypedDict, total=False):
    """M input for aggregating numbers"""
    id: bool
    int: bool
    optional_int: bool
    float: bool
    optional_float: bool


MAvgAggregateInput = MNumberAggregateInput
MSumAggregateInput = MNumberAggregateInput


MCountAggregateInput = TypedDict(
    'MCountAggregateInput',
    {
        'id': bool,
        'int': bool,
        'optional_int': bool,
        'float': bool,
        'optional_float': bool,
        'string': bool,
        'optional_string': bool,
        'enum': bool,
        'optional_enum': bool,
        'boolean': bool,
        'optional_boolean': bool,
        '_all': bool,
    },
    total=False,
)

MCountAggregateOutput = TypedDict(
    'MCountAggregateOutput',
    {
        'id': int,
        'int': int,
        'optional_int': int,
        'float': int,
        'optional_float': int,
        'string': int,
        'optional_string': int,
        'enum': int,
        'optional_enum': int,
        'boolean': int,
        'optional_boolean': int,
        '_all': int,
    },
    total=False,
)


MKeys = Literal[
    'id',
    'n',
    'int',
    'optional_int',
    'float',
    'optional_float',
    'string',
    'optional_string',
    'enum',
    'optional_enum',
    'boolean',
    'optional_boolean',
]
MScalarFieldKeys = Literal[
    'id',
    'int',
    'optional_int',
    'float',
    'optional_float',
    'string',
    'optional_string',
    'enum',
    'optional_enum',
    'boolean',
    'optional_boolean',
]
MScalarFieldKeysT = TypeVar('MScalarFieldKeysT', bound=MScalarFieldKeys)

MRelationalFieldKeys = Literal[
        'n',
    ]


# we have to import ourselves as forward references may use 'types.XFilter' syntax
from .. import enums, types  # noqa: TID251

'''