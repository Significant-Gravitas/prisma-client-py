'''
# -*- coding: utf-8 -*-
# code generated by Prisma. DO NOT EDIT.
# pyright: reportUnusedImport=false
# fmt: off

# global imports for type checking
import datetime
from typing import (
    TYPE_CHECKING,
    Any,
    Dict,
    List,
    Union,
    Literal,
    TypeVar,
    TypedDict,
)
from builtins import str as _str

LiteralString = str
# -- template types/_model.py.jinja --
# Types for model: E

from ..utils import _NoneType
from .atomic import *  # noqa: TID251
from .filters import *  # noqa: TID251
from .list_filters import *  # noqa: TID251

# Cross-import related model types for type checker resolution
if TYPE_CHECKING:
    from .a import (  # noqa: TID251
        AWhereInput,
        AOrderByInput,
        AScalarFieldKeys,
        AWhereUniqueInput,
    )
    from .b import (  # noqa: TID251
        BWhereInput,
        BOrderByInput,
        BScalarFieldKeys,
        BWhereUniqueInput,
    )
    from .c import (  # noqa: TID251
        CWhereInput,
        COrderByInput,
        CScalarFieldKeys,
        CWhereUniqueInput,
    )
    from .d import (  # noqa: TID251
        DWhereInput,
        DOrderByInput,
        DScalarFieldKeys,
        DWhereUniqueInput,
    )
    from .m import (  # noqa: TID251
        MWhereInput,
        MOrderByInput,
        MScalarFieldKeys,
        MWhereUniqueInput,
    )
    from .n import (  # noqa: TID251
        NWhereInput,
        NOrderByInput,
        NScalarFieldKeys,
        NWhereUniqueInput,
    )
    from .post import (  # noqa: TID251
        PostWhereInput,
        PostOrderByInput,
        PostScalarFieldKeys,
        PostWhereUniqueInput,
    )
    from .user import (  # noqa: TID251
        UserWhereInput,
        UserOrderByInput,
        UserScalarFieldKeys,
        UserWhereUniqueInput,
    )
    from .lists import (  # noqa: TID251
        ListsWhereInput,
        ListsOrderByInput,
        ListsScalarFieldKeys,
        ListsWhereUniqueInput,
    )
    from .oneoptional import (  # noqa: TID251
        OneOptionalWhereInput,
        OneOptionalOrderByInput,
        OneOptionalScalarFieldKeys,
        OneOptionalWhereUniqueInput,
    )
    from .manyrequired import (  # noqa: TID251
        ManyRequiredWhereInput,
        ManyRequiredOrderByInput,
        ManyRequiredScalarFieldKeys,
        ManyRequiredWhereUniqueInput,
    )





# E types

class EOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the E create method"""
    id: _str


class ECreateInput(EOptionalCreateInput):
    """Required arguments to the E create method"""
    date: datetime.datetime
    time: datetime.datetime
    ts: datetime.datetime


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class EOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the E create method, without relations"""
    id: _str


class ECreateWithoutRelationsInput(EOptionalCreateWithoutRelationsInput):
    """Required arguments to the E create method, without relations"""
    date: datetime.datetime
    time: datetime.datetime
    ts: datetime.datetime

class EConnectOrCreateWithoutRelationsInput(TypedDict):
    create: 'ECreateWithoutRelationsInput'
    where: 'EWhereUniqueInput'

class ECreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'ECreateWithoutRelationsInput'
    connect: 'EWhereUniqueInput'
    connect_or_create: 'EConnectOrCreateWithoutRelationsInput'


class ECreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['ECreateWithoutRelationsInput', List['ECreateWithoutRelationsInput']]
    connect: Union['EWhereUniqueInput', List['EWhereUniqueInput']]
    connect_or_create: Union['EConnectOrCreateWithoutRelationsInput', List['EConnectOrCreateWithoutRelationsInput']]

_EWhereUnique_id_Input = TypedDict(
    '_EWhereUnique_id_Input',
    {
        'id': '_str',
    },
    total=True
)

EWhereUniqueInput = _EWhereUnique_id_Input


class EUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: _str
    date: datetime.datetime
    time: datetime.datetime
    ts: datetime.datetime


class EUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: _str
    date: datetime.datetime
    time: datetime.datetime
    ts: datetime.datetime


class EUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['ECreateWithoutRelationsInput']
    connect: List['EWhereUniqueInput']
    connect_or_create: List['EConnectOrCreateWithoutRelationsInput']
    set: List['EWhereUniqueInput']
    disconnect: List['EWhereUniqueInput']
    delete: List['EWhereUniqueInput']

    # TODO
    # update: List['EUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['EUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['EScalarWhereInput']
    # upsert: List['EUpserteWithWhereUniqueWithoutRelationsInput']


class EUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'ECreateWithoutRelationsInput'
    connect: 'EWhereUniqueInput'
    connect_or_create: 'EConnectOrCreateWithoutRelationsInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'EUpdateInput'
    # upsert: 'EUpsertWithoutRelationsInput'


class EUpsertInput(TypedDict):
    create: 'ECreateInput'
    update: 'EUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_E_id_OrderByInput = TypedDict(
    '_E_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_E_date_OrderByInput = TypedDict(
    '_E_date_OrderByInput',
    {
        'date': 'SortOrder',
    },
    total=True
)

_E_time_OrderByInput = TypedDict(
    '_E_time_OrderByInput',
    {
        'time': 'SortOrder',
    },
    total=True
)

_E_ts_OrderByInput = TypedDict(
    '_E_ts_OrderByInput',
    {
        'ts': 'SortOrder',
    },
    total=True
)

_E_RelevanceInner = TypedDict(
    '_E_RelevanceInner',
    {
        'fields': 'List[EScalarFieldKeys]',
        'search': 'str',
        'sort': 'SortOrder',
    },
    total=True
)

_E_RelevanceOrderByInput = TypedDict(
    '_E_RelevanceOrderByInput',
    {
        '_relevance': '_E_RelevanceInner',
    },
    total=True
)

EOrderByInput = Union[
    '_E_id_OrderByInput',
    '_E_date_OrderByInput',
    '_E_time_OrderByInput',
    '_E_ts_OrderByInput',
    '_E_RelevanceOrderByInput',
]



# recursive E types
# TODO: cleanup these types


# Dict[str, Any] is a mypy limitation
# see https://github.com/RobertCraigie/prisma-client-py/issues/45
# switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/stable/reference/limitations/

ERelationFilter = TypedDict(
    'ERelationFilter',
    {
        'is': 'Dict[str, Any]',
        'is_not': 'Dict[str, Any]',
    },
    total=False,
)


class EListRelationFilter(TypedDict, total=False):
    some: 'Dict[str, Any]'
    none: 'Dict[str, Any]'
    every: 'Dict[str, Any]'


class EInclude(TypedDict, total=False):
    """E relational arguments"""


    

class PostIncludeFromE(TypedDict, total=False):
    """Relational arguments for E"""
    author: Union[bool, 'UserArgsFromERecursive1']


class PostIncludeFromERecursive1(TypedDict, total=False):
    """Relational arguments for E"""
    author: Union[bool, 'UserArgsFromERecursive2']


class PostIncludeFromERecursive2(TypedDict, total=False):
    """Relational arguments for E"""

    

class PostArgsFromE(TypedDict, total=False):
    """Arguments for E"""
    include: 'PostIncludeFromERecursive1'


class PostArgsFromERecursive1(TypedDict, total=False):
    """Arguments for E"""
    include: 'PostIncludeFromERecursive2'


class PostArgsFromERecursive2(TypedDict, total=False):
    """Arguments for E"""
    
    

class FindManyPostArgsFromE(TypedDict, total=False):
    """Arguments for E"""
    take: int
    skip: int
    order_by: Union['PostOrderByInput', List['PostOrderByInput']]
    where: 'PostWhereInput'
    cursor: 'PostWhereUniqueInput'
    distinct: List['PostScalarFieldKeys']
    include: 'PostIncludeFromERecursive1'


class FindManyPostArgsFromERecursive1(TypedDict, total=False):
    """Arguments for E"""
    take: int
    skip: int
    order_by: Union['PostOrderByInput', List['PostOrderByInput']]
    where: 'PostWhereInput'
    cursor: 'PostWhereUniqueInput'
    distinct: List['PostScalarFieldKeys']
    include: 'PostIncludeFromERecursive2'


class FindManyPostArgsFromERecursive2(TypedDict, total=False):
    """Arguments for E"""
    take: int
    skip: int
    order_by: Union['PostOrderByInput', List['PostOrderByInput']]
    where: 'PostWhereInput'
    cursor: 'PostWhereUniqueInput'
    distinct: List['PostScalarFieldKeys']
        

class UserIncludeFromE(TypedDict, total=False):
    """Relational arguments for E"""
    posts: Union[bool, 'FindManyPostArgsFromERecursive1']


class UserIncludeFromERecursive1(TypedDict, total=False):
    """Relational arguments for E"""
    posts: Union[bool, 'FindManyPostArgsFromERecursive2']


class UserIncludeFromERecursive2(TypedDict, total=False):
    """Relational arguments for E"""

    

class UserArgsFromE(TypedDict, total=False):
    """Arguments for E"""
    include: 'UserIncludeFromERecursive1'


class UserArgsFromERecursive1(TypedDict, total=False):
    """Arguments for E"""
    include: 'UserIncludeFromERecursive2'


class UserArgsFromERecursive2(TypedDict, total=False):
    """Arguments for E"""
    
    

class FindManyUserArgsFromE(TypedDict, total=False):
    """Arguments for E"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromERecursive1'


class FindManyUserArgsFromERecursive1(TypedDict, total=False):
    """Arguments for E"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromERecursive2'


class FindManyUserArgsFromERecursive2(TypedDict, total=False):
    """Arguments for E"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
        

class MIncludeFromE(TypedDict, total=False):
    """Relational arguments for E"""
    n: Union[bool, 'FindManyNArgsFromERecursive1']


class MIncludeFromERecursive1(TypedDict, total=False):
    """Relational arguments for E"""
    n: Union[bool, 'FindManyNArgsFromERecursive2']


class MIncludeFromERecursive2(TypedDict, total=False):
    """Relational arguments for E"""

    

class MArgsFromE(TypedDict, total=False):
    """Arguments for E"""
    include: 'MIncludeFromERecursive1'


class MArgsFromERecursive1(TypedDict, total=False):
    """Arguments for E"""
    include: 'MIncludeFromERecursive2'


class MArgsFromERecursive2(TypedDict, total=False):
    """Arguments for E"""
    
    

class FindManyMArgsFromE(TypedDict, total=False):
    """Arguments for E"""
    take: int
    skip: int
    order_by: Union['MOrderByInput', List['MOrderByInput']]
    where: 'MWhereInput'
    cursor: 'MWhereUniqueInput'
    distinct: List['MScalarFieldKeys']
    include: 'MIncludeFromERecursive1'


class FindManyMArgsFromERecursive1(TypedDict, total=False):
    """Arguments for E"""
    take: int
    skip: int
    order_by: Union['MOrderByInput', List['MOrderByInput']]
    where: 'MWhereInput'
    cursor: 'MWhereUniqueInput'
    distinct: List['MScalarFieldKeys']
    include: 'MIncludeFromERecursive2'


class FindManyMArgsFromERecursive2(TypedDict, total=False):
    """Arguments for E"""
    take: int
    skip: int
    order_by: Union['MOrderByInput', List['MOrderByInput']]
    where: 'MWhereInput'
    cursor: 'MWhereUniqueInput'
    distinct: List['MScalarFieldKeys']
        

class NIncludeFromE(TypedDict, total=False):
    """Relational arguments for E"""
    m: Union[bool, 'FindManyMArgsFromERecursive1']


class NIncludeFromERecursive1(TypedDict, total=False):
    """Relational arguments for E"""
    m: Union[bool, 'FindManyMArgsFromERecursive2']


class NIncludeFromERecursive2(TypedDict, total=False):
    """Relational arguments for E"""

    

class NArgsFromE(TypedDict, total=False):
    """Arguments for E"""
    include: 'NIncludeFromERecursive1'


class NArgsFromERecursive1(TypedDict, total=False):
    """Arguments for E"""
    include: 'NIncludeFromERecursive2'


class NArgsFromERecursive2(TypedDict, total=False):
    """Arguments for E"""
    
    

class FindManyNArgsFromE(TypedDict, total=False):
    """Arguments for E"""
    take: int
    skip: int
    order_by: Union['NOrderByInput', List['NOrderByInput']]
    where: 'NWhereInput'
    cursor: 'NWhereUniqueInput'
    distinct: List['NScalarFieldKeys']
    include: 'NIncludeFromERecursive1'


class FindManyNArgsFromERecursive1(TypedDict, total=False):
    """Arguments for E"""
    take: int
    skip: int
    order_by: Union['NOrderByInput', List['NOrderByInput']]
    where: 'NWhereInput'
    cursor: 'NWhereUniqueInput'
    distinct: List['NScalarFieldKeys']
    include: 'NIncludeFromERecursive2'


class FindManyNArgsFromERecursive2(TypedDict, total=False):
    """Arguments for E"""
    take: int
    skip: int
    order_by: Union['NOrderByInput', List['NOrderByInput']]
    where: 'NWhereInput'
    cursor: 'NWhereUniqueInput'
    distinct: List['NScalarFieldKeys']
        

class OneOptionalIncludeFromE(TypedDict, total=False):
    """Relational arguments for E"""
    many: Union[bool, 'FindManyManyRequiredArgsFromERecursive1']


class OneOptionalIncludeFromERecursive1(TypedDict, total=False):
    """Relational arguments for E"""
    many: Union[bool, 'FindManyManyRequiredArgsFromERecursive2']


class OneOptionalIncludeFromERecursive2(TypedDict, total=False):
    """Relational arguments for E"""

    

class OneOptionalArgsFromE(TypedDict, total=False):
    """Arguments for E"""
    include: 'OneOptionalIncludeFromERecursive1'


class OneOptionalArgsFromERecursive1(TypedDict, total=False):
    """Arguments for E"""
    include: 'OneOptionalIncludeFromERecursive2'


class OneOptionalArgsFromERecursive2(TypedDict, total=False):
    """Arguments for E"""
    
    

class FindManyOneOptionalArgsFromE(TypedDict, total=False):
    """Arguments for E"""
    take: int
    skip: int
    order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
    where: 'OneOptionalWhereInput'
    cursor: 'OneOptionalWhereUniqueInput'
    distinct: List['OneOptionalScalarFieldKeys']
    include: 'OneOptionalIncludeFromERecursive1'


class FindManyOneOptionalArgsFromERecursive1(TypedDict, total=False):
    """Arguments for E"""
    take: int
    skip: int
    order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
    where: 'OneOptionalWhereInput'
    cursor: 'OneOptionalWhereUniqueInput'
    distinct: List['OneOptionalScalarFieldKeys']
    include: 'OneOptionalIncludeFromERecursive2'


class FindManyOneOptionalArgsFromERecursive2(TypedDict, total=False):
    """Arguments for E"""
    take: int
    skip: int
    order_by: Union['OneOptionalOrderByInput', List['OneOptionalOrderByInput']]
    where: 'OneOptionalWhereInput'
    cursor: 'OneOptionalWhereUniqueInput'
    distinct: List['OneOptionalScalarFieldKeys']
        

class ManyRequiredIncludeFromE(TypedDict, total=False):
    """Relational arguments for E"""
    one: Union[bool, 'OneOptionalArgsFromERecursive1']


class ManyRequiredIncludeFromERecursive1(TypedDict, total=False):
    """Relational arguments for E"""
    one: Union[bool, 'OneOptionalArgsFromERecursive2']


class ManyRequiredIncludeFromERecursive2(TypedDict, total=False):
    """Relational arguments for E"""

    

class ManyRequiredArgsFromE(TypedDict, total=False):
    """Arguments for E"""
    include: 'ManyRequiredIncludeFromERecursive1'


class ManyRequiredArgsFromERecursive1(TypedDict, total=False):
    """Arguments for E"""
    include: 'ManyRequiredIncludeFromERecursive2'


class ManyRequiredArgsFromERecursive2(TypedDict, total=False):
    """Arguments for E"""
    
    

class FindManyManyRequiredArgsFromE(TypedDict, total=False):
    """Arguments for E"""
    take: int
    skip: int
    order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
    where: 'ManyRequiredWhereInput'
    cursor: 'ManyRequiredWhereUniqueInput'
    distinct: List['ManyRequiredScalarFieldKeys']
    include: 'ManyRequiredIncludeFromERecursive1'


class FindManyManyRequiredArgsFromERecursive1(TypedDict, total=False):
    """Arguments for E"""
    take: int
    skip: int
    order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
    where: 'ManyRequiredWhereInput'
    cursor: 'ManyRequiredWhereUniqueInput'
    distinct: List['ManyRequiredScalarFieldKeys']
    include: 'ManyRequiredIncludeFromERecursive2'


class FindManyManyRequiredArgsFromERecursive2(TypedDict, total=False):
    """Arguments for E"""
    take: int
    skip: int
    order_by: Union['ManyRequiredOrderByInput', List['ManyRequiredOrderByInput']]
    where: 'ManyRequiredWhereInput'
    cursor: 'ManyRequiredWhereUniqueInput'
    distinct: List['ManyRequiredScalarFieldKeys']
        

class ListsIncludeFromE(TypedDict, total=False):
    """Relational arguments for E"""


class ListsIncludeFromERecursive1(TypedDict, total=False):
    """Relational arguments for E"""


class ListsIncludeFromERecursive2(TypedDict, total=False):
    """Relational arguments for E"""

    

class ListsArgsFromE(TypedDict, total=False):
    """Arguments for E"""
    include: 'ListsIncludeFromERecursive1'


class ListsArgsFromERecursive1(TypedDict, total=False):
    """Arguments for E"""
    include: 'ListsIncludeFromERecursive2'


class ListsArgsFromERecursive2(TypedDict, total=False):
    """Arguments for E"""
    
    

class FindManyListsArgsFromE(TypedDict, total=False):
    """Arguments for E"""
    take: int
    skip: int
    order_by: Union['ListsOrderByInput', List['ListsOrderByInput']]
    where: 'ListsWhereInput'
    cursor: 'ListsWhereUniqueInput'
    distinct: List['ListsScalarFieldKeys']
    include: 'ListsIncludeFromERecursive1'


class FindManyListsArgsFromERecursive1(TypedDict, total=False):
    """Arguments for E"""
    take: int
    skip: int
    order_by: Union['ListsOrderByInput', List['ListsOrderByInput']]
    where: 'ListsWhereInput'
    cursor: 'ListsWhereUniqueInput'
    distinct: List['ListsScalarFieldKeys']
    include: 'ListsIncludeFromERecursive2'


class FindManyListsArgsFromERecursive2(TypedDict, total=False):
    """Arguments for E"""
    take: int
    skip: int
    order_by: Union['ListsOrderByInput', List['ListsOrderByInput']]
    where: 'ListsWhereInput'
    cursor: 'ListsWhereUniqueInput'
    distinct: List['ListsScalarFieldKeys']
        

class AIncludeFromE(TypedDict, total=False):
    """Relational arguments for E"""


class AIncludeFromERecursive1(TypedDict, total=False):
    """Relational arguments for E"""


class AIncludeFromERecursive2(TypedDict, total=False):
    """Relational arguments for E"""

    

class AArgsFromE(TypedDict, total=False):
    """Arguments for E"""
    include: 'AIncludeFromERecursive1'


class AArgsFromERecursive1(TypedDict, total=False):
    """Arguments for E"""
    include: 'AIncludeFromERecursive2'


class AArgsFromERecursive2(TypedDict, total=False):
    """Arguments for E"""
    
    

class FindManyAArgsFromE(TypedDict, total=False):
    """Arguments for E"""
    take: int
    skip: int
    order_by: Union['AOrderByInput', List['AOrderByInput']]
    where: 'AWhereInput'
    cursor: 'AWhereUniqueInput'
    distinct: List['AScalarFieldKeys']
    include: 'AIncludeFromERecursive1'


class FindManyAArgsFromERecursive1(TypedDict, total=False):
    """Arguments for E"""
    take: int
    skip: int
    order_by: Union['AOrderByInput', List['AOrderByInput']]
    where: 'AWhereInput'
    cursor: 'AWhereUniqueInput'
    distinct: List['AScalarFieldKeys']
    include: 'AIncludeFromERecursive2'


class FindManyAArgsFromERecursive2(TypedDict, total=False):
    """Arguments for E"""
    take: int
    skip: int
    order_by: Union['AOrderByInput', List['AOrderByInput']]
    where: 'AWhereInput'
    cursor: 'AWhereUniqueInput'
    distinct: List['AScalarFieldKeys']
        

class BIncludeFromE(TypedDict, total=False):
    """Relational arguments for E"""


class BIncludeFromERecursive1(TypedDict, total=False):
    """Relational arguments for E"""


class BIncludeFromERecursive2(TypedDict, total=False):
    """Relational arguments for E"""

    

class BArgsFromE(TypedDict, total=False):
    """Arguments for E"""
    include: 'BIncludeFromERecursive1'


class BArgsFromERecursive1(TypedDict, total=False):
    """Arguments for E"""
    include: 'BIncludeFromERecursive2'


class BArgsFromERecursive2(TypedDict, total=False):
    """Arguments for E"""
    
    

class FindManyBArgsFromE(TypedDict, total=False):
    """Arguments for E"""
    take: int
    skip: int
    order_by: Union['BOrderByInput', List['BOrderByInput']]
    where: 'BWhereInput'
    cursor: 'BWhereUniqueInput'
    distinct: List['BScalarFieldKeys']
    include: 'BIncludeFromERecursive1'


class FindManyBArgsFromERecursive1(TypedDict, total=False):
    """Arguments for E"""
    take: int
    skip: int
    order_by: Union['BOrderByInput', List['BOrderByInput']]
    where: 'BWhereInput'
    cursor: 'BWhereUniqueInput'
    distinct: List['BScalarFieldKeys']
    include: 'BIncludeFromERecursive2'


class FindManyBArgsFromERecursive2(TypedDict, total=False):
    """Arguments for E"""
    take: int
    skip: int
    order_by: Union['BOrderByInput', List['BOrderByInput']]
    where: 'BWhereInput'
    cursor: 'BWhereUniqueInput'
    distinct: List['BScalarFieldKeys']
        

class CIncludeFromE(TypedDict, total=False):
    """Relational arguments for E"""


class CIncludeFromERecursive1(TypedDict, total=False):
    """Relational arguments for E"""


class CIncludeFromERecursive2(TypedDict, total=False):
    """Relational arguments for E"""

    

class CArgsFromE(TypedDict, total=False):
    """Arguments for E"""
    include: 'CIncludeFromERecursive1'


class CArgsFromERecursive1(TypedDict, total=False):
    """Arguments for E"""
    include: 'CIncludeFromERecursive2'


class CArgsFromERecursive2(TypedDict, total=False):
    """Arguments for E"""
    
    

class FindManyCArgsFromE(TypedDict, total=False):
    """Arguments for E"""
    take: int
    skip: int
    order_by: Union['COrderByInput', List['COrderByInput']]
    where: 'CWhereInput'
    cursor: 'CWhereUniqueInput'
    distinct: List['CScalarFieldKeys']
    include: 'CIncludeFromERecursive1'


class FindManyCArgsFromERecursive1(TypedDict, total=False):
    """Arguments for E"""
    take: int
    skip: int
    order_by: Union['COrderByInput', List['COrderByInput']]
    where: 'CWhereInput'
    cursor: 'CWhereUniqueInput'
    distinct: List['CScalarFieldKeys']
    include: 'CIncludeFromERecursive2'


class FindManyCArgsFromERecursive2(TypedDict, total=False):
    """Arguments for E"""
    take: int
    skip: int
    order_by: Union['COrderByInput', List['COrderByInput']]
    where: 'CWhereInput'
    cursor: 'CWhereUniqueInput'
    distinct: List['CScalarFieldKeys']
        

class DIncludeFromE(TypedDict, total=False):
    """Relational arguments for E"""


class DIncludeFromERecursive1(TypedDict, total=False):
    """Relational arguments for E"""


class DIncludeFromERecursive2(TypedDict, total=False):
    """Relational arguments for E"""

    

class DArgsFromE(TypedDict, total=False):
    """Arguments for E"""
    include: 'DIncludeFromERecursive1'


class DArgsFromERecursive1(TypedDict, total=False):
    """Arguments for E"""
    include: 'DIncludeFromERecursive2'


class DArgsFromERecursive2(TypedDict, total=False):
    """Arguments for E"""
    
    

class FindManyDArgsFromE(TypedDict, total=False):
    """Arguments for E"""
    take: int
    skip: int
    order_by: Union['DOrderByInput', List['DOrderByInput']]
    where: 'DWhereInput'
    cursor: 'DWhereUniqueInput'
    distinct: List['DScalarFieldKeys']
    include: 'DIncludeFromERecursive1'


class FindManyDArgsFromERecursive1(TypedDict, total=False):
    """Arguments for E"""
    take: int
    skip: int
    order_by: Union['DOrderByInput', List['DOrderByInput']]
    where: 'DWhereInput'
    cursor: 'DWhereUniqueInput'
    distinct: List['DScalarFieldKeys']
    include: 'DIncludeFromERecursive2'


class FindManyDArgsFromERecursive2(TypedDict, total=False):
    """Arguments for E"""
    take: int
    skip: int
    order_by: Union['DOrderByInput', List['DOrderByInput']]
    where: 'DWhereInput'
    cursor: 'DWhereUniqueInput'
    distinct: List['DScalarFieldKeys']
        

class EIncludeFromE(TypedDict, total=False):
    """Relational arguments for E"""


class EIncludeFromERecursive1(TypedDict, total=False):
    """Relational arguments for E"""


class EIncludeFromERecursive2(TypedDict, total=False):
    """Relational arguments for E"""

    

class EArgsFromE(TypedDict, total=False):
    """Arguments for E"""
    include: 'EIncludeFromERecursive1'


class EArgsFromERecursive1(TypedDict, total=False):
    """Arguments for E"""
    include: 'EIncludeFromERecursive2'


class EArgsFromERecursive2(TypedDict, total=False):
    """Arguments for E"""
    
    

class FindManyEArgsFromE(TypedDict, total=False):
    """Arguments for E"""
    take: int
    skip: int
    order_by: Union['EOrderByInput', List['EOrderByInput']]
    where: 'EWhereInput'
    cursor: 'EWhereUniqueInput'
    distinct: List['EScalarFieldKeys']
    include: 'EIncludeFromERecursive1'


class FindManyEArgsFromERecursive1(TypedDict, total=False):
    """Arguments for E"""
    take: int
    skip: int
    order_by: Union['EOrderByInput', List['EOrderByInput']]
    where: 'EWhereInput'
    cursor: 'EWhereUniqueInput'
    distinct: List['EScalarFieldKeys']
    include: 'EIncludeFromERecursive2'


class FindManyEArgsFromERecursive2(TypedDict, total=False):
    """Arguments for E"""
    take: int
    skip: int
    order_by: Union['EOrderByInput', List['EOrderByInput']]
    where: 'EWhereInput'
    cursor: 'EWhereUniqueInput'
    distinct: List['EScalarFieldKeys']
    

FindManyEArgs = FindManyEArgsFromE
FindFirstEArgs = FindManyEArgsFromE


    

class EWhereInput(TypedDict, total=False):
    """E arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    date: Union[datetime.datetime, 'types.DateTimeFilter']
    time: Union[datetime.datetime, 'types.DateTimeFilter']
    ts: Union[datetime.datetime, 'types.DateTimeFilter']

    # should be noted that AND and NOT should be Union['EWhereInputRecursive1', List['EWhereInputRecursive1']]
    # but this causes mypy to hang :/
    AND: List['EWhereInputRecursive1']
    OR: List['EWhereInputRecursive1']
    NOT: List['EWhereInputRecursive1']


class EWhereInputRecursive1(TypedDict, total=False):
    """E arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    date: Union[datetime.datetime, 'types.DateTimeFilter']
    time: Union[datetime.datetime, 'types.DateTimeFilter']
    ts: Union[datetime.datetime, 'types.DateTimeFilter']

    # should be noted that AND and NOT should be Union['EWhereInputRecursive2', List['EWhereInputRecursive2']]
    # but this causes mypy to hang :/
    AND: List['EWhereInputRecursive2']
    OR: List['EWhereInputRecursive2']
    NOT: List['EWhereInputRecursive2']


class EWhereInputRecursive2(TypedDict, total=False):
    """E arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    date: Union[datetime.datetime, 'types.DateTimeFilter']
    time: Union[datetime.datetime, 'types.DateTimeFilter']
    ts: Union[datetime.datetime, 'types.DateTimeFilter']



# aggregate E types


    

class EScalarWhereWithAggregatesInput(TypedDict, total=False):
    """E arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    date: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    time: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    ts: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['EScalarWhereWithAggregatesInputRecursive1']
    OR: List['EScalarWhereWithAggregatesInputRecursive1']
    NOT: List['EScalarWhereWithAggregatesInputRecursive1']


class EScalarWhereWithAggregatesInputRecursive1(TypedDict, total=False):
    """E arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    date: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    time: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    ts: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['EScalarWhereWithAggregatesInputRecursive2']
    OR: List['EScalarWhereWithAggregatesInputRecursive2']
    NOT: List['EScalarWhereWithAggregatesInputRecursive2']


class EScalarWhereWithAggregatesInputRecursive2(TypedDict, total=False):
    """E arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    date: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    time: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    ts: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']



class EGroupByOutput(TypedDict, total=False):
    id: _str
    date: datetime.datetime
    time: datetime.datetime
    ts: datetime.datetime
    _sum: 'ESumAggregateOutput'
    _avg: 'EAvgAggregateOutput'
    _min: 'EMinAggregateOutput'
    _max: 'EMaxAggregateOutput'
    _count: 'ECountAggregateOutput'


class EAvgAggregateOutput(TypedDict, total=False):
    """E output for aggregating averages"""


class ESumAggregateOutput(TypedDict, total=False):
    """E output for aggregating sums"""


class EScalarAggregateOutput(TypedDict, total=False):
    """E output including scalar fields"""
    id: _str
    date: datetime.datetime
    time: datetime.datetime
    ts: datetime.datetime


EMinAggregateOutput = EScalarAggregateOutput
EMaxAggregateOutput = EScalarAggregateOutput


class EMaxAggregateInput(TypedDict, total=False):
    """E input for aggregating by max"""
    id: bool
    date: bool
    time: bool
    ts: bool


class EMinAggregateInput(TypedDict, total=False):
    """E input for aggregating by min"""
    id: bool
    date: bool
    time: bool
    ts: bool


class ENumberAggregateInput(TypedDict, total=False):
    """E input for aggregating numbers"""


EAvgAggregateInput = ENumberAggregateInput
ESumAggregateInput = ENumberAggregateInput


ECountAggregateInput = TypedDict(
    'ECountAggregateInput',
    {
        'id': bool,
        'date': bool,
        'time': bool,
        'ts': bool,
        '_all': bool,
    },
    total=False,
)

ECountAggregateOutput = TypedDict(
    'ECountAggregateOutput',
    {
        'id': int,
        'date': int,
        'time': int,
        'ts': int,
        '_all': int,
    },
    total=False,
)


EKeys = Literal[
    'id',
    'date',
    'time',
    'ts',
]
EScalarFieldKeys = Literal[
    'id',
    'date',
    'time',
    'ts',
]
EScalarFieldKeysT = TypeVar('EScalarFieldKeysT', bound=EScalarFieldKeys)

ERelationalFieldKeys = _NoneType


# we have to import ourselves as forward references may use 'types.XFilter' syntax
from .. import types  # noqa: TID251

'''