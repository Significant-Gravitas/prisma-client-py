{% include '_header.py.jinja' %}
{% from '_utils.py.jinja' import recursive_types with context %}
# -- template types/_model.py.jinja --
# Types for model: {{ model.name }}

from ..utils import _NoneType
from .filters import *
from .atomic import *
from .list_filters import *

# Cross-import related model types for type checker resolution
if TYPE_CHECKING:
{% for other_model in all_models %}
{% if other_model.name != model.name %}
    from .{{ other_model.name | lower }} import (
        {{ other_model.name }}WhereInput,
        {{ other_model.name }}WhereUniqueInput,
        {{ other_model.name }}OrderByInput,
        {{ other_model.name }}ScalarFieldKeys,
        {{ other_model.name }}RelationFilter,
        {{ other_model.name }}ListRelationFilter,
        {{ other_model.name }}CreateWithoutRelationsInput,
        {{ other_model.name }}CreateNestedWithoutRelationsInput,
        {{ other_model.name }}CreateManyNestedWithoutRelationsInput,
        {{ other_model.name }}UpdateOneWithoutRelationsInput,
        {{ other_model.name }}UpdateManyWithoutRelationsInput,
        {{ other_model.name }}ConnectOrCreateWithoutRelationsInput,
    )
{% endif %}
{% endfor %}


{% set depth = generator.config.recursive_type_depth %}

{% macro recursive(base) %}
    {% if recursive_types %}
{{ caller(base, base, '') }}
    {% else %}
    {%+ for i in range(depth) -%}
        {% if i == 0 %}
            {% set name = base %}
        {% else %}
            {% set name = base + 'Recursive%s' % i %}
        {% endif %}

        {% if i == depth - 1 %}
            {% set iteration = '' %}
        {% else %}
            {% set iteration = 'Recursive%s' % (i + 1) %}
        {% endif %}

        {% if iteration %}
            {% set next = base + iteration %}
        {% else %}
            {% set next = '' %}
        {% endif %}
{{ caller(name, next, iteration) }}
    {%- endfor %}
    {% endif %}
{% endmacro %}

{% macro render_type(type) %}
{# It is important that we render subtypes first so that references can be resolved correctly #}
{% for subtype in type.subtypes %}
{{ render_type(subtype) }}
{% endfor %}
{% if type.kind == 'alias' %}
{{ type.name }} = {{ type.to }}
{% elif type.kind == 'union' %}
{{ type.name }} = Union[
    {% for variant in type.variants %}
    '{{ variant.name }}',
    {% endfor %}
]
{% elif type.kind == 'typeddict' %}
{# We use the old syntax for defined TypedDicts so that fields that shadow keywords #}
{# can be defined, e.g. 'not' #}
{{ type.name }} = TypedDict(
    '{{ type.name }}',
    {
        {% for field, subtype in type.fields.items() %}
        '{{ field }}': {{ type_as_string(subtype) }},
        {% endfor %}
    },
    total={{ type.total }}
)
{% elif type.kind == 'enum' %}
class {{ type.name }}(StrEnum):
    {% for name, value in type.members %}
    {{ name }} = "{{ value }}"
    {% endfor %}
{% else %}
{{ raise_err('Unhandled type kind: %s' % type.kind) }}
{% endif %}
{% endmacro %}

# {{ model.name }} types

class {{ model.name }}OptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the {{ model.name }} create method"""
    {% for field in model.all_fields %}
        {%- if not field.required_on_create or field.is_read_only -%}
            {{'    '}}{{ field.name }}: {{ field.maybe_optional(field.create_input_type) }}
        {% endif %}
    {% endfor %}


class {{ model.name }}CreateInput({{ model.name }}OptionalCreateInput):
    """Required arguments to the {{ model.name }} create method"""
    {% for field in model.all_fields %}
        {%- if field.required_on_create and not field.is_read_only -%}
            {{'    '}}{{ field.name }}: {{ field.maybe_optional(field.create_input_type) }}
        {% endif %}
    {% endfor %}


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class {{ model.name }}OptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the {{ model.name }} create method, without relations"""
    {% for field in model.scalar_fields %}
        {%- if not field.required_on_create or field.is_read_only -%}
            {{'    '}}{{ field.name }}: {{ field.maybe_optional(field.create_input_type) }}
        {% endif %}
    {% endfor %}


class {{ model.name }}CreateWithoutRelationsInput({{ model.name }}OptionalCreateWithoutRelationsInput):
    """Required arguments to the {{ model.name }} create method, without relations"""
    {% for field in model.scalar_fields %}
        {%- if field.required_on_create and not field.is_read_only -%}
            {{'    '}}{{ field.name }}: {{ field.maybe_optional(field.create_input_type) }}
        {% endif %}
    {% endfor %}

class {{ model.name }}ConnectOrCreateWithoutRelationsInput(TypedDict):
    create: '{{ model.name }}CreateWithoutRelationsInput'
    where: '{{ model.name }}WhereUniqueInput'

class {{ model.name }}CreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: '{{ model.name }}CreateWithoutRelationsInput'
    connect: '{{ model.name }}WhereUniqueInput'
    connect_or_create: '{{ model.name }}ConnectOrCreateWithoutRelationsInput'


class {{ model.name }}CreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['{{ model.name }}CreateWithoutRelationsInput', List['{{ model.name }}CreateWithoutRelationsInput']]
    connect: Union['{{ model.name }}WhereUniqueInput', List['{{ model.name }}WhereUniqueInput']]
    connect_or_create: Union['{{ model.name }}ConnectOrCreateWithoutRelationsInput', List['{{ model.name }}ConnectOrCreateWithoutRelationsInput']]

{{ render_type(model_schema.where_unique) }}

class {{ model.name }}UpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    {% for field in model.all_fields %}
        {%- if not field.is_read_only -%}
            {{'    '}}{{ field.name }}: {{ field.maybe_optional(field.get_update_input_type()) }}
        {% endif %}
    {% endfor %}


class {{ model.name }}UpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    {% for field in model.scalar_fields %}
        {%- if not field.is_read_only -%}
            {{'    '}}{{ field.name }}: {{ field.maybe_optional(field.get_update_input_type()) }}
        {% endif %}
    {% endfor %}


class {{ model.name }}UpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['{{ model.name }}CreateWithoutRelationsInput']
    connect: List['{{ model.name }}WhereUniqueInput']
    connect_or_create: List['{{ model.name }}ConnectOrCreateWithoutRelationsInput']
    set: List['{{ model.name }}WhereUniqueInput']
    disconnect: List['{{ model.name }}WhereUniqueInput']
    delete: List['{{ model.name }}WhereUniqueInput']

    # TODO
    # update: List['{{ model.name }}UpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['{{ model.name }}UpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['{{ model.name }}ScalarWhereInput']
    # upsert: List['{{ model.name }}UpserteWithWhereUniqueWithoutRelationsInput']


class {{ model.name }}UpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: '{{ model.name }}CreateWithoutRelationsInput'
    connect: '{{ model.name }}WhereUniqueInput'
    connect_or_create: '{{ model.name }}ConnectOrCreateWithoutRelationsInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: '{{ model.name }}UpdateInput'
    # upsert: '{{ model.name }}UpsertWithoutRelationsInput'


class {{ model.name }}UpsertInput(TypedDict):
    create: '{{ model.name }}CreateInput'
    update: '{{ model.name }}UpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


{{ render_type(model_schema.order_by) }}


# recursive {{ model.name }} types
# TODO: cleanup these types


{% if recursive_types %}
    {% set where_input_type = model.name + 'WhereInput' %}
{% else %}
# Dict[str, Any] is a mypy limitation
# see https://github.com/RobertCraigie/prisma-client-py/issues/45
# switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/stable/reference/limitations/
    {% set where_input_type = 'Dict[str, Any]' %}
{% endif %}

{{ model.name }}RelationFilter = TypedDict(
    '{{ model.name }}RelationFilter',
    {
        'is': '{{ where_input_type }}',
        'is_not': '{{ where_input_type }}',
    },
    total=False,
)


class {{ model.name }}ListRelationFilter(TypedDict, total=False):
    some: '{{ where_input_type }}'
    none: '{{ where_input_type }}'
    every: '{{ where_input_type }}'


class {{ model.name }}Include(TypedDict, total=False):
    """{{ model.name }} relational arguments"""
    {% for field in model.relational_fields -%}
        {{'    '}}{{ field.name }}: Union[bool, '{{ field.relational_args_type }}From{{ model.name }}']
    {% endfor %}


{% for related in all_models %}
{% call(name, next, iteration) recursive('%sIncludeFrom%s' % (related.name, model.name)) %}
class {{ name }}(TypedDict, total=False):
    """Relational arguments for {{model.name }}"""
    {% if next != '' -%}
        {% for field in related.relational_fields -%}
            {{'    '}}{{ field.name }}: Union[bool, '{{ field.relational_args_type }}From{{ model.name + iteration }}']
        {% endfor %}
    {% endif %}
{% endcall %}

{% call(name, next, iteration) recursive('%sArgsFrom%s' % (related.name, model.name)) %}
class {{ name }}(TypedDict, total=False):
    """Arguments for {{model.name }}"""
    {%+ if next != '' -%}
        include: '{{ related.name }}IncludeFrom{{ model.name + iteration}}'
    {% endif %}
{% endcall %}

{% call(name, next, iteration) recursive('FindMany%sArgsFrom%s' % (related.name, model.name)) %}
class {{ name }}(TypedDict, total=False):
    """Arguments for {{model.name }}"""
    take: int
    skip: int
    order_by: Union['{{ related.name }}OrderByInput', List['{{ related.name }}OrderByInput']]
    where: '{{ related.name }}WhereInput'
    cursor: '{{ related.name }}WhereUniqueInput'
    distinct: List['{{ related.name }}ScalarFieldKeys']
    {%+ if next != '' -%}
        include: '{{ related.name }}IncludeFrom{{ model.name + iteration}}'
    {% endif %}
{% endcall %}

{% endfor %}


FindMany{{ model.name }}Args = FindMany{{ model.name }}ArgsFrom{{ model.name }}
FindFirst{{ model.name }}Args = FindMany{{ model.name }}ArgsFrom{{ model.name}}


{% call(current, next, iteration) recursive(model.name + 'WhereInput') %}
class {{ current }}(TypedDict, total=False):
    """{{ model.name }} arguments for searching"""
    {% for field in model.all_fields -%}
        {{'    '}}{{ field.name }}: {{ field.where_input_type }}
    {% endfor %}

    {% if next != '' %}
    # should be noted that AND and NOT should be Union['{{ next }}', List['{{ next }}']]
    # but this causes mypy to hang :/
    AND: List['{{ next }}']
    OR: List['{{ next }}']
    NOT: List['{{ next }}']
    {% endif %}
{% endcall %}


# aggregate {{ model.name }} types


{% call(current, next, iteration) recursive(model.name + 'ScalarWhereWithAggregatesInput') %}
class {{ current }}(TypedDict, total=False):
    """{{ model.name }} arguments for searching"""
    {% for field in model.scalar_fields %}
    {{ field.name }}: {{ field.where_aggregates_input_type }}
    {% endfor %}

    {% if next != '' %}
    AND: List['{{ next }}']
    OR: List['{{ next }}']
    NOT: List['{{ next }}']
    {% endif %}
{% endcall %}


class {{ model.name }}GroupByOutput(TypedDict, total=False):
    {% for field in model.scalar_fields -%}
        {{ '    ' }}{{ field.name }}: {{ field.python_type }}
    {% endfor %}
    _sum: '{{ model.name }}SumAggregateOutput'
    _avg: '{{ model.name }}AvgAggregateOutput'
    _min: '{{ model.name }}MinAggregateOutput'
    _max: '{{ model.name }}MaxAggregateOutput'
    _count: '{{ model.name }}CountAggregateOutput'


class {{ model.name }}AvgAggregateOutput(TypedDict, total=False):
    """{{ model.name }} output for aggregating averages"""
    {% for field in model.scalar_fields %}
        {% if field.is_number -%}
            {{ '    ' }}{{ field.name }}: float
        {% endif %}
    {% endfor %}


class {{ model.name }}SumAggregateOutput(TypedDict, total=False):
    """{{ model.name }} output for aggregating sums"""
    {% for field in model.scalar_fields %}
        {% if field.is_number -%}
            {{ '    ' }}{{ field.name }}: {{ field.python_type }}
        {% endif %}
    {% endfor %}


class {{ model.name }}ScalarAggregateOutput(TypedDict, total=False):
    """{{ model.name }} output including scalar fields"""
    {% for field in model.scalar_fields -%}
        {{ '    ' }}{{ field.name }}: {{ field.python_type }}
    {% endfor %}


{{ model.name }}MinAggregateOutput = {{ model.name }}ScalarAggregateOutput
{{ model.name }}MaxAggregateOutput = {{ model.name }}ScalarAggregateOutput


class {{ model.name }}MaxAggregateInput(TypedDict, total=False):
    """{{ model.name }} input for aggregating by max"""
    {% for field in model.scalar_fields -%}
        {{ '    ' }}{{ field.name }}: bool
    {% endfor %}


class {{ model.name }}MinAggregateInput(TypedDict, total=False):
    """{{ model.name }} input for aggregating by min"""
    {% for field in model.scalar_fields -%}
        {{ '    ' }}{{ field.name }}: bool
    {% endfor %}


class {{ model.name }}NumberAggregateInput(TypedDict, total=False):
    """{{ model.name }} input for aggregating numbers"""
    {% for field in model.scalar_fields %}
        {% if field.is_number -%}
            {{ '    ' }}{{ field.name }}: bool
        {% endif %}
    {% endfor %}


{{ model.name }}AvgAggregateInput = {{ model.name }}NumberAggregateInput
{{ model.name }}SumAggregateInput = {{ model.name }}NumberAggregateInput


{{ model.name }}CountAggregateInput = TypedDict(
    '{{ model.name }}CountAggregateInput',
    {
        {% for field in model.scalar_fields %}
        '{{ field.name }}': bool,
        {% endfor %}
        '_all': bool,
    },
    total=False,
)

{{ model.name }}CountAggregateOutput = TypedDict(
    '{{ model.name }}CountAggregateOutput',
    {
        {% for field in model.scalar_fields %}
        '{{ field.name }}': int,
        {% endfor %}
        '_all': int,
    },
    total=False,
)


{{ model.name }}Keys = Literal[
    {% for field in model.all_fields %}
    '{{ field.name }}',
    {% endfor %}
]
{{ model.name }}ScalarFieldKeys = Literal[
    {% for field in model.scalar_fields %}
    '{{ field.name }}',
    {% endfor %}
]
{{ model.name }}ScalarFieldKeysT = TypeVar('{{ model.name }}ScalarFieldKeysT', bound={{ model.name }}ScalarFieldKeys)

{% if model.has_relational_fields -%}
    {{ model.name }}RelationalFieldKeys = Literal[
        {% for field in model.relational_fields %}
        '{{ field.name }}',
        {% endfor %}
    ]
{% else -%}
    {{ model.name }}RelationalFieldKeys = _NoneType
{% endif %}


# we have to import ourselves as forward references may use 'types.XFilter' syntax
from .. import types, enums, fields
